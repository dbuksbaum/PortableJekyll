var search_data = {"index":{"searchIndex":["encoding","http","message","array","body","parts","headers","status","httpaccess2","client","retryableresponse","session","badresponse","error","invalidstate","keepalivedisconnected","httpclient","authbase","authfilterbase","badresponse","badresponseerror","basicauth","configurationerror","connecttimeouterror","connection","cookiemanager","debugsocket","digestauth","includeclient","keepalivedisconnected","loopbacksocket","negotiateauth","oauth","config","proxyauth","proxybasicauth","proxydigestauth","receivetimeouterror","retryableresponse","sslconfig","sslsocketwrap","sspinegotiateauth","sendtimeouterror","session","sessionmanager","site","socketwrap","timeout","timeouterror","timeoutscheduler","period","util","addressable","addressableuri","wwwauth","webagentsaver","hexdump","jsonclient","oauthclient","string","uri","generic","webagent","cookie","cookiemanager","error","erroroverrideok","specialerror","cookieutils","synchronizedarray","<<()","<<()","<<()","<<()","==()","[]()","[]=()","add()","add()","add()","add()","add_cached_session()","add_crl()","add_size()","add_trust_ca()","add_trust_ca_to_store()","addr()","all()","argument_to_hash()","argument_to_hash_for_json()","attr_proxy()","authority()","body()","body()","body=()","body_encoding()","body_size=()","build_query_multipart_str()","calc_cred()","calc_cred()","cancel()","cancel()","cert_store=()","challenge()","challenge()","challenge()","challenge()","challenge()","challenge()","challenge()","change_notify()","charset_label()","check_cookie_accept_domain()","check_cookie_accept_domain()","check_cookies_file()","check_cookies_file()","check_domain()","check_domain()","check_expired_cookies()","check_expired_cookies()","check_mask()","ciphers=()","clear_cert_store()","client_cert=()","client_key=()","close()","close()","close()","close()","close()","close_all()","closed?()","closed?()","closed?()","code()","connect()","connect_ssl_proxy()","content()","content()","content_type()","content_type()","content_type=()","content_type=()","contenttype()","contenttype()","contenttype=()","contenttype=()","cookie_error()","cookie_error()","cookie_to_record()","cookie_value()","cookie_value()","cookies()","cookies()","cookies()","cookies()","cookies=()","cookies=()","create_base_string()","create_boundary()","create_openssl_socket()","create_query_part()","create_query_uri()","create_request()","create_socket()","create_ssl_socket()","debug()","debug()","debug_dev()","debug_dev=()","debug_dev=()","default_options()","default_redirect_uri_callback()","default_verify_callback()","delete()","delete()","delete_async()","deprecated()","discard?()","do_get_block()","do_get_config()","do_get_header()","do_get_stream()","do_request()","do_request_async()","domain()","domain_match()","domain_orig?()","dump()","dump()","dump()","dump_chunk()","dump_chunk_size()","dump_chunked()","dump_chunks()","dump_dummy_request_response()","dump_file()","dump_last_chunk()","empty_bin_str()","encode()","encode()","encode_header()","encode_param()","eof?()","eof?()","eof?()","eql?()","escape()","file?()","file_in_form_data?()","filter_request()","filter_request()","filter_response()","filter_response()","filter_response()","find()","find()","finished?()","flag()","flag()","flush()","flush()","follow_redirect()","force_basic_auth=()","generate_cnonce()","generate_nonce()","get()","get()","get()","get()","get()","get()","get()","get()","get()","get_access_token()","get_async()","get_body()","get_cached_session()","get_config()","get_content()","get_header()","get_mime_type_func()","get_oauth_response()","get_request_token()","get_session()","getenv()","gets()","gets()","gets()","hash_find_value()","hash_find_value()","hashy_argument_has_keys()","head()","head_async()","head_match?()","headers()","hostname()","hostname()","http?()","http_body=()","http_only?()","http_version()","http_version=()","https?()","include_http_client()","init_connect_request()","init_request()","init_request()","init_response()","init_response()","internal_mime_type()","join()","join_quotedstr()","json_header()","keep()","keep_alive_enabled?()","keep_webmock_compat()","keyword_argument()","load()","load_cacerts()","load_cookies()","load_cookies()","load_environment()","load_trust_ca()","make_cookie_str()","make_cookie_str()","match()","match?()","mime_type_handler()","mime_type_handler=()","multiparam_query?()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new_connect_request()","new_request()","new_response()","no_message_body?()","no_proxy()","no_proxy=()","no_proxy?()","normalize_cookie_value()","ok?()","open()","options()","options=()","options_async()","original_domain()","override?()","override_header()","params_from_file()","parse()","parse()","parse()","parse()","parse()","parse_authentication_header()","parse_challenge_header()","parse_challenge_param()","parse_header()","parse_keepalive_header()","parse_record()","parts()","path_orig?()","peer_cert()","pop()","port()","post()","post()","post_async()","post_connection_check()","post_content()","propfind()","propfind_async()","proppatch()","proppatch_async()","protect_keep_alive_disconnected()","proxy()","proxy=()","proxy=()","put()","put()","put_async()","query()","query()","raise()","read()","read()","read()","read_body_chunked()","read_body_length()","read_body_rest()","read_header()","readpartial()","readpartial()","readpartial()","reason()","reason=()","redirect?()","redirect?()","redirect_uri_callback=()","regex_quote_n()","register()","remember_pos()","request()","request()","request_async()","request_async2()","request_line()","reset()","reset()","reset_all()","reset_all()","reset_challenge()","reset_challenge()","reset_challenge()","reset_challenge()","reset_pos()","response_status_line()","sample_verify_callback()","save()","save_all_cookies()","save_all_cookies()","save_cookie_store()","save_cookies()","save_cookies()","scrub_cached_session()","secure?()","see_other?()","set()","set()","set()","set()","set()","set()","set()","set()","set?()","set?()","set?()","set?()","set?()","set_auth()","set_auth()","set_auth()","set_basic_auth()","set_body_encoding()","set_client_cert_file()","set_config()","set_content()","set_cookie_store()","set_crl()","set_date_header()","set_default_paths()","set_encoding()","set_flag()","set_flag()","set_header()","set_header()","set_headers()","set_mime_type_func()","set_proxy_auth()","set_request_header()","set_response_header()","set_trust_ca()","sign()","sign_hmac_sha1()","ssl_cipher()","ssl_connect()","ssl_state()","ssl_version()","ssl_version=()","start_timer_thread()","status()","status=()","status_code()","status_code=()","strict_redirect_uri_callback()","success_content()","successful?()","sync()","sync()","sync=()","sync=()","tail_match?()","timeout()","timeout=()","timeout_scheduler()","to_resource_url()","trace()","trace_async()","try_convert()","try_require()","try_require()","unescape()","unescape()","uri_dirname()","uri_dirname()","uri_part_of()","uri_part_of()","urify()","urify()","url()","url=()","use?()","valid_session?()","verify_callback=()","verify_depth=()","verify_mode=()","version()","version=()","wrap_json_response()","cacert.p7s"],"longSearchIndex":["encoding","http","http::message","http::message::array","http::message::body","http::message::body::parts","http::message::headers","http::status","httpaccess2","httpaccess2::client","httpaccess2::client::retryableresponse","httpaccess2::session","httpaccess2::session::badresponse","httpaccess2::session::error","httpaccess2::session::invalidstate","httpaccess2::session::keepalivedisconnected","httpclient","httpclient::authbase","httpclient::authfilterbase","httpclient::badresponse","httpclient::badresponseerror","httpclient::basicauth","httpclient::configurationerror","httpclient::connecttimeouterror","httpclient::connection","httpclient::cookiemanager","httpclient::debugsocket","httpclient::digestauth","httpclient::includeclient","httpclient::keepalivedisconnected","httpclient::loopbacksocket","httpclient::negotiateauth","httpclient::oauth","httpclient::oauth::config","httpclient::proxyauth","httpclient::proxybasicauth","httpclient::proxydigestauth","httpclient::receivetimeouterror","httpclient::retryableresponse","httpclient::sslconfig","httpclient::sslsocketwrap","httpclient::sspinegotiateauth","httpclient::sendtimeouterror","httpclient::session","httpclient::sessionmanager","httpclient::site","httpclient::socketwrap","httpclient::timeout","httpclient::timeouterror","httpclient::timeoutscheduler","httpclient::timeoutscheduler::period","httpclient::util","httpclient::util::addressable","httpclient::util::addressableuri","httpclient::wwwauth","httpclient::webagentsaver","hexdump","jsonclient","oauthclient","string","uri","uri::generic","webagent","webagent::cookie","webagent::cookiemanager","webagent::cookiemanager::error","webagent::cookiemanager::erroroverrideok","webagent::cookiemanager::specialerror","webagent::cookieutils","webagent::synchronizedarray","httpclient::debugsocket#<<()","httpclient::loopbacksocket#<<()","httpclient::sslsocketwrap#<<()","httpclient::socketwrap#<<()","httpclient::site#==()","http::message::headers#[]()","http::message::headers#[]=()","http::message::body::parts#add()","http::message::headers#add()","httpclient::cookiemanager#add()","httpclient::cookiemanager#add()","httpclient::sessionmanager#add_cached_session()","httpclient::sslconfig#add_crl()","http::message::body::parts#add_size()","httpclient::sslconfig#add_trust_ca()","httpclient::sslconfig#add_trust_ca_to_store()","httpclient::site#addr()","http::message::headers#all()","httpclient::util#argument_to_hash()","jsonclient#argument_to_hash_for_json()","httpclient::attr_proxy()","httpclient::util::addressableuri#authority()","http::message#body()","httpclient#body()","http::message#body=()","http::message#body_encoding()","http::message::headers#body_size=()","http::message::body#build_query_multipart_str()","httpclient::digestauth#calc_cred()","httpclient::oauth#calc_cred()","httpclient::timeoutscheduler#cancel()","httpclient::timeoutscheduler::period#cancel()","httpclient::sslconfig#cert_store=()","httpclient::basicauth#challenge()","httpclient::digestauth#challenge()","httpclient::negotiateauth#challenge()","httpclient::oauth#challenge()","httpclient::proxybasicauth#challenge()","httpclient::proxydigestauth#challenge()","httpclient::sspinegotiateauth#challenge()","httpclient::sslconfig#change_notify()","http::message::headers#charset_label()","webagent::cookiemanager#check_cookie_accept_domain()","webagent::cookiemanager#check_cookie_accept_domain()","httpclient::cookiemanager#check_cookies_file()","httpclient::cookiemanager#check_cookies_file()","webagent::cookiemanager#check_domain()","webagent::cookiemanager#check_domain()","webagent::cookiemanager#check_expired_cookies()","webagent::cookiemanager#check_expired_cookies()","httpclient::sslsocketwrap#check_mask()","httpclient::sslconfig#ciphers=()","httpclient::sslconfig#clear_cert_store()","httpclient::sslconfig#client_cert=()","httpclient::sslconfig#client_key=()","httpclient::debugsocket#close()","httpclient::sslsocketwrap#close()","httpclient::session#close()","httpclient::sessionmanager#close()","httpclient::socketwrap#close()","httpclient::sessionmanager#close_all()","httpclient::sslsocketwrap#closed?()","httpclient::session#closed?()","httpclient::socketwrap#closed?()","http::message#code()","httpclient::session#connect()","httpclient::session#connect_ssl_proxy()","http::message#content()","http::message::body#content()","http::message#content_type()","http::message::headers#content_type()","http::message#content_type=()","http::message::headers#content_type=()","http::message#contenttype()","http::message::headers#contenttype()","http::message#contenttype=()","http::message::headers#contenttype=()","webagent::cookiemanager#cookie_error()","webagent::cookiemanager#cookie_error()","httpclient::webagentsaver#cookie_to_record()","httpclient::cookiemanager#cookie_value()","httpclient::cookiemanager#cookie_value()","http::message#cookies()","httpclient#cookies()","httpclient::cookiemanager#cookies()","httpclient::cookiemanager#cookies()","httpclient::cookiemanager#cookies=()","httpclient::cookiemanager#cookies=()","httpclient::oauth#create_base_string()","httpclient#create_boundary()","httpclient::sslsocketwrap#create_openssl_socket()","http::message::headers#create_query_part()","http::message::headers#create_query_uri()","httpclient#create_request()","httpclient::session#create_socket()","httpclient::session#create_ssl_socket()","httpclient::debugsocket#debug()","httpclient::sslsocketwrap#debug()","httpclient#debug_dev()","httpclient#debug_dev=()","httpclient::debugsocket#debug_dev=()","httpclient::webagentsaver#default_options()","httpclient#default_redirect_uri_callback()","httpclient::sslconfig#default_verify_callback()","http::message::headers#delete()","httpclient#delete()","httpclient#delete_async()","webagent::cookie#deprecated()","webagent::cookie#discard?()","httpclient#do_get_block()","httpclient::oauth#do_get_config()","httpclient#do_get_header()","httpclient#do_get_stream()","httpclient#do_request()","httpclient#do_request_async()","webagent::cookie#domain()","webagent::cookieutils#domain_match()","webagent::cookie#domain_orig?()","http::message#dump()","http::message::body#dump()","http::message::headers#dump()","http::message::body#dump_chunk()","http::message::body#dump_chunk_size()","http::message::body#dump_chunked()","http::message::body#dump_chunks()","httpclient#dump_dummy_request_response()","http::message::body#dump_file()","http::message::body#dump_last_chunk()","httpclient::session#empty_bin_str()","hexdump::encode()","hexdump#encode()","httpclient::oauth#encode_header()","httpclient::oauth#encode_param()","httpclient::sslsocketwrap#eof?()","httpclient::session#eof?()","httpclient::socketwrap#eof?()","httpclient::site#eql?()","httpclient::oauth#escape()","http::message::file?()","httpclient#file_in_form_data?()","httpclient::proxyauth#filter_request()","httpclient::wwwauth#filter_request()","httpclient::proxyauth#filter_response()","httpclient::wwwauth#filter_response()","oauthclient#filter_response()","httpclient::cookiemanager#find()","httpclient::cookiemanager#find()","httpclient::connection#finished?()","httpclient::webagentsaver::flag()","webagent::cookie#flag()","httpclient::sslsocketwrap#flush()","httpclient::socketwrap#flush()","httpclient#follow_redirect()","httpclient#force_basic_auth=()","httpclient::digestauth#generate_cnonce()","httpclient::oauth#generate_nonce()","http::message::headers#get()","httpclient#get()","httpclient::basicauth#get()","httpclient::digestauth#get()","httpclient::negotiateauth#get()","httpclient::oauth#get()","httpclient::proxybasicauth#get()","httpclient::proxydigestauth#get()","httpclient::sspinegotiateauth#get()","oauthclient#get_access_token()","httpclient#get_async()","httpclient::session#get_body()","httpclient::sessionmanager#get_cached_session()","httpclient::oauth#get_config()","httpclient#get_content()","httpclient::session#get_header()","http::message::get_mime_type_func()","oauthclient#get_oauth_response()","oauthclient#get_request_token()","httpclient::sessionmanager#get_session()","httpclient#getenv()","httpclient::debugsocket#gets()","httpclient::sslsocketwrap#gets()","httpclient::socketwrap#gets()","httpclient::util::hash_find_value()","httpclient::util#hash_find_value()","httpclient#hashy_argument_has_keys()","httpclient#head()","httpclient#head_async()","webagent::cookieutils#head_match?()","http::message#headers()","httpclient::util::addressableuri#hostname()","uri::generic#hostname()","httpclient::util#http?()","http::message#http_body=()","webagent::cookie#http_only?()","http::message#http_version()","http::message#http_version=()","httpclient::util#https?()","httpclient::includeclient#include_http_client()","http::message::headers#init_connect_request()","http::message::body#init_request()","http::message::headers#init_request()","http::message::body#init_response()","http::message::headers#init_response()","http::message::internal_mime_type()","httpclient::connection#join()","webagent::cookie#join_quotedstr()","jsonclient#json_header()","httpclient::sessionmanager#keep()","http::message::keep_alive_enabled?()","httpclient#keep_webmock_compat()","httpclient::util#keyword_argument()","httpclient::webagentsaver#load()","httpclient::sslconfig#load_cacerts()","httpclient::cookiemanager#load_cookies()","httpclient::cookiemanager#load_cookies()","httpclient#load_environment()","httpclient::sslconfig#load_trust_ca()","webagent::cookiemanager#make_cookie_str()","webagent::cookiemanager#make_cookie_str()","httpclient::site#match()","webagent::cookie#match?()","http::message::mime_type_handler()","http::message::mime_type_handler=()","http::message::multiparam_query?()","http::message::body::new()","http::message::body::parts::new()","http::message::headers::new()","httpclient::new()","httpclient::authbase::new()","httpclient::basicauth::new()","httpclient::cookiemanager::new()","httpclient::cookiemanager::new()","httpclient::digestauth::new()","httpclient::loopbacksocket::new()","httpclient::negotiateauth::new()","httpclient::oauth::new()","httpclient::oauth::config::new()","httpclient::proxyauth::new()","httpclient::sslconfig::new()","httpclient::sslsocketwrap::new()","httpclient::sspinegotiateauth::new()","httpclient::session::new()","httpclient::sessionmanager::new()","httpclient::site::new()","httpclient::socketwrap::new()","httpclient::timeoutscheduler::new()","httpclient::timeoutscheduler::period::new()","httpclient::wwwauth::new()","jsonclient::new()","oauthclient::new()","webagent::cookie::new()","http::message::new_connect_request()","http::message::new_request()","http::message::new_response()","httpclient::session#no_message_body?()","httpclient#no_proxy()","httpclient#no_proxy=()","httpclient#no_proxy?()","webagent::cookie#normalize_cookie_value()","http::message#ok?()","httpclient::sessionmanager#open()","httpclient#options()","httpclient::sslconfig#options=()","httpclient#options_async()","webagent::cookie#original_domain()","webagent::cookie#override?()","httpclient#override_header()","http::message::body#params_from_file()","http::message::parse()","httpclient::cookiemanager#parse()","httpclient::cookiemanager#parse()","webagent::cookie::parse()","webagent::cookie#parse()","httpclient::authfilterbase#parse_authentication_header()","httpclient::authfilterbase#parse_challenge_header()","httpclient::digestauth#parse_challenge_param()","httpclient::session#parse_header()","httpclient::session#parse_keepalive_header()","httpclient::webagentsaver#parse_record()","http::message::body::parts#parts()","webagent::cookie#path_orig?()","httpclient::sslsocketwrap#peer_cert()","httpclient::connection#pop()","httpclient::util::addressableuri#port()","httpclient#post()","jsonclient#post()","httpclient#post_async()","httpclient::sslsocketwrap#post_connection_check()","httpclient#post_content()","httpclient#propfind()","httpclient#propfind_async()","httpclient#proppatch()","httpclient#proppatch_async()","httpclient#protect_keep_alive_disconnected()","httpclient#proxy()","httpclient#proxy=()","httpclient::sessionmanager#proxy=()","httpclient#put()","jsonclient#put()","httpclient#put_async()","httpclient::session#query()","httpclient::sessionmanager#query()","httpclient::timeoutscheduler::period#raise()","httpclient::debugsocket#read()","httpclient::sslsocketwrap#read()","httpclient::socketwrap#read()","httpclient::session#read_body_chunked()","httpclient::session#read_body_length()","httpclient::session#read_body_rest()","httpclient::session#read_header()","httpclient::debugsocket#readpartial()","httpclient::sslsocketwrap#readpartial()","httpclient::socketwrap#readpartial()","http::message#reason()","http::message#reason=()","http::message#redirect?()","http::status::redirect?()","httpclient#redirect_uri_callback=()","hexdump::regex_quote_n()","httpclient::timeoutscheduler#register()","http::message::body#remember_pos()","httpclient#request()","jsonclient#request()","httpclient#request_async()","httpclient#request_async2()","http::message::headers#request_line()","httpclient#reset()","httpclient::sessionmanager#reset()","httpclient#reset_all()","httpclient::sessionmanager#reset_all()","httpclient::authbase#reset_challenge()","httpclient::proxyauth#reset_challenge()","httpclient::proxydigestauth#reset_challenge()","httpclient::wwwauth#reset_challenge()","http::message::body#reset_pos()","http::message::headers#response_status_line()","httpclient::sslconfig#sample_verify_callback()","httpclient::webagentsaver#save()","webagent::cookiemanager#save_all_cookies()","webagent::cookiemanager#save_all_cookies()","httpclient#save_cookie_store()","httpclient::cookiemanager#save_cookies()","httpclient::cookiemanager#save_cookies()","httpclient::sessionmanager#scrub_cached_session()","webagent::cookie#secure?()","http::message#see_other?()","http::message::headers#set()","httpclient::basicauth#set()","httpclient::digestauth#set()","httpclient::negotiateauth#set()","httpclient::oauth#set()","httpclient::proxybasicauth#set()","httpclient::proxydigestauth#set()","httpclient::sspinegotiateauth#set()","httpclient::basicauth#set?()","httpclient::digestauth#set?()","httpclient::negotiateauth#set?()","httpclient::oauth#set?()","httpclient::sspinegotiateauth#set?()","httpclient#set_auth()","httpclient::proxyauth#set_auth()","httpclient::wwwauth#set_auth()","httpclient#set_basic_auth()","http::message::headers#set_body_encoding()","httpclient::sslconfig#set_client_cert_file()","httpclient::oauth#set_config()","http::message::body#set_content()","httpclient#set_cookie_store()","httpclient::sslconfig#set_crl()","http::message::headers#set_date_header()","httpclient::sslconfig#set_default_paths()","httpclient#set_encoding()","httpclient::webagentsaver::set_flag()","webagent::cookie#set_flag()","http::message::headers#set_header()","httpclient::session#set_header()","http::message::headers#set_headers()","http::message::set_mime_type_func()","httpclient#set_proxy_auth()","http::message::headers#set_request_header()","http::message::headers#set_response_header()","httpclient::sslconfig#set_trust_ca()","httpclient::oauth#sign()","httpclient::oauth#sign_hmac_sha1()","httpclient::sslsocketwrap#ssl_cipher()","httpclient::sslsocketwrap#ssl_connect()","httpclient::sslsocketwrap#ssl_state()","httpclient::sslsocketwrap#ssl_version()","httpclient::sslconfig#ssl_version=()","httpclient::timeoutscheduler#start_timer_thread()","http::message#status()","http::message#status=()","http::message#status_code()","http::message::headers#status_code=()","httpclient#strict_redirect_uri_callback()","httpclient#success_content()","http::status::successful?()","httpclient::sslsocketwrap#sync()","httpclient::socketwrap#sync()","httpclient::sslsocketwrap#sync=()","httpclient::socketwrap#sync=()","webagent::cookieutils#tail_match?()","httpclient::timeout#timeout()","httpclient::sslconfig#timeout=()","httpclient::timeout_scheduler()","httpclient#to_resource_url()","httpclient#trace()","httpclient#trace_async()","http::message::array::try_convert()","httpclient::util#try_require()","httpclient::util::try_require()","http::message::unescape()","oauthclient#unescape()","httpclient::util#uri_dirname()","httpclient::util::uri_dirname()","httpclient::util::uri_part_of()","httpclient::util#uri_part_of()","httpclient::util#urify()","httpclient::util::urify()","webagent::cookie#url()","webagent::cookie#url=()","webagent::cookie#use?()","httpclient::sessionmanager#valid_session?()","httpclient::sslconfig#verify_callback=()","httpclient::sslconfig#verify_depth=()","httpclient::sslconfig#verify_mode=()","http::message#version()","http::message#version=()","jsonclient#wrap_json_response()",""],"info":[["Encoding","","Encoding.html","",""],["HTTP","","HTTP.html","","<p>A namespace module for HTTP Message definitions used by HTTPClient.\n"],["HTTP::Message","","HTTP/Message.html","","<p>Represents a HTTP message.  A message is for a request or a response.\n<p>Request message is generated from …\n"],["HTTP::Message::Array","","HTTP/Message/Array.html","",""],["HTTP::Message::Body","","HTTP/Message/Body.html","","<p>Represents HTTP message body.\n"],["HTTP::Message::Body::Parts","","HTTP/Message/Body/Parts.html","",""],["HTTP::Message::Headers","","HTTP/Message/Headers.html","","<p>Represents HTTP message header.\n"],["HTTP::Status","","HTTP/Status.html","","<p>Represents HTTP response status code.  Defines constants for HTTP response\nand some conditional methods. …\n"],["HTTPAccess2","","HTTPAccess2.html","",""],["HTTPAccess2::Client","","HTTPAccess2/Client.html","",""],["HTTPAccess2::Client::RetryableResponse","","HTTPAccess2/Client/RetryableResponse.html","",""],["HTTPAccess2::Session","","HTTPAccess2/Session.html","",""],["HTTPAccess2::Session::BadResponse","","HTTPAccess2/Session/BadResponse.html","",""],["HTTPAccess2::Session::Error","","HTTPAccess2/Session/Error.html","",""],["HTTPAccess2::Session::InvalidState","","HTTPAccess2/Session/InvalidState.html","",""],["HTTPAccess2::Session::KeepAliveDisconnected","","HTTPAccess2/Session/KeepAliveDisconnected.html","",""],["HTTPClient","","HTTPClient.html","","<p>The HTTPClient class provides several methods for accessing Web resources\nvia HTTP.\n<p>HTTPClient instance …\n"],["HTTPClient::AuthBase","","HTTPClient/AuthBase.html","","<p>Authentication filter base class.\n"],["HTTPClient::AuthFilterBase","","HTTPClient/AuthFilterBase.html","","<p>Common abstract class for authentication filter.\n<p>There are 2 authentication filters.\n<p>WWWAuth &mdash; Authentication …\n"],["HTTPClient::BadResponse","","HTTPClient/BadResponse.html","","<p>Raised for indicating HTTP response error.\n"],["HTTPClient::BadResponseError","","HTTPClient/BadResponseError.html","","<p>Raised for indicating HTTP response error.\n"],["HTTPClient::BasicAuth","","HTTPClient/BasicAuth.html","","<p>Authentication filter for handling BasicAuth negotiation. Used in WWWAuth\nand ProxyAuth.\n"],["HTTPClient::ConfigurationError","","HTTPClient/ConfigurationError.html","","<p>Raised for indicating running environment configuration error for example\naccessing via SSL under the …\n"],["HTTPClient::ConnectTimeoutError","","HTTPClient/ConnectTimeoutError.html","","<p>Raised for indicating a connection timeout error. You can configure\nconnection timeout via HTTPClient#connect_timeout= …\n"],["HTTPClient::Connection","","HTTPClient/Connection.html","","<p>Represents a HTTP response to an asynchronous request.  Async methods of\nHTTPClient such as get_async …\n"],["HTTPClient::CookieManager","","HTTPClient/CookieManager.html","",""],["HTTPClient::DebugSocket","","HTTPClient/DebugSocket.html","","<p>Module for intercepting Socket methods and dumps in/out to given debugging\ndevice.  debug_dev must respond …\n"],["HTTPClient::DigestAuth","","HTTPClient/DigestAuth.html","","<p>Authentication filter for handling DigestAuth negotiation. Used in WWWAuth.\n"],["HTTPClient::IncludeClient","","HTTPClient/IncludeClient.html","",""],["HTTPClient::KeepAliveDisconnected","","HTTPClient/KeepAliveDisconnected.html","",""],["HTTPClient::LoopBackSocket","","HTTPClient/LoopBackSocket.html","","<p>Dummy Socket for emulating loopback test.\n"],["HTTPClient::NegotiateAuth","","HTTPClient/NegotiateAuth.html","","<p>Authentication filter for handling Negotiate/NTLM negotiation. Used in\nWWWAuth and ProxyAuth.\n<p>NegotiateAuth …\n"],["HTTPClient::OAuth","","HTTPClient/OAuth.html","","<p>Authentication filter for handling OAuth negotiation. Used in WWWAuth.\n<p>CAUTION: This impl only support …\n"],["HTTPClient::OAuth::Config","","HTTPClient/OAuth/Config.html","",""],["HTTPClient::ProxyAuth","","HTTPClient/ProxyAuth.html","","<p>Authentication filter for handling authentication negotiation between Proxy\nserver.  Parses &#39;Proxy-Authentication&#39; …\n"],["HTTPClient::ProxyBasicAuth","","HTTPClient/ProxyBasicAuth.html","",""],["HTTPClient::ProxyDigestAuth","","HTTPClient/ProxyDigestAuth.html","","<p>Authentication filter for handling DigestAuth negotiation. Ignores uri\nargument. Used in ProxyAuth.\n"],["HTTPClient::ReceiveTimeoutError","","HTTPClient/ReceiveTimeoutError.html","","<p>Raised for indicating a response receiving timeout error. You can configure\nresponse receiving timeout …\n"],["HTTPClient::RetryableResponse","","HTTPClient/RetryableResponse.html","",""],["HTTPClient::SSLConfig","","HTTPClient/SSLConfig.html","","<p>Represents SSL configuration for HTTPClient instance. The implementation\ndepends on OpenSSL.\n<p>Trust Anchor …\n"],["HTTPClient::SSLSocketWrap","","HTTPClient/SSLSocketWrap.html","","<p>Wraps up OpenSSL::SSL::SSLSocket and offers debugging features.\n"],["HTTPClient::SSPINegotiateAuth","","HTTPClient/SSPINegotiateAuth.html","","<p>Authentication filter for handling Negotiate/NTLM negotiation. Used in\nProxyAuth.\n<p>SSPINegotiateAuth depends …\n"],["HTTPClient::SendTimeoutError","","HTTPClient/SendTimeoutError.html","","<p>Raised for indicating a request sending timeout error. You can configure\nrequest sending timeout via …\n"],["HTTPClient::Session","","HTTPClient/Session.html","","<p>Deprecated.  just for backward compatibility\n<p>Manages a HTTP session with a Site.\n"],["HTTPClient::SessionManager","","HTTPClient/SessionManager.html","","<p>Manages sessions for a HTTPClient instance.\n"],["HTTPClient::Site","","HTTPClient/Site.html","","<p>Represents a Site: protocol scheme, host String and port Number.\n"],["HTTPClient::SocketWrap","","HTTPClient/SocketWrap.html","","<p>Wraps up a Socket for method interception.\n"],["HTTPClient::Timeout","","HTTPClient/Timeout.html","",""],["HTTPClient::TimeoutError","","HTTPClient/TimeoutError.html","","<p>Raised for indicating a timeout error.\n"],["HTTPClient::TimeoutScheduler","","HTTPClient/TimeoutScheduler.html","",""],["HTTPClient::TimeoutScheduler::Period","","HTTPClient/TimeoutScheduler/Period.html","","<p>Represents timeout period.\n"],["HTTPClient::Util","","HTTPClient/Util.html","","<p>A module for common function.\n"],["HTTPClient::Util::Addressable","","HTTPClient/Util/Addressable.html","",""],["HTTPClient::Util::AddressableURI","","HTTPClient/Util/AddressableURI.html","",""],["HTTPClient::WWWAuth","","HTTPClient/WWWAuth.html","","<p>Authentication filter for handling authentication negotiation between Web\nserver.  Parses &#39;WWW-Authentication&#39; …\n"],["HTTPClient::WebAgentSaver","","HTTPClient/WebAgentSaver.html","",""],["HexDump","","HexDump.html","","<p>This was written by Arai-san and published at\nblade.nagaokaut.ac.jp/cgi-bin/scat.rb/ruby/ruby-list/31987 …\n"],["JSONClient","","JSONClient.html","","<p>JSONClient auto-converts Hash &lt;-&gt; JSON in request and response.\n<p>For POST or PUT request, convert …\n"],["OAuthClient","","OAuthClient.html","","<p>OAuthClient provides OAuth related methods in addition to HTTPClient.\n<p>See sample/ dir how to use OAuthClient …\n"],["String","","String.html","",""],["URI","","URI.html","",""],["URI::Generic","","URI/Generic.html","",""],["WebAgent","","WebAgent.html","","<p>for backward compatibility\n"],["WebAgent::Cookie","","WebAgent/Cookie.html","",""],["WebAgent::CookieManager","","WebAgent/CookieManager.html","",""],["WebAgent::CookieManager::Error","","WebAgent/CookieManager/Error.html","","<p>errors\n"],["WebAgent::CookieManager::ErrorOverrideOK","","WebAgent/CookieManager/ErrorOverrideOK.html","",""],["WebAgent::CookieManager::SpecialError","","WebAgent/CookieManager/SpecialError.html","",""],["WebAgent::CookieUtils","","WebAgent/CookieUtils.html","",""],["WebAgent::SynchronizedArray","","WebAgent/SynchronizedArray.html","","<p>An Array class that already includes the MonitorMixin module.\n"],["<<","HTTPClient::DebugSocket","HTTPClient/DebugSocket.html#method-i-3C-3C","(str)",""],["<<","HTTPClient::LoopBackSocket","HTTPClient/LoopBackSocket.html#method-i-3C-3C","(str)",""],["<<","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-3C-3C","(str)",""],["<<","HTTPClient::SocketWrap","HTTPClient/SocketWrap.html#method-i-3C-3C","(str)",""],["==","HTTPClient::Site","HTTPClient/Site.html#method-i-3D-3D","(rhs)","<p>Returns true is scheme, host and port are &#39;==&#39;\n"],["[]","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-5B-5D","(key)","<p>Returns an Array of header values for the given key.\n"],["[]=","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-5B-5D-3D","(key, value)","<p>Adds a header.  See set.\n"],["add","HTTP::Message::Body::Parts","HTTP/Message/Body/Parts.html#method-i-add","(part)",""],["add","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-add","(key, value)","<p>Adds a header.  Addition order is preserved.\n"],["add","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-add","(cookie)",""],["add","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-add","(cookie)",""],["add_cached_session","HTTPClient::SessionManager","HTTPClient/SessionManager.html#method-i-add_cached_session","(sess)",""],["add_crl","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-add_crl","(crl)","<p>Adds CRL for verification.\n<p>crl &mdash; a OpenSSL::X509::CRL or a filename of a PEM/DER formatted\nOpenSSL::X509::CRL …\n\n"],["add_size","HTTP::Message::Body::Parts","HTTP/Message/Body/Parts.html#method-i-add_size","(part, sz)",""],["add_trust_ca","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-add_trust_ca","(trust_ca_file_or_hashed_dir)","<p>Sets trust anchor certificate(s) for verification.\n<p>trust_ca_file_or_hashed_dir &mdash; a filename of a PEM/DER …\n\n"],["add_trust_ca_to_store","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-add_trust_ca_to_store","(cert_store, trust_ca_file_or_hashed_dir)",""],["addr","HTTPClient::Site","HTTPClient/Site.html#method-i-addr","()","<p>Returns address String.\n"],["all","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-all","()","<p>Returns an Array of all headers.\n"],["argument_to_hash","HTTPClient::Util","HTTPClient/Util.html#method-i-argument_to_hash","(args, *field)","<p>Keyword argument to hash helper.\n<p>args &mdash; given arguments.\n<p>*field &mdash; a list of arguments to be extracted.\n"],["argument_to_hash_for_json","JSONClient","JSONClient.html#method-i-argument_to_hash_for_json","(args)",""],["attr_proxy","HTTPClient","HTTPClient.html#method-c-attr_proxy","(symbol, assignable = false)",""],["authority","HTTPClient::Util::AddressableURI","HTTPClient/Util/AddressableURI.html#method-i-authority","()","<p>Overwrites the original definition just for one line…\n"],["body","HTTP::Message","HTTP/Message.html#method-i-body","()",""],["body","HTTPClient","HTTPClient.html#method-i-body","()",""],["body=","HTTP::Message","HTTP/Message.html#method-i-body-3D","(body)",""],["body_encoding","HTTP::Message","HTTP/Message.html#method-i-body_encoding","()","<p>Returns content encoding\n"],["body_size=","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-body_size-3D","(body_size)","<p>Sets byte size of message body. body_size == nil means that the body is_a?\nIO\n"],["build_query_multipart_str","HTTP::Message::Body","HTTP/Message/Body.html#method-i-build_query_multipart_str","(query, boundary)",""],["calc_cred","HTTPClient::DigestAuth","HTTPClient/DigestAuth.html#method-i-calc_cred","(req, user, passwd, param)","<p>this method is implemented by sromano and posted to\ntools.assembla.com/breakout/wiki/DigestForSoap Thanks …\n"],["calc_cred","HTTPClient::OAuth","HTTPClient/OAuth.html#method-i-calc_cred","(req, config)",""],["cancel","HTTPClient::TimeoutScheduler","HTTPClient/TimeoutScheduler.html#method-i-cancel","(period)","<p>Cancels the given period.\n"],["cancel","HTTPClient::TimeoutScheduler::Period","HTTPClient/TimeoutScheduler/Period.html#method-i-cancel","()","<p>Cancel this Period.  Mutex is needed to avoid too-late exception.\n"],["cert_store=","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-cert_store-3D","(cert_store)","<p>Sets new certificate store (OpenSSL::X509::Store). don&#39;t use if you\ndon&#39;t know what it is.\n<p>Calling …\n"],["challenge","HTTPClient::BasicAuth","HTTPClient/BasicAuth.html#method-i-challenge","(uri, param_str = nil)","<p>Challenge handler: remember URL for response.\n"],["challenge","HTTPClient::DigestAuth","HTTPClient/DigestAuth.html#method-i-challenge","(uri, param_str)","<p>Challenge handler: remember URL and challenge token for response.\n"],["challenge","HTTPClient::NegotiateAuth","HTTPClient/NegotiateAuth.html#method-i-challenge","(uri, param_str)","<p>Challenge handler: remember URL and challenge token for response.\n"],["challenge","HTTPClient::OAuth","HTTPClient/OAuth.html#method-i-challenge","(uri, param_str = nil)","<p>Challenge handler: remember URL for response.\n<p>challenge() in OAuth handler always returns false to avoid …\n"],["challenge","HTTPClient::ProxyBasicAuth","HTTPClient/ProxyBasicAuth.html#method-i-challenge","(uri, param_str = nil)","<p>Challenge handler: remember URL for response.\n"],["challenge","HTTPClient::ProxyDigestAuth","HTTPClient/ProxyDigestAuth.html#method-i-challenge","(uri, param_str)",""],["challenge","HTTPClient::SSPINegotiateAuth","HTTPClient/SSPINegotiateAuth.html#method-i-challenge","(uri, param_str)","<p>Challenge handler: remember URL and challenge token for response.\n"],["change_notify","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-change_notify","()",""],["charset_label","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-charset_label","()",""],["check_cookie_accept_domain","WebAgent::CookieManager","WebAgent/CookieManager.html#method-i-check_cookie_accept_domain","(domain)","<p>Who use it?\n"],["check_cookie_accept_domain","WebAgent::CookieManager","WebAgent/CookieManager.html#method-i-check_cookie_accept_domain","(domain)","<p>Who use it?\n"],["check_cookies_file","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-check_cookies_file","()",""],["check_cookies_file","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-check_cookies_file","()",""],["check_domain","WebAgent::CookieManager","WebAgent/CookieManager.html#method-i-check_domain","(domain, hostname, override)",""],["check_domain","WebAgent::CookieManager","WebAgent/CookieManager.html#method-i-check_domain","(domain, hostname, override)",""],["check_expired_cookies","WebAgent::CookieManager","WebAgent/CookieManager.html#method-i-check_expired_cookies","()",""],["check_expired_cookies","WebAgent::CookieManager","WebAgent/CookieManager.html#method-i-check_expired_cookies","()",""],["check_mask","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-check_mask","(value, mask)",""],["ciphers=","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-ciphers-3D","(ciphers)","<p>Sets cipher configuration.  New value must be a String.\n<p>Calling this method resets all existing sessions. …\n"],["clear_cert_store","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-clear_cert_store","()","<p>Drops current certificate store (OpenSSL::X509::Store) for SSL and create\nnew one for the next session. …\n"],["client_cert=","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-client_cert-3D","(client_cert)","<p>Sets certificate (OpenSSL::X509::Certificate) for SSL client\nauthentication. client_key and client_cert …\n"],["client_key=","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-client_key-3D","(client_key)","<p>Sets private key (OpenSSL::PKey::PKey) for SSL client authentication.\nclient_key and client_cert must …\n"],["close","HTTPClient::DebugSocket","HTTPClient/DebugSocket.html#method-i-close","()",""],["close","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-close","()",""],["close","HTTPClient::Session","HTTPClient/Session.html#method-i-close","()",""],["close","HTTPClient::SessionManager","HTTPClient/SessionManager.html#method-i-close","(dest)","<p>This method might not work as you expected…\n"],["close","HTTPClient::SocketWrap","HTTPClient/SocketWrap.html#method-i-close","()",""],["close_all","HTTPClient::SessionManager","HTTPClient/SessionManager.html#method-i-close_all","()",""],["closed?","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-closed-3F","()",""],["closed?","HTTPClient::Session","HTTPClient/Session.html#method-i-closed-3F","()",""],["closed?","HTTPClient::SocketWrap","HTTPClient/SocketWrap.html#method-i-closed-3F","()",""],["code","HTTP::Message","HTTP/Message.html#method-i-code","()",""],["connect","HTTPClient::Session","HTTPClient/Session.html#method-i-connect","()","<p>Connect to the server\n"],["connect_ssl_proxy","HTTPClient::Session","HTTPClient/Session.html#method-i-connect_ssl_proxy","(socket, uri)",""],["content","HTTP::Message","HTTP/Message.html#method-i-content","()","<p>Returns a content of message body.  A String or an IO.\n"],["content","HTTP::Message::Body","HTTP/Message/Body.html#method-i-content","()","<p>Returns a message body itself.\n"],["content_type","HTTP::Message","HTTP/Message.html#method-i-content_type","()","<p>Returns &#39;Content-Type&#39; header value.\n"],["content_type","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-content_type","()","<p>Returns &#39;Content-Type&#39; header value.\n"],["content_type=","HTTP::Message","HTTP/Message.html#method-i-content_type-3D","(content_type)","<p>Sets &#39;Content-Type&#39; header value.  Overrides if already exists.\n"],["content_type=","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-content_type-3D","(content_type)","<p>Sets &#39;Content-Type&#39; header value.  Overrides if already exists.\n"],["contenttype","HTTP::Message","HTTP/Message.html#method-i-contenttype","()",""],["contenttype","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-contenttype","()",""],["contenttype=","HTTP::Message","HTTP/Message.html#method-i-contenttype-3D","(content_type)",""],["contenttype=","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-contenttype-3D","(content_type)",""],["cookie_error","WebAgent::CookieManager","WebAgent/CookieManager.html#method-i-cookie_error","(err, override)","<p>not tested well; used only netscape_rule = true.\n"],["cookie_error","WebAgent::CookieManager","WebAgent/CookieManager.html#method-i-cookie_error","(err, override)","<p>not tested well; used only netscape_rule = true.\n"],["cookie_to_record","HTTPClient::WebAgentSaver","HTTPClient/WebAgentSaver.html#method-i-cookie_to_record","(cookie)",""],["cookie_value","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-cookie_value","(uri)",""],["cookie_value","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-cookie_value","(uri)",""],["cookies","HTTP::Message","HTTP/Message.html#method-i-cookies","()","<p>Extracts cookies from &#39;Set-Cookie&#39; header. Supports\n&#39;Set-Cookie&#39; in response header only. …\n"],["cookies","HTTPClient","HTTPClient.html#method-i-cookies","()","<p>Returns stored cookies.\n"],["cookies","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-cookies","(uri = nil)",""],["cookies","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-cookies","(uri = nil)",""],["cookies=","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-cookies-3D","(cookies)",""],["cookies=","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-cookies-3D","(cookies)",""],["create_base_string","HTTPClient::OAuth","HTTPClient/OAuth.html#method-i-create_base_string","(config, header, req)",""],["create_boundary","HTTPClient","HTTPClient.html#method-i-create_boundary","()",""],["create_openssl_socket","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-create_openssl_socket","(socket)",""],["create_query_part","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-create_query_part","()",""],["create_query_uri","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-create_query_uri","()",""],["create_request","HTTPClient","HTTPClient.html#method-i-create_request","(method, uri, query, body, header)",""],["create_socket","HTTPClient::Session","HTTPClient/Session.html#method-i-create_socket","(site)",""],["create_ssl_socket","HTTPClient::Session","HTTPClient/Session.html#method-i-create_ssl_socket","(raw_socket)","<p>wrap socket with OpenSSL.\n"],["debug","HTTPClient::DebugSocket","HTTPClient/DebugSocket.html#method-i-debug","(str)",""],["debug","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-debug","(str)",""],["debug_dev","HTTPClient","HTTPClient.html#method-i-debug_dev","()","<p>Returns debug device if exists.  See debug_dev=.\n"],["debug_dev=","HTTPClient","HTTPClient.html#method-i-debug_dev-3D","(dev)","<p>Sets debug device.  Once debug device is set, all HTTP requests and\nresponses are dumped to given device. …\n"],["debug_dev=","HTTPClient::DebugSocket","HTTPClient/DebugSocket.html#method-i-debug_dev-3D","(debug_dev)",""],["default_options","HTTPClient::WebAgentSaver","HTTPClient/WebAgentSaver.html#method-i-default_options","()","<p>no option\n"],["default_redirect_uri_callback","HTTPClient","HTTPClient.html#method-i-default_redirect_uri_callback","(uri, res)","<p>A default method for redirect uri callback.  This method is used by\nHTTPClient instance by default.  …\n"],["default_verify_callback","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-default_verify_callback","(is_ok, ctx)","<p>Default callback for verification: only dumps error.\n"],["delete","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-delete","(key)","<p>Deletes headers of the given key.\n"],["delete","HTTPClient","HTTPClient.html#method-i-delete","(uri, *args, &block)","<p>Sends DELETE request to the specified URL.  See request for arguments.\n"],["delete_async","HTTPClient","HTTPClient.html#method-i-delete_async","(uri, *args)","<p>Sends DELETE request in async style.  See request_async2 for arguments. It\nimmediately returns a HTTPClient::Connection …\n"],["deprecated","WebAgent::Cookie","WebAgent/Cookie.html#method-i-deprecated","(old, new)",""],["discard?","WebAgent::Cookie","WebAgent/Cookie.html#method-i-discard-3F","()",""],["do_get_block","HTTPClient","HTTPClient.html#method-i-do_get_block","(req, proxy, conn, &block)","<p>!! CAUTION !!\n\n<pre>Method &#39;do_get*&#39; runs under MT conditon. Be careful to change.</pre>\n"],["do_get_config","HTTPClient::OAuth","HTTPClient/OAuth.html#method-i-do_get_config","(uri = nil)",""],["do_get_header","HTTPClient","HTTPClient.html#method-i-do_get_header","(req, res, sess)",""],["do_get_stream","HTTPClient","HTTPClient.html#method-i-do_get_stream","(req, proxy, conn)",""],["do_request","HTTPClient","HTTPClient.html#method-i-do_request","(method, uri, query, body, header, &block)",""],["do_request_async","HTTPClient","HTTPClient.html#method-i-do_request_async","(method, uri, query, body, header)",""],["domain","WebAgent::Cookie","WebAgent/Cookie.html#method-i-domain","()",""],["domain_match","WebAgent::CookieUtils","WebAgent/CookieUtils.html#method-i-domain_match","(host, domain)",""],["domain_orig?","WebAgent::Cookie","WebAgent/Cookie.html#method-i-domain_orig-3F","()",""],["dump","HTTP::Message","HTTP/Message.html#method-i-dump","(dev = '')","<p>Dumps message (header and body) to given dev. dev needs to respond to\n&lt;&lt;.\n"],["dump","HTTP::Message::Body","HTTP/Message/Body.html#method-i-dump","(header = '', dev = '')","<p>Dumps message body to given dev. dev needs to respond to &lt;&lt;.\n<p>Message header must be given as the …\n"],["dump","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-dump","()","<p>Dumps message header part and returns a dumped String.\n"],["dump_chunk","HTTP::Message::Body","HTTP/Message/Body.html#method-i-dump_chunk","(str)",""],["dump_chunk_size","HTTP::Message::Body","HTTP/Message/Body.html#method-i-dump_chunk_size","(size)",""],["dump_chunked","HTTP::Message::Body","HTTP/Message/Body.html#method-i-dump_chunked","(header = '', dev = '')","<p>Dumps message body with chunked encoding to given dev. dev needs to respond\nto &lt;&lt;.\n<p>Message header …\n"],["dump_chunks","HTTP::Message::Body","HTTP/Message/Body.html#method-i-dump_chunks","(io, dev)",""],["dump_dummy_request_response","HTTPClient","HTTPClient.html#method-i-dump_dummy_request_response","(req, res)",""],["dump_file","HTTP::Message::Body","HTTP/Message/Body.html#method-i-dump_file","(io, dev, sz)",""],["dump_last_chunk","HTTP::Message::Body","HTTP/Message/Body.html#method-i-dump_last_chunk","()",""],["empty_bin_str","HTTPClient::Session","HTTPClient/Session.html#method-i-empty_bin_str","()",""],["encode","HexDump","HexDump.html#method-c-encode","(str)","<p>str must be in BINARY encoding in 1.9\n"],["encode","HexDump","HexDump.html#method-i-encode","(str)","<p>str must be in BINARY encoding in 1.9\n"],["encode_header","HTTPClient::OAuth","HTTPClient/OAuth.html#method-i-encode_header","(k, v)",""],["encode_param","HTTPClient::OAuth","HTTPClient/OAuth.html#method-i-encode_param","(params)",""],["eof?","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-eof-3F","()",""],["eof?","HTTPClient::Session","HTTPClient/Session.html#method-i-eof-3F","()",""],["eof?","HTTPClient::SocketWrap","HTTPClient/SocketWrap.html#method-i-eof-3F","()",""],["eql?","HTTPClient::Site","HTTPClient/Site.html#method-i-eql-3F","(rhs)","<p>Same as ==.\n"],["escape","HTTPClient::OAuth","HTTPClient/OAuth.html#method-i-escape","(str)",""],["file?","HTTP::Message","HTTP/Message.html#method-c-file-3F","(obj)","<p>Returns true if the given object is a File.  In HTTPClient, a file is;\n<p>must respond to :read for retrieving …\n"],["file_in_form_data?","HTTPClient","HTTPClient.html#method-i-file_in_form_data-3F","(body)",""],["filter_request","HTTPClient::ProxyAuth","HTTPClient/ProxyAuth.html#method-i-filter_request","(req)","<p>Filter API implementation.  Traps HTTP request and insert\n&#39;Proxy-Authorization&#39; header if needed. …\n"],["filter_request","HTTPClient::WWWAuth","HTTPClient/WWWAuth.html#method-i-filter_request","(req)","<p>Filter API implementation.  Traps HTTP request and insert\n&#39;Authorization&#39; header if needed.\n"],["filter_response","HTTPClient::ProxyAuth","HTTPClient/ProxyAuth.html#method-i-filter_response","(req, res)","<p>Filter API implementation.  Traps HTTP response and parses\n&#39;Proxy-Authenticate&#39; header.\n"],["filter_response","HTTPClient::WWWAuth","HTTPClient/WWWAuth.html#method-i-filter_response","(req, res)","<p>Filter API implementation.  Traps HTTP response and parses\n&#39;WWW-Authenticate&#39; header.\n<p>This remembers …\n"],["filter_response","OAuthClient","OAuthClient.html#method-i-filter_response","(res)",""],["find","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-find","(uri)",""],["find","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-find","(uri)",""],["finished?","HTTPClient::Connection","HTTPClient/Connection.html#method-i-finished-3F","()","<p>Checks if the asynchronous invocation has been finished or not.\n"],["flag","HTTPClient::WebAgentSaver","HTTPClient/WebAgentSaver.html#method-c-flag","(cookie)",""],["flag","WebAgent::Cookie","WebAgent/Cookie.html#method-i-flag","()",""],["flush","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-flush","()",""],["flush","HTTPClient::SocketWrap","HTTPClient/SocketWrap.html#method-i-flush","()",""],["follow_redirect","HTTPClient","HTTPClient.html#method-i-follow_redirect","(method, uri, query, body, header, &block)",""],["force_basic_auth=","HTTPClient","HTTPClient.html#method-i-force_basic_auth-3D","(force_basic_auth)","<p>Turn on/off the BasicAuth force flag. Generally HTTP client must send\nAuthorization header after it gets …\n"],["generate_cnonce","HTTPClient::DigestAuth","HTTPClient/DigestAuth.html#method-i-generate_cnonce","()","<p>cf. WEBrick::HTTPAuth::DigestAuth#generate_next_nonce(aTime)\n"],["generate_nonce","HTTPClient::OAuth","HTTPClient/OAuth.html#method-i-generate_nonce","()",""],["get","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-get","(key = nil)","<p>Returns an Array of headers for the given key.  Each element is a pair of\nkey and value.  It returns …\n"],["get","HTTPClient","HTTPClient.html#method-i-get","(uri, *args, &block)","<p>Sends GET request to the specified URL.  See request for arguments.\n"],["get","HTTPClient::BasicAuth","HTTPClient/BasicAuth.html#method-i-get","(req)","<p>Response handler: returns credential. It sends cred only when a given uri\nis;\n<p>child page of challengeable(got …\n"],["get","HTTPClient::DigestAuth","HTTPClient/DigestAuth.html#method-i-get","(req)","<p>Response handler: returns credential. It sends cred only when a given uri\nis;\n<p>child page of challengeable(got …\n"],["get","HTTPClient::NegotiateAuth","HTTPClient/NegotiateAuth.html#method-i-get","(req)","<p>Response handler: returns credential. See ruby/ntlm for negotiation state\ntransition.\n"],["get","HTTPClient::OAuth","HTTPClient/OAuth.html#method-i-get","(req)","<p>Response handler: returns credential. It sends cred only when a given uri\nis;\n<p>child page of challengeable(got …\n"],["get","HTTPClient::ProxyBasicAuth","HTTPClient/ProxyBasicAuth.html#method-i-get","(req)",""],["get","HTTPClient::ProxyDigestAuth","HTTPClient/ProxyDigestAuth.html#method-i-get","(req)","<p>overrides DigestAuth#get. Uses default user name and password regardless of\ntarget uri if the proxy has …\n"],["get","HTTPClient::SSPINegotiateAuth","HTTPClient/SSPINegotiateAuth.html#method-i-get","(req)","<p>Response handler: returns credential. See win32/sspi for negotiation state\ntransition.\n"],["get_access_token","OAuthClient","OAuthClient.html#method-i-get_access_token","(uri, request_token, request_token_secret, verifier = nil)","<p>Get access token.\n<p>uri &mdash; URI for request token.\n<p>request_token &mdash; a request token String. See get_access_token. …\n"],["get_async","HTTPClient","HTTPClient.html#method-i-get_async","(uri, *args)","<p>Sends GET request in async style.  See request_async for arguments. It\nimmediately returns a HTTPClient::Connection …\n"],["get_body","HTTPClient::Session","HTTPClient/Session.html#method-i-get_body","(&block)",""],["get_cached_session","HTTPClient::SessionManager","HTTPClient/SessionManager.html#method-i-get_cached_session","(site)",""],["get_config","HTTPClient::OAuth","HTTPClient/OAuth.html#method-i-get_config","(uri = nil)","<p>Get authentication credential.\n"],["get_content","HTTPClient","HTTPClient.html#method-i-get_content","(uri, *args, &block)","<p>Retrieves a web resource.\n<p>uri &mdash; a String or an URI object which represents an URL of web resource.\n<p>query … &mdash; "],["get_header","HTTPClient::Session","HTTPClient/Session.html#method-i-get_header","()",""],["get_mime_type_func","HTTP::Message","HTTP/Message.html#method-c-get_mime_type_func","()",""],["get_oauth_response","OAuthClient","OAuthClient.html#method-i-get_oauth_response","(res)","<p>Parse response and returns a Hash.\n"],["get_request_token","OAuthClient","OAuthClient.html#method-i-get_request_token","(uri, callback = nil, param = nil)","<p>Get request token.\n<p>uri &mdash; URI for request token.\n<p>callback &mdash; callback String. This can be nil for OAuth 1.0a …\n"],["get_session","HTTPClient::SessionManager","HTTPClient/SessionManager.html#method-i-get_session","(req, via_proxy = false)","<p>TODO: create PR for webmock&#39;s httpclient adapter to use get_session\ninstead of open so that we can …\n"],["getenv","HTTPClient","HTTPClient.html#method-i-getenv","(name)",""],["gets","HTTPClient::DebugSocket","HTTPClient/DebugSocket.html#method-i-gets","(*args)",""],["gets","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-gets","(*args)",""],["gets","HTTPClient::SocketWrap","HTTPClient/SocketWrap.html#method-i-gets","(*args)",""],["hash_find_value","HTTPClient::Util","HTTPClient/Util.html#method-c-hash_find_value","(hash, &block)","<p>Finds a value of a Hash.\n"],["hash_find_value","HTTPClient::Util","HTTPClient/Util.html#method-i-hash_find_value","(hash, &block)","<p>Finds a value of a Hash.\n"],["hashy_argument_has_keys","HTTPClient","HTTPClient.html#method-i-hashy_argument_has_keys","(args, *key)",""],["head","HTTPClient","HTTPClient.html#method-i-head","(uri, *args)","<p>Sends HEAD request to the specified URL.  See request for arguments.\n"],["head_async","HTTPClient","HTTPClient.html#method-i-head_async","(uri, *args)","<p>Sends HEAD request in async style.  See request_async for arguments. It\nimmediately returns a HTTPClient::Connection …\n"],["head_match?","WebAgent::CookieUtils","WebAgent/CookieUtils.html#method-i-head_match-3F","(str1, str2)",""],["headers","HTTP::Message","HTTP/Message.html#method-i-headers","()","<p>Returns Hash of header. key and value are both String. Each key has a\nsingle value so you can&#39;t extract …\n"],["hostname","HTTPClient::Util::AddressableURI","HTTPClient/Util/AddressableURI.html#method-i-hostname","()","<p>Captured from uri/generic.rb\n"],["hostname","URI::Generic","URI/Generic.html#method-i-hostname","()",""],["http?","HTTPClient::Util","HTTPClient/Util.html#method-i-http-3F","(uri)",""],["http_body=","HTTP::Message","HTTP/Message.html#method-i-http_body-3D","(body)","<p>Sets a new body.  header.body_size is updated with new body.size.\n"],["http_only?","WebAgent::Cookie","WebAgent/Cookie.html#method-i-http_only-3F","()",""],["http_version","HTTP::Message","HTTP/Message.html#method-i-http_version","()","<p>Returns HTTP version in a HTTP header.  String.\n"],["http_version=","HTTP::Message","HTTP/Message.html#method-i-http_version-3D","(http_version)","<p>Sets HTTP version in a HTTP header.  String.\n"],["https?","HTTPClient::Util","HTTPClient/Util.html#method-i-https-3F","(uri)","<p>Checks if the given URI is https.\n"],["include_http_client","HTTPClient::IncludeClient","HTTPClient/IncludeClient.html#method-i-include_http_client","(*args, &block)",""],["init_connect_request","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-init_connect_request","(uri)","<p>Initialize this instance as a CONNECT request.\n"],["init_request","HTTP::Message::Body","HTTP/Message/Body.html#method-i-init_request","(body = nil, boundary = nil)","<p>Initialize this instance as a request.\n"],["init_request","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-init_request","(method, uri, query = nil)","<p>Initialize this instance as a general request.\n"],["init_response","HTTP::Message::Body","HTTP/Message/Body.html#method-i-init_response","(body = nil)","<p>Initialize this instance as a response.\n"],["init_response","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-init_response","(status_code, req = nil)","<p>Initialize this instance as a response.\n"],["internal_mime_type","HTTP::Message","HTTP/Message.html#method-c-internal_mime_type","(path)","<p>Default MIME type handler. See mime_type_handler=.\n"],["join","HTTPClient::Connection","HTTPClient/Connection.html#method-i-join","()","<p>Waits the completion of the asynchronous invocation.\n"],["join_quotedstr","WebAgent::Cookie","WebAgent/Cookie.html#method-i-join_quotedstr","(array, sep)",""],["json_header","JSONClient","JSONClient.html#method-i-json_header","(header)",""],["keep","HTTPClient::SessionManager","HTTPClient/SessionManager.html#method-i-keep","(sess)","<p>assert: sess.last_used must not be nil\n"],["keep_alive_enabled?","HTTP::Message","HTTP/Message.html#method-c-keep_alive_enabled-3F","(version)","<p>Returns true if the given HTTP version allows keep alive connection.\n<p>version &mdash; String\n\n"],["keep_webmock_compat","HTTPClient","HTTPClient.html#method-i-keep_webmock_compat","()","<p>webmock 1.6.2 depends on HTTP::Message#body.content to work. let&#39;s keep\nit work iif webmock is loaded …\n"],["keyword_argument","HTTPClient::Util","HTTPClient/Util.html#method-i-keyword_argument","(args, *field)","<p>Keyword argument helper.\n<p>args &mdash; given arguments.\n<p>*field &mdash; a list of arguments to be extracted.\n"],["load","HTTPClient::WebAgentSaver","HTTPClient/WebAgentSaver.html#method-i-load","(io, jar)","<p>same as HTTP::CookieJar::CookiestxtSaver\n"],["load_cacerts","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-load_cacerts","(cert_store)",""],["load_cookies","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-load_cookies","()",""],["load_cookies","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-load_cookies","()",""],["load_environment","HTTPClient","HTTPClient.html#method-i-load_environment","()",""],["load_trust_ca","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-load_trust_ca","()","<p>Loads default trust anchors. Calling this method resets all existing\nsessions.\n"],["make_cookie_str","WebAgent::CookieManager","WebAgent/CookieManager.html#method-i-make_cookie_str","(cookie_list)",""],["make_cookie_str","WebAgent::CookieManager","WebAgent/CookieManager.html#method-i-make_cookie_str","(cookie_list)",""],["match","HTTPClient::Site","HTTPClient/Site.html#method-i-match","(uri)","<p>Returns true if scheme, host and port of the given URI matches with this.\n"],["match?","WebAgent::Cookie","WebAgent/Cookie.html#method-i-match-3F","(url)",""],["mime_type_handler","HTTP::Message","HTTP/Message.html#method-c-mime_type_handler","()","<p>Returns MIME type handler.\n"],["mime_type_handler=","HTTP::Message","HTTP/Message.html#method-c-mime_type_handler-3D","(handler)","<p>Sets MIME type handler.\n<p>handler must respond to :call with a single argument :path and returns a\nMIME …\n"],["multiparam_query?","HTTP::Message","HTTP/Message.html#method-c-multiparam_query-3F","(query)","<p>Returns true if the given query (or body) has a multiple parameter.\n"],["new","HTTP::Message::Body","HTTP/Message/Body.html#method-c-new","()","<p>Creates a Message::Body.  Use init_request or init_response for acutual\ninitialize.\n"],["new","HTTP::Message::Body::Parts","HTTP/Message/Body/Parts.html#method-c-new","()",""],["new","HTTP::Message::Headers","HTTP/Message/Headers.html#method-c-new","()","<p>Creates a Message::Headers.  Use init_request, init_response, or\ninit_connect_request for acutual initialize. …\n"],["new","HTTPClient","HTTPClient.html#method-c-new","(*args)","<p>Creates a HTTPClient instance which manages sessions, cookies, etc.\n<p>HTTPClient.new takes optional arguments …\n"],["new","HTTPClient::AuthBase","HTTPClient/AuthBase.html#method-c-new","(scheme)",""],["new","HTTPClient::BasicAuth","HTTPClient/BasicAuth.html#method-c-new","()","<p>Creates new BasicAuth filter.\n"],["new","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-c-new","(cookies_file = nil, format = WebAgentSaver)",""],["new","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-c-new","(cookies_file = nil, format = WebAgentSaver)",""],["new","HTTPClient::DigestAuth","HTTPClient/DigestAuth.html#method-c-new","()","<p>Creates new DigestAuth filter.\n"],["new","HTTPClient::LoopBackSocket","HTTPClient/LoopBackSocket.html#method-c-new","(host, port, response)",""],["new","HTTPClient::NegotiateAuth","HTTPClient/NegotiateAuth.html#method-c-new","(scheme = \"Negotiate\")","<p>Creates new NegotiateAuth filter.\n"],["new","HTTPClient::OAuth","HTTPClient/OAuth.html#method-c-new","()","<p>Creates new DigestAuth filter.\n"],["new","HTTPClient::OAuth::Config","HTTPClient/OAuth/Config.html#method-c-new","(*args)",""],["new","HTTPClient::ProxyAuth","HTTPClient/ProxyAuth.html#method-c-new","()","<p>Creates new ProxyAuth.\n"],["new","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-c-new","(client)","<p>Creates a SSLConfig.\n"],["new","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-c-new","(socket, context, debug_dev = nil)",""],["new","HTTPClient::SSPINegotiateAuth","HTTPClient/SSPINegotiateAuth.html#method-c-new","()","<p>Creates new SSPINegotiateAuth filter.\n"],["new","HTTPClient::Session","HTTPClient/Session.html#method-c-new","(client, dest, agent_name, from)",""],["new","HTTPClient::SessionManager","HTTPClient/SessionManager.html#method-c-new","(client)",""],["new","HTTPClient::Site","HTTPClient/Site.html#method-c-new","(uri = nil)","<p>Creates a new Site based on the given URI.\n"],["new","HTTPClient::SocketWrap","HTTPClient/SocketWrap.html#method-c-new","(socket, *args)",""],["new","HTTPClient::TimeoutScheduler","HTTPClient/TimeoutScheduler.html#method-c-new","()","<p>Creates new TimeoutScheduler.\n"],["new","HTTPClient::TimeoutScheduler::Period","HTTPClient/TimeoutScheduler/Period.html#method-c-new","(thread, time, ex)","<p>Creates new Period.\n"],["new","HTTPClient::WWWAuth","HTTPClient/WWWAuth.html#method-c-new","()","<p>Creates new WWWAuth.\n"],["new","JSONClient","JSONClient.html#method-c-new","(*args)",""],["new","OAuthClient","OAuthClient.html#method-c-new","(*arg)","<p>Creates a OAuthClient instance which provides OAuth related methods in\naddition to HTTPClient.\n<p>Method …\n"],["new","WebAgent::Cookie","WebAgent/Cookie.html#method-c-new","()",""],["new_connect_request","HTTP::Message","HTTP/Message.html#method-c-new_connect_request","(uri)","<p>Creates a Message instance of &#39;CONNECT&#39; request. &#39;CONNECT&#39;\nrequest does not have Body …\n"],["new_request","HTTP::Message","HTTP/Message.html#method-c-new_request","(method, uri, query = nil, body = nil, boundary = nil)","<p>Creates a Message instance of general request.\n<p>method &mdash; HTTP method String.\n<p>uri &mdash; an URI object which represents …\n"],["new_response","HTTP::Message","HTTP/Message.html#method-c-new_response","(body, req = nil)","<p>Creates a Message instance of response.\n<p>body &mdash; a String or an IO of response message body.\n\n"],["no_message_body?","HTTPClient::Session","HTTPClient/Session.html#method-i-no_message_body-3F","(status)",""],["no_proxy","HTTPClient","HTTPClient.html#method-i-no_proxy","()","<p>Returns NO_PROXY setting String if given.\n"],["no_proxy=","HTTPClient","HTTPClient.html#method-i-no_proxy-3D","(no_proxy)","<p>Sets NO_PROXY setting String.  no_proxy must be a comma separated String.\nEach entry must be &#39;host&#39; …\n"],["no_proxy?","HTTPClient","HTTPClient.html#method-i-no_proxy-3F","(uri)",""],["normalize_cookie_value","WebAgent::Cookie","WebAgent/Cookie.html#method-i-normalize_cookie_value","(value)",""],["ok?","HTTP::Message","HTTP/Message.html#method-i-ok-3F","()","<p>Convenience method to return boolean of whether we had a successful request\n"],["open","HTTPClient::SessionManager","HTTPClient/SessionManager.html#method-i-open","(uri, via_proxy = false)",""],["options","HTTPClient","HTTPClient.html#method-i-options","(uri, *args, &block)","<p>Sends OPTIONS request to the specified URL.  See request for arguments.\n"],["options=","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-options-3D","(options)","<p>Sets SSL options.  New value must be a combination of # constants\nOpenSSL::SSL::OP_*\n<p>Calling this method …\n"],["options_async","HTTPClient","HTTPClient.html#method-i-options_async","(uri, *args)","<p>Sends OPTIONS request in async style.  See request_async2 for arguments. It\nimmediately returns a HTTPClient::Connection …\n"],["original_domain","WebAgent::Cookie","WebAgent/Cookie.html#method-i-original_domain","()",""],["override?","WebAgent::Cookie","WebAgent/Cookie.html#method-i-override-3F","()",""],["override_header","HTTPClient","HTTPClient.html#method-i-override_header","(header, key, value)",""],["params_from_file","HTTP::Message::Body","HTTP/Message/Body.html#method-i-params_from_file","(value)",""],["parse","HTTP::Message","HTTP/Message.html#method-c-parse","(query)","<p>from CGI.parse\n"],["parse","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-parse","(value, uri)",""],["parse","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-parse","(value, uri)",""],["parse","WebAgent::Cookie","WebAgent/Cookie.html#method-c-parse","(str, url)",""],["parse","WebAgent::Cookie","WebAgent/Cookie.html#method-i-parse","(str, url)",""],["parse_authentication_header","HTTPClient::AuthFilterBase","HTTPClient/AuthFilterBase.html#method-i-parse_authentication_header","(res, tag)",""],["parse_challenge_header","HTTPClient::AuthFilterBase","HTTPClient/AuthFilterBase.html#method-i-parse_challenge_header","(challenge)",""],["parse_challenge_param","HTTPClient::DigestAuth","HTTPClient/DigestAuth.html#method-i-parse_challenge_param","(param_str)",""],["parse_header","HTTPClient::Session","HTTPClient/Session.html#method-i-parse_header","()",""],["parse_keepalive_header","HTTPClient::Session","HTTPClient/Session.html#method-i-parse_keepalive_header","(key, value)",""],["parse_record","HTTPClient::WebAgentSaver","HTTPClient/WebAgentSaver.html#method-i-parse_record","(line)",""],["parts","HTTP::Message::Body::Parts","HTTP/Message/Body/Parts.html#method-i-parts","()",""],["path_orig?","WebAgent::Cookie","WebAgent/Cookie.html#method-i-path_orig-3F","()",""],["peer_cert","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-peer_cert","()",""],["pop","HTTPClient::Connection","HTTPClient/Connection.html#method-i-pop","()","<p>Retrieves a HTTP::Message instance of HTTP response.  Do not invoke this\nmethod twice for now.  The second …\n"],["port","HTTPClient::Util::AddressableURI","HTTPClient/Util/AddressableURI.html#method-i-port","()","<p>HTTPClient expects urify(“foo/”).port to be not nil but 80 like URI.\n"],["post","HTTPClient","HTTPClient.html#method-i-post","(uri, *args, &block)","<p>Sends POST request to the specified URL.  See request for arguments. You\nshould not depend on :follow_redirect …\n"],["post","JSONClient","JSONClient.html#method-i-post","(uri, *args, &block)",""],["post_async","HTTPClient","HTTPClient.html#method-i-post_async","(uri, *args)","<p>Sends POST request in async style.  See request_async for arguments. It\nimmediately returns a HTTPClient::Connection …\n"],["post_connection_check","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-post_connection_check","(host)",""],["post_content","HTTPClient","HTTPClient.html#method-i-post_content","(uri, *args, &block)","<p>Posts a content.\n<p>uri &mdash; a String or an URI object which represents an URL of web resource.\n<p>body &mdash; a Hash or …\n"],["propfind","HTTPClient","HTTPClient.html#method-i-propfind","(uri, *args, &block)","<p>Sends PROPFIND request to the specified URL.  See request for arguments.\n"],["propfind_async","HTTPClient","HTTPClient.html#method-i-propfind_async","(uri, *args)","<p>Sends PROPFIND request in async style.  See request_async2 for arguments.\nIt immediately returns a HTTPClient::Connection …\n"],["proppatch","HTTPClient","HTTPClient.html#method-i-proppatch","(uri, *args, &block)","<p>Sends PROPPATCH request to the specified URL.  See request for arguments.\n"],["proppatch_async","HTTPClient","HTTPClient.html#method-i-proppatch_async","(uri, *args)","<p>Sends PROPPATCH request in async style.  See request_async2 for arguments.\nIt immediately returns a  …\n"],["protect_keep_alive_disconnected","HTTPClient","HTTPClient.html#method-i-protect_keep_alive_disconnected","()",""],["proxy","HTTPClient","HTTPClient.html#method-i-proxy","()","<p>Returns URI object of HTTP proxy if exists.\n"],["proxy=","HTTPClient","HTTPClient.html#method-i-proxy-3D","(proxy)","<p>Sets HTTP proxy used for HTTP connection.  Given proxy can be an URI, a\nString or nil.  You can set  …\n"],["proxy=","HTTPClient::SessionManager","HTTPClient/SessionManager.html#method-i-proxy-3D","(proxy)",""],["put","HTTPClient","HTTPClient.html#method-i-put","(uri, *args, &block)","<p>Sends PUT request to the specified URL.  See request for arguments.\n"],["put","JSONClient","JSONClient.html#method-i-put","(uri, *args, &block)",""],["put_async","HTTPClient","HTTPClient.html#method-i-put_async","(uri, *args)","<p>Sends PUT request in async style.  See request_async2 for arguments. It\nimmediately returns a HTTPClient::Connection …\n"],["query","HTTPClient::Session","HTTPClient/Session.html#method-i-query","(req)","<p>Send a request to the server\n"],["query","HTTPClient::SessionManager","HTTPClient/SessionManager.html#method-i-query","(req, via_proxy)",""],["raise","HTTPClient::TimeoutScheduler::Period","HTTPClient/TimeoutScheduler/Period.html#method-i-raise","(message)","<p>Raises if thread exists and alive.\n"],["read","HTTPClient::DebugSocket","HTTPClient/DebugSocket.html#method-i-read","(*args)",""],["read","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-read","(*args)",""],["read","HTTPClient::SocketWrap","HTTPClient/SocketWrap.html#method-i-read","(*args)",""],["read_body_chunked","HTTPClient::Session","HTTPClient/Session.html#method-i-read_body_chunked","(&block)",""],["read_body_length","HTTPClient::Session","HTTPClient/Session.html#method-i-read_body_length","(&block)",""],["read_body_rest","HTTPClient::Session","HTTPClient/Session.html#method-i-read_body_rest","()",""],["read_header","HTTPClient::Session","HTTPClient/Session.html#method-i-read_header","()","<p>Read status block.\n"],["readpartial","HTTPClient::DebugSocket","HTTPClient/DebugSocket.html#method-i-readpartial","(*args)",""],["readpartial","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-readpartial","(*args)",""],["readpartial","HTTPClient::SocketWrap","HTTPClient/SocketWrap.html#method-i-readpartial","(*args)",""],["reason","HTTP::Message","HTTP/Message.html#method-i-reason","()","<p>Returns  HTTP status reason phrase in response.  String.\n"],["reason=","HTTP::Message","HTTP/Message.html#method-i-reason-3D","(reason)","<p>Sets  HTTP status reason phrase of response.  String.\n"],["redirect?","HTTP::Message","HTTP/Message.html#method-i-redirect-3F","()",""],["redirect?","HTTP::Status","HTTP/Status.html#method-c-redirect-3F","(status)","<p>Returns true if the given status is thought to be redirect. See also\nREDIRECT_STATUS.\n"],["redirect_uri_callback=","HTTPClient","HTTPClient.html#method-i-redirect_uri_callback-3D","(redirect_uri_callback)","<p>Sets callback proc when HTTP redirect status is returned for get_content\nand post_content.  default_redirect_uri_callback …\n"],["regex_quote_n","HexDump","HexDump.html#method-c-regex_quote_n","(raw)","<p>raw must be in BINARY encoding in 1.9\n"],["register","HTTPClient::TimeoutScheduler","HTTPClient/TimeoutScheduler.html#method-i-register","(thread, sec, ex)","<p>Registers new timeout period.\n"],["remember_pos","HTTP::Message::Body","HTTP/Message/Body.html#method-i-remember_pos","(io)",""],["request","HTTPClient","HTTPClient.html#method-i-request","(method, uri, *args, &block)","<p>Sends a request to the specified URL.\n<p>method &mdash; HTTP method to be sent.  method.to_s.upcase is used.\n<p>uri &mdash; "],["request","JSONClient","JSONClient.html#method-i-request","(method, uri, *args, &block)",""],["request_async","HTTPClient","HTTPClient.html#method-i-request_async","(method, uri, query = nil, body = nil, header = {})","<p>Sends a request in async style.  request method creates new Thread for HTTP\nconnection and returns a …\n"],["request_async2","HTTPClient","HTTPClient.html#method-i-request_async2","(method, uri, *args)","<p>new method that has same signature as &#39;request&#39;\n"],["request_line","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-request_line","()",""],["reset","HTTPClient","HTTPClient.html#method-i-reset","(uri)","<p>Resets internal session for the given URL.  Keep-alive connection for the\nsite (host-port pair) is disconnected …\n"],["reset","HTTPClient::SessionManager","HTTPClient/SessionManager.html#method-i-reset","(uri)",""],["reset_all","HTTPClient","HTTPClient.html#method-i-reset_all","()","<p>Resets all of internal sessions.  Keep-alive connections are disconnected.\n"],["reset_all","HTTPClient::SessionManager","HTTPClient/SessionManager.html#method-i-reset_all","()",""],["reset_challenge","HTTPClient::AuthBase","HTTPClient/AuthBase.html#method-i-reset_challenge","()","<p>Resets challenge state.  Do not send &#39;*Authorization&#39; header until\nthe server sends &#39;*Authentication&#39; …\n"],["reset_challenge","HTTPClient::ProxyAuth","HTTPClient/ProxyAuth.html#method-i-reset_challenge","()","<p>Resets challenge state.  See sub filters for more details.\n"],["reset_challenge","HTTPClient::ProxyDigestAuth","HTTPClient/ProxyDigestAuth.html#method-i-reset_challenge","()",""],["reset_challenge","HTTPClient::WWWAuth","HTTPClient/WWWAuth.html#method-i-reset_challenge","()","<p>Resets challenge state.  See sub filters for more details.\n"],["reset_pos","HTTP::Message::Body","HTTP/Message/Body.html#method-i-reset_pos","(io)",""],["response_status_line","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-response_status_line","()",""],["sample_verify_callback","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-sample_verify_callback","(is_ok, ctx)","<p>Sample callback method:  CAUTION: does not check CRL/ARL.\n"],["save","HTTPClient::WebAgentSaver","HTTPClient/WebAgentSaver.html#method-i-save","(io, jar)","<p>same as HTTP::CookieJar::CookiestxtSaver\n"],["save_all_cookies","WebAgent::CookieManager","WebAgent/CookieManager.html#method-i-save_all_cookies","(force = nil, save_unused = true, save_discarded = true)",""],["save_all_cookies","WebAgent::CookieManager","WebAgent/CookieManager.html#method-i-save_all_cookies","(force = nil, save_unused = true, save_discarded = true)",""],["save_cookie_store","HTTPClient","HTTPClient.html#method-i-save_cookie_store","()","<p>Try to save Cookies to the file specified in set_cookie_store.  Unexpected\nerror will be raised if you …\n"],["save_cookies","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-save_cookies","(session = false)",""],["save_cookies","HTTPClient::CookieManager","HTTPClient/CookieManager.html#method-i-save_cookies","(session = false)",""],["scrub_cached_session","HTTPClient::SessionManager","HTTPClient/SessionManager.html#method-i-scrub_cached_session","(now)",""],["secure?","WebAgent::Cookie","WebAgent/Cookie.html#method-i-secure-3F","()",""],["see_other?","HTTP::Message","HTTP/Message.html#method-i-see_other-3F","()","<p>SEE_OTHER is a redirect, but it should sent as GET\n"],["set","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-set","(key, value)","<p>Sets a header.\n"],["set","HTTPClient::BasicAuth","HTTPClient/BasicAuth.html#method-i-set","(uri, user, passwd)","<p>Set authentication credential. uri == nil for generic purpose (allow to use\nuser/password for any URL …\n"],["set","HTTPClient::DigestAuth","HTTPClient/DigestAuth.html#method-i-set","(uri, user, passwd)","<p>Set authentication credential. uri == nil is ignored.\n"],["set","HTTPClient::NegotiateAuth","HTTPClient/NegotiateAuth.html#method-i-set","(uri, user, passwd)","<p>Set authentication credential. uri == nil for generic purpose (allow to use\nuser/password for any URL …\n"],["set","HTTPClient::OAuth","HTTPClient/OAuth.html#method-i-set","(*args)","<p>Set authentication credential. You cannot set OAuth config via\nWWWAuth#set_auth. Use OAuth#config=\n"],["set","HTTPClient::ProxyBasicAuth","HTTPClient/ProxyBasicAuth.html#method-i-set","(uri, user, passwd)",""],["set","HTTPClient::ProxyDigestAuth","HTTPClient/ProxyDigestAuth.html#method-i-set","(uri, user, passwd)","<p>overrides DigestAuth#set. sets default user name and password. uri is not\nused.\n"],["set","HTTPClient::SSPINegotiateAuth","HTTPClient/SSPINegotiateAuth.html#method-i-set","(*args)","<p>Set authentication credential. NOT SUPPORTED: username and necessary data\nis retrieved by win32/sspi. …\n"],["set?","HTTPClient::BasicAuth","HTTPClient/BasicAuth.html#method-i-set-3F","()","<p>have we marked this as set - ie that it&#39;s valid to use in this context?\n"],["set?","HTTPClient::DigestAuth","HTTPClient/DigestAuth.html#method-i-set-3F","()","<p>have we marked this as set - ie that it&#39;s valid to use in this context?\n"],["set?","HTTPClient::NegotiateAuth","HTTPClient/NegotiateAuth.html#method-i-set-3F","()","<p>have we marked this as set - ie that it&#39;s valid to use in this context?\n"],["set?","HTTPClient::OAuth","HTTPClient/OAuth.html#method-i-set-3F","()","<p>Check always (not effective but it works)\n"],["set?","HTTPClient::SSPINegotiateAuth","HTTPClient/SSPINegotiateAuth.html#method-i-set-3F","()","<p>Check always (not effective but it works)\n"],["set_auth","HTTPClient","HTTPClient.html#method-i-set_auth","(domain, user, passwd)","<p>Sets credential for Web server authentication.\n<p>domain &mdash; a String or an URI to specify where HTTPClient should …\n\n"],["set_auth","HTTPClient::ProxyAuth","HTTPClient/ProxyAuth.html#method-i-set_auth","(user, passwd)","<p>Set authentication credential.  See sub filters for more details.\n"],["set_auth","HTTPClient::WWWAuth","HTTPClient/WWWAuth.html#method-i-set_auth","(uri, user, passwd)","<p>Set authentication credential.  See sub filters for more details.\n"],["set_basic_auth","HTTPClient","HTTPClient.html#method-i-set_basic_auth","(domain, user, passwd)","<p>Deprecated.  Use set_auth instead.\n"],["set_body_encoding","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-set_body_encoding","()",""],["set_client_cert_file","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-set_client_cert_file","(cert_file, key_file, pass = nil)","<p>Sets certificate and private key for SSL client authentication.\n<p>cert_file &mdash; must be a filename of PEM/DER …\n"],["set_config","HTTPClient::OAuth","HTTPClient/OAuth.html#method-i-set_config","(uri, config)","<p>Set authentication credential.\n"],["set_content","HTTP::Message::Body","HTTP/Message/Body.html#method-i-set_content","(body, boundary = nil)",""],["set_cookie_store","HTTPClient","HTTPClient.html#method-i-set_cookie_store","(filename)","<p>Sets the filename where non-volatile Cookies be saved by calling\nsave_cookie_store. This method tries …\n"],["set_crl","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-set_crl","(crl)",""],["set_date_header","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-set_date_header","()","<p>Set Date header\n"],["set_default_paths","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-set_default_paths","()","<p>Sets OpenSSL&#39;s default trusted CA certificates.  Generally, OpenSSL is\nconfigured to use OS&#39;s …\n"],["set_encoding","HTTPClient","HTTPClient.html#method-i-set_encoding","(str, encoding)",""],["set_flag","HTTPClient::WebAgentSaver","HTTPClient/WebAgentSaver.html#method-c-set_flag","(cookie, flag)",""],["set_flag","WebAgent::Cookie","WebAgent/Cookie.html#method-i-set_flag","(flag)",""],["set_header","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-set_header","()",""],["set_header","HTTPClient::Session","HTTPClient/Session.html#method-i-set_header","(req)",""],["set_headers","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-set_headers","(headers)",""],["set_mime_type_func","HTTP::Message","HTTP/Message.html#method-c-set_mime_type_func","(handler)","<p>For backward compatibility.\n"],["set_proxy_auth","HTTPClient","HTTPClient.html#method-i-set_proxy_auth","(user, passwd)","<p>Sets credential for Proxy authentication.\n<p>user &mdash; username String.\n<p>passwd &mdash; password String.\n"],["set_request_header","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-set_request_header","()",""],["set_response_header","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-set_response_header","()",""],["set_trust_ca","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-set_trust_ca","(trust_ca_file_or_hashed_dir)",""],["sign","HTTPClient::OAuth","HTTPClient/OAuth.html#method-i-sign","(config, header, req)",""],["sign_hmac_sha1","HTTPClient::OAuth","HTTPClient/OAuth.html#method-i-sign_hmac_sha1","(config, base_string)",""],["ssl_cipher","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-ssl_cipher","()",""],["ssl_connect","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-ssl_connect","(hostname = nil)",""],["ssl_state","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-ssl_state","()",""],["ssl_version","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-ssl_version","()",""],["ssl_version=","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-ssl_version-3D","(ssl_version)","<p>Sets SSL version method String.  Possible values: “SSLv2” for SSL2, “SSLv3”\nfor  …\n"],["start_timer_thread","HTTPClient::TimeoutScheduler","HTTPClient/TimeoutScheduler.html#method-i-start_timer_thread","()",""],["status","HTTP::Message","HTTP/Message.html#method-i-status","()","<p>Returns HTTP status code in response.  Integer.\n"],["status=","HTTP::Message","HTTP/Message.html#method-i-status-3D","(status)","<p>Sets HTTP status code of response.  Integer. Reason phrase is updated, too.\n"],["status_code","HTTP::Message","HTTP/Message.html#method-i-status_code","()",""],["status_code=","HTTP::Message::Headers","HTTP/Message/Headers.html#method-i-status_code-3D","(status_code)","<p>Sets status code and reason phrase.\n"],["strict_redirect_uri_callback","HTTPClient","HTTPClient.html#method-i-strict_redirect_uri_callback","(uri, res)","<p>A method for redirect uri callback.  How to use:\n\n<pre>clnt.redirect_uri_callback = clnt.method(:strict_redirect_uri_callback)</pre>\n"],["success_content","HTTPClient","HTTPClient.html#method-i-success_content","(res)",""],["successful?","HTTP::Status","HTTP/Status.html#method-c-successful-3F","(status)","<p>Returns true if the given status represents successful HTTP response. See\nalso SUCCESSFUL_STATUS.\n"],["sync","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-sync","()",""],["sync","HTTPClient::SocketWrap","HTTPClient/SocketWrap.html#method-i-sync","()",""],["sync=","HTTPClient::SSLSocketWrap","HTTPClient/SSLSocketWrap.html#method-i-sync-3D","(sync)",""],["sync=","HTTPClient::SocketWrap","HTTPClient/SocketWrap.html#method-i-sync-3D","(sync)",""],["tail_match?","WebAgent::CookieUtils","WebAgent/CookieUtils.html#method-i-tail_match-3F","(str1, str2)",""],["timeout","HTTPClient::Timeout","HTTPClient/Timeout.html#method-i-timeout","(sec, ex = nil, &block)",""],["timeout=","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-timeout-3D","(timeout)","<p>Sets SSL timeout in sec.\n<p>Calling this method resets all existing sessions.\n"],["timeout_scheduler","HTTPClient","HTTPClient.html#method-c-timeout_scheduler","()","<p>CAUTION: caller must aware of race condition.\n"],["to_resource_url","HTTPClient","HTTPClient.html#method-i-to_resource_url","(uri)",""],["trace","HTTPClient","HTTPClient.html#method-i-trace","(uri, *args, &block)","<p>Sends TRACE request to the specified URL.  See request for arguments.\n"],["trace_async","HTTPClient","HTTPClient.html#method-i-trace_async","(uri, *args)","<p>Sends TRACE request in async style.  See request_async2 for arguments. It\nimmediately returns a HTTPClient::Connection …\n"],["try_convert","HTTP::Message::Array","HTTP/Message/Array.html#method-c-try_convert","(value)",""],["try_require","HTTPClient::Util","HTTPClient/Util.html#method-i-try_require","(feature)","<p>Try to require a feature and returns true/false if loaded\n<p>It returns &#39;true&#39; for the second require …\n"],["try_require","HTTPClient::Util","HTTPClient/Util.html#method-c-try_require","(feature)","<p>Try to require a feature and returns true/false if loaded\n<p>It returns &#39;true&#39; for the second require …\n"],["unescape","HTTP::Message","HTTP/Message.html#method-c-unescape","(string)","<p>from CGI.unescape\n"],["unescape","OAuthClient","OAuthClient.html#method-i-unescape","(escaped)",""],["uri_dirname","HTTPClient::Util","HTTPClient/Util.html#method-i-uri_dirname","(uri)","<p>Returns parent directory URI of the given URI.\n"],["uri_dirname","HTTPClient::Util","HTTPClient/Util.html#method-c-uri_dirname","(uri)","<p>Returns parent directory URI of the given URI.\n"],["uri_part_of","HTTPClient::Util","HTTPClient/Util.html#method-c-uri_part_of","(uri, part)","<p>Returns true if the given 2 URIs have a part_of relationship.\n<p>the same scheme\n<p>the same host String (no …\n"],["uri_part_of","HTTPClient::Util","HTTPClient/Util.html#method-i-uri_part_of","(uri, part)","<p>Returns true if the given 2 URIs have a part_of relationship.\n<p>the same scheme\n<p>the same host String (no …\n"],["urify","HTTPClient::Util","HTTPClient/Util.html#method-i-urify","(uri)","<p>Gets an URI instance.\n"],["urify","HTTPClient::Util","HTTPClient/Util.html#method-c-urify","(uri)","<p>Gets an URI instance.\n"],["url","WebAgent::Cookie","WebAgent/Cookie.html#method-i-url","()",""],["url=","WebAgent::Cookie","WebAgent/Cookie.html#method-i-url-3D","(url)",""],["use?","WebAgent::Cookie","WebAgent/Cookie.html#method-i-use-3F","()",""],["valid_session?","HTTPClient::SessionManager","HTTPClient/SessionManager.html#method-i-valid_session-3F","(sess, now)",""],["verify_callback=","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-verify_callback-3D","(verify_callback)","<p>Sets callback handler for custom certificate verification. See\nverify_callback.\n<p>Calling this method resets …\n"],["verify_depth=","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-verify_depth-3D","(verify_depth)","<p>Sets verify depth.  New value must be a number.\n<p>Calling this method resets all existing sessions.\n"],["verify_mode=","HTTPClient::SSLConfig","HTTPClient/SSLConfig.html#method-i-verify_mode-3D","(verify_mode)","<p>Sets verify mode of OpenSSL.  New value must be a combination of constants\nOpenSSL::SSL::VERIFY_*\n<p>Calling …\n"],["version","HTTP::Message","HTTP/Message.html#method-i-version","()",""],["version=","HTTP::Message","HTTP/Message.html#method-i-version-3D","(version)",""],["wrap_json_response","JSONClient","JSONClient.html#method-i-wrap_json_response","(original)",""],["cacert.p7s","","lib/httpclient/cacert_p7s.html","","<p>## ## ca-bundle.crt – Bundle of CA Root Certificates ## ## Certificate data\nfrom Mozilla as of: Tue …\n"]]}}