<!DOCTYPE html>

<html>
<head>
<meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

<title>coffee-script.js - coffee-script-source-1.9.1.1 Documentation</title>

<link type="text/css" media="screen" href="../../rdoc.css" rel="stylesheet">

<script type="text/javascript">
  var rdoc_rel_prefix = "../../";
</script>

<script type="text/javascript" charset="utf-8" src="../../js/jquery.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/navigation.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/search_index.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/search.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/searcher.js"></script>
<script type="text/javascript" charset="utf-8" src="../../js/darkfish.js"></script>


<body class="file">
<nav id="metadata">
  <nav id="home-section" class="section">
  <h3 class="section-header">
    <a href="../../index.html">Home</a>
    <a href="../../table_of_contents.html#classes">Classes</a>
    <a href="../../table_of_contents.html#methods">Methods</a>
  </h3>
</nav>


  <nav id="search-section" class="section project-section" class="initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <h3 class="section-header">
      <input type="text" name="search" placeholder="Search" id="search-field"
             title="Type to search, Up and Down to navigate, Enter to load">
    </h3>
  </form>

  <ul id="search-results" class="initially-hidden"></ul>
</nav>


  

  <div id="project-metadata">
    <nav id="fileindex-section" class="section project-section">
  <h3 class="section-header">Pages</h3>

  <ul>
  
    <li class="file"><a href="../../lib/coffee_script/coffee-script_js.html">coffee-script.js</a>
  
  </ul>
</nav>

    <nav id="classindex-section" class="section project-section">
  <h3 class="section-header">Class and Module Index</h3>

  <ul class="link-list">
  
    <li><a href="../../CoffeeScript.html">CoffeeScript</a>
  
    <li><a href="../../CoffeeScript/Source.html">CoffeeScript::Source</a>
  
  </ul>
</nav>

  </div>
</nav>

<div id="documentation" class="description">
  
<pre>CoffeeScript Compiler v1.9.1
http://coffeescript.org

Copyright 2011, Jeremy Ashkenas
Released under the MIT License</pre>

<p>(function(root) {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-constant">CoffeeScript</span> = <span class="ruby-identifier">function</span>() {
  <span class="ruby-identifier">function</span> <span class="ruby-identifier">require</span>(<span class="ruby-identifier">path</span>){ <span class="ruby-keyword">return</span> <span class="ruby-identifier">require</span>[<span class="ruby-identifier">path</span>]; }
  <span class="ruby-identifier">require</span>[<span class="ruby-string">&#39;./helpers&#39;</span>] = (<span class="ruby-identifier">function</span>() {
<span class="ruby-identifier">var</span> <span class="ruby-identifier">exports</span> = {}, <span class="ruby-identifier">module</span> = {<span class="ruby-identifier">exports</span><span class="ruby-operator">:</span> <span class="ruby-identifier">exports</span>};
<span class="ruby-regexp">//</span> <span class="ruby-constant">Generated</span> <span class="ruby-identifier">by</span> <span class="ruby-constant">CoffeeScript</span> <span class="ruby-value">1.9</span><span class="ruby-value">.1</span>
</pre>

<p>(function() {</p>

<pre>var buildLocationData, extend, flatten, ref, repeat, syntaxErrorToString;

exports.starts = function(string, literal, start) {
  return literal === string.substr(start, literal.length);
};

exports.ends = function(string, literal, back) {
  var len;
  len = literal.length;
  return literal === string.substr(string.length - len - (back || 0), len);
};

exports.repeat = repeat = function(str, n) {
  var res;
  res = &#39;&#39;;
  while (n &gt; 0) {
    if (n &amp; 1) {
      res += str;
    }
    n &gt;&gt;&gt;= 1;
    str += str;
  }
  return res;
};

exports.compact = function(array) {
  var i, item, len1, results;
  results = [];
  for (i = 0, len1 = array.length; i &lt; len1; i++) {
    item = array[i];
    if (item) {
      results.push(item);
    }
  }
  return results;
};

exports.count = function(string, substr) {
  var num, pos;
  num = pos = 0;
  if (!substr.length) {
    return 1 / 0;
  }
  while (pos = 1 + string.indexOf(substr, pos)) {
    num++;
  }
  return num;
};

exports.merge = function(options, overrides) {
  return extend(extend({}, options), overrides);
};

extend = exports.extend = function(object, properties) {
  var key, val;
  for (key in properties) {
    val = properties[key];
    object[key] = val;
  }
  return object;
};

exports.flatten = flatten = function(array) {
  var element, flattened, i, len1;
  flattened = [];
  for (i = 0, len1 = array.length; i &lt; len1; i++) {
    element = array[i];
    if (element instanceof Array) {
      flattened = flattened.concat(flatten(element));
    } else {
      flattened.push(element);
    }
  }
  return flattened;
};

exports.del = function(obj, key) {
  var val;
  val = obj[key];
  delete obj[key];
  return val;
};

exports.some = (ref = Array.prototype.some) != null ? ref : function(fn) {
  var e, i, len1;
  for (i = 0, len1 = this.length; i &lt; len1; i++) {
    e = this[i];
    if (fn(e)) {
      return true;
    }
  }
  return false;
};

exports.invertLiterate = function(code) {
  var line, lines, maybe_code;
  maybe_code = true;
  lines = (function() {
    var i, len1, ref1, results;
    ref1 = code.split(&#39;\n&#39;);
    results = [];
    for (i = 0, len1 = ref1.length; i &lt; len1; i++) {
      line = ref1[i];
      if (maybe_code &amp;&amp; /^([ ]{4}|[ ]{0,3}\t)/.test(line)) {
        results.push(line);
      } else if (maybe_code = /^\s*$/.test(line)) {
        results.push(line);
      } else {
        results.push(&#39;# &#39; + line);
      }
    }
    return results;
  })();
  return lines.join(&#39;\n&#39;);
};

buildLocationData = function(first, last) {
  if (!last) {
    return first;
  } else {
    return {
      first_line: first.first_line,
      first_column: first.first_column,
      last_line: last.last_line,
      last_column: last.last_column
    };
  }
};

exports.addLocationDataFn = function(first, last) {
  return function(obj) {
    if (((typeof obj) === &#39;object&#39;) &amp;&amp; (!!obj[&#39;updateLocationDataIfMissing&#39;])) {
      obj.updateLocationDataIfMissing(buildLocationData(first, last));
    }
    return obj;
  };
};

exports.locationDataToString = function(obj) {
  var locationData;
  if ((&quot;2&quot; in obj) &amp;&amp; (&quot;first_line&quot; in obj[2])) {
    locationData = obj[2];
  } else if (&quot;first_line&quot; in obj) {
    locationData = obj;
  }
  if (locationData) {
    return ((locationData.first_line + 1) + &quot;:&quot; + (locationData.first_column + 1) + &quot;-&quot;) + ((locationData.last_line + 1) + &quot;:&quot; + (locationData.last_column + 1));
  } else {
    return &quot;No location data&quot;;
  }
};

exports.baseFileName = function(file, stripExt, useWinPathSep) {
  var parts, pathSep;
  if (stripExt == null) {
    stripExt = false;
  }
  if (useWinPathSep == null) {
    useWinPathSep = false;
  }
  pathSep = useWinPathSep ? /\\|\// : /\//;
  parts = file.split(pathSep);
  file = parts[parts.length - 1];
  if (!(stripExt &amp;&amp; file.indexOf(&#39;.&#39;) &gt;= 0)) {
    return file;
  }
  parts = file.split(&#39;.&#39;);
  parts.pop();
  if (parts[parts.length - 1] === &#39;coffee&#39; &amp;&amp; parts.length &gt; 1) {
    parts.pop();
  }
  return parts.join(&#39;.&#39;);
};

exports.isCoffee = function(file) {
  return /\.((lit)?coffee|coffee\.md)$/.test(file);
};

exports.isLiterate = function(file) {
  return /\.(litcoffee|coffee\.md)$/.test(file);
};

exports.throwSyntaxError = function(message, location) {
  var error;
  error = new SyntaxError(message);
  error.location = location;
  error.toString = syntaxErrorToString;
  error.stack = error.toString();
  throw error;
};

exports.updateSyntaxError = function(error, code, filename) {
  if (error.toString === syntaxErrorToString) {
    error.code || (error.code = code);
    error.filename || (error.filename = filename);
    error.stack = error.toString();
  }
  return error;
};

syntaxErrorToString = function() {
  var codeLine, colorize, colorsEnabled, end, filename, first_column, first_line, last_column, last_line, marker, ref1, ref2, ref3, ref4, start;
  if (!(this.code &amp;&amp; this.location)) {
    return Error.prototype.toString.call(this);
  }
  ref1 = this.location, first_line = ref1.first_line, first_column = ref1.first_column, last_line = ref1.last_line, last_column = ref1.last_column;
  if (last_line == null) {
    last_line = first_line;
  }
  if (last_column == null) {
    last_column = first_column;
  }
  filename = this.filename || &#39;[stdin]&#39;;
  codeLine = this.code.split(&#39;\n&#39;)[first_line];
  start = first_column;
  end = first_line === last_line ? last_column + 1 : codeLine.length;
  marker = codeLine.slice(0, start).replace(/[^\s]/g, &#39; &#39;) + repeat(&#39;^&#39;, end - start);
  if (typeof process !== &quot;undefined&quot; &amp;&amp; process !== null) {
    colorsEnabled = ((ref2 = process.stdout) != null ? ref2.isTTY : void 0) &amp;&amp; !((ref3 = process.env) != null ? ref3.NODE_DISABLE_COLORS : void 0);
  }
  if ((ref4 = this.colorful) != null ? ref4 : colorsEnabled) {
    colorize = function(str) {
      return &quot;\x1B[1;31m&quot; + str + &quot;\x1B[0m&quot;;
    };
    codeLine = codeLine.slice(0, start) + colorize(codeLine.slice(start, end)) + codeLine.slice(end);
    marker = colorize(marker);
  }
  return filename + &quot;:&quot; + (first_line + 1) + &quot;:&quot; + (first_column + 1) + &quot;: error: &quot; + this.message + &quot;\n&quot; + codeLine + &quot;\n&quot; + marker;
};

exports.nameWhitespaceCharacter = function(string) {
  switch (string) {
    case &#39; &#39;:
      return &#39;space&#39;;
    case &#39;\n&#39;:
      return &#39;newline&#39;;
    case &#39;\r&#39;:
      return &#39;carriage return&#39;;
    case &#39;\t&#39;:
      return &#39;tab&#39;;
    default:
      return string;
  }
};</pre>

<p>}).call(this);</p>

<pre>return module.exports;</pre>

<p>})();<a href="http://'./rewriter'">require</a> = (function() {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">exports</span> = {}, <span class="ruby-identifier">module</span> = {<span class="ruby-identifier">exports</span><span class="ruby-operator">:</span> <span class="ruby-identifier">exports</span>};
<span class="ruby-regexp">//</span> <span class="ruby-constant">Generated</span> <span class="ruby-identifier">by</span> <span class="ruby-constant">CoffeeScript</span> <span class="ruby-value">1.9</span><span class="ruby-value">.1</span>
</pre>

<p>(function() {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-constant">BALANCED_PAIRS</span>, <span class="ruby-constant">CALL_CLOSERS</span>, <span class="ruby-constant">EXPRESSION_CLOSE</span>, <span class="ruby-constant">EXPRESSION_END</span>, <span class="ruby-constant">EXPRESSION_START</span>, <span class="ruby-constant">IMPLICIT_CALL</span>, <span class="ruby-constant">IMPLICIT_END</span>, <span class="ruby-constant">IMPLICIT_FUNC</span>, <span class="ruby-constant">IMPLICIT_UNSPACED_CALL</span>, <span class="ruby-constant">INVERSES</span>, <span class="ruby-constant">LINEBREAKS</span>, <span class="ruby-constant">SINGLE_CLOSERS</span>, <span class="ruby-constant">SINGLE_LINERS</span>, <span class="ruby-identifier">generate</span>, <span class="ruby-identifier">k</span>, <span class="ruby-identifier">left</span>, <span class="ruby-identifier">len</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">rite</span>,
  <span class="ruby-identifier">indexOf</span> = [].<span class="ruby-identifier">indexOf</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">item</span>) { <span class="ruby-keyword">for</span> (<span class="ruby-identifier">var</span> <span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">l</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">l</span>; <span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) { <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">this</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>[<span class="ruby-identifier">i</span>] <span class="ruby-operator">===</span> <span class="ruby-identifier">item</span>) <span class="ruby-keyword">return</span> <span class="ruby-identifier">i</span>; } <span class="ruby-keyword">return</span> <span class="ruby-value">-1</span>; },
  <span class="ruby-identifier">slice</span> = [].<span class="ruby-identifier">slice</span>;

<span class="ruby-identifier">generate</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">tag</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">origin</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">tok</span>;
  <span class="ruby-identifier">tok</span> = [<span class="ruby-identifier">tag</span>, <span class="ruby-identifier">value</span>];
  <span class="ruby-identifier">tok</span>.<span class="ruby-identifier">generated</span> = <span class="ruby-keyword">true</span>;
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">origin</span>) {
    <span class="ruby-identifier">tok</span>.<span class="ruby-identifier">origin</span> = <span class="ruby-identifier">origin</span>;
  }
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">tok</span>;
};

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Rewriter</span> = (<span class="ruby-identifier">function</span>() {
  <span class="ruby-identifier">function</span> <span class="ruby-constant">Rewriter</span>() {}

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">rewrite</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">tokens1</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tokens</span> = <span class="ruby-identifier">tokens1</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">removeLeadingNewlines</span>();
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">closeOpenCalls</span>();
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">closeOpenIndexes</span>();
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">normalizeLines</span>();
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tagPostfixConditionals</span>();
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">addImplicitBracesAndParens</span>();
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">addLocationDataToGeneratedTokens</span>();
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tokens</span>;
  };

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">scanTokens</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">block</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">i</span>, <span class="ruby-identifier">token</span>, <span class="ruby-identifier">tokens</span>;
    <span class="ruby-identifier">tokens</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tokens</span>;
    <span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>;
    <span class="ruby-keyword">while</span> (<span class="ruby-identifier">token</span> = <span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">i</span>]) {
      <span class="ruby-identifier">i</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">block</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">tokens</span>);
    }
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;
  };

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">detectEnd</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">i</span>, <span class="ruby-identifier">condition</span>, <span class="ruby-identifier">action</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">levels</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref1</span>, <span class="ruby-identifier">token</span>, <span class="ruby-identifier">tokens</span>;
    <span class="ruby-identifier">tokens</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tokens</span>;
    <span class="ruby-identifier">levels</span> = <span class="ruby-value">0</span>;
    <span class="ruby-keyword">while</span> (<span class="ruby-identifier">token</span> = <span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">i</span>]) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">levels</span> <span class="ruby-operator">===</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">condition</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>)) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">action</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">token</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">levels</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">action</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">EXPRESSION_START</span>, <span class="ruby-identifier">ref</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) {
        <span class="ruby-identifier">levels</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>;
      } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">ref1</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">EXPRESSION_END</span>, <span class="ruby-identifier">ref1</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) {
        <span class="ruby-identifier">levels</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>;
      }
      <span class="ruby-identifier">i</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>;
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>;
  };

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">removeLeadingNewlines</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">i</span>, <span class="ruby-identifier">k</span>, <span class="ruby-identifier">len</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">tag</span>;
    <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tokens</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len</span> = <span class="ruby-identifier">ref</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">k</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len</span>; <span class="ruby-identifier">i</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">k</span>) {
      <span class="ruby-identifier">tag</span> = <span class="ruby-identifier">ref</span>[<span class="ruby-identifier">i</span>][<span class="ruby-value">0</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">tag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;TERMINATOR&#39;</span>) {
        <span class="ruby-keyword">break</span>;
      }
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">splice</span>(<span class="ruby-value">0</span>, <span class="ruby-identifier">i</span>);
    }
  };

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">closeOpenCalls</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">action</span>, <span class="ruby-identifier">condition</span>;
    <span class="ruby-identifier">condition</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>) {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref</span>;
      <span class="ruby-keyword">return</span> ((<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>]) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;)&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;CALL_END&#39;</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">===</span> <span class="ruby-string">&#39;OUTDENT&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;)&#39;</span>;
    };
    <span class="ruby-identifier">action</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">===</span> <span class="ruby-string">&#39;OUTDENT&#39;</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">i</span>][<span class="ruby-value">0</span>] = <span class="ruby-string">&#39;CALL_END&#39;</span>;
    };
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">scanTokens</span>(<span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">===</span> <span class="ruby-string">&#39;CALL_START&#39;</span>) {
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">detectEnd</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>, <span class="ruby-identifier">condition</span>, <span class="ruby-identifier">action</span>);
      }
      <span class="ruby-keyword">return</span> <span class="ruby-value">1</span>;
    });
  };

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">closeOpenIndexes</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">action</span>, <span class="ruby-identifier">condition</span>;
    <span class="ruby-identifier">condition</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>) {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref</span>;
      <span class="ruby-keyword">return</span> (<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>]) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;]&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;INDEX_END&#39;</span>;
    };
    <span class="ruby-identifier">action</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>] = <span class="ruby-string">&#39;INDEX_END&#39;</span>;
    };
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">scanTokens</span>(<span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">===</span> <span class="ruby-string">&#39;INDEX_START&#39;</span>) {
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">detectEnd</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>, <span class="ruby-identifier">condition</span>, <span class="ruby-identifier">action</span>);
      }
      <span class="ruby-keyword">return</span> <span class="ruby-value">1</span>;
    });
  };

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">indexOfTag</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">fuzz</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">k</span>, <span class="ruby-identifier">pattern</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref1</span>;
    <span class="ruby-identifier">i</span> = <span class="ruby-identifier">arguments</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">pattern</span> = <span class="ruby-value">2</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">arguments</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">slice</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">arguments</span>, <span class="ruby-value">1</span>) <span class="ruby-operator">:</span> [];
    <span class="ruby-identifier">fuzz</span> = <span class="ruby-value">0</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">pattern</span>.<span class="ruby-identifier">length</span>; <span class="ruby-value">0</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">ref</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">ref</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">k</span> <span class="ruby-operator">&gt;</span> <span class="ruby-identifier">ref</span>; <span class="ruby-identifier">j</span> = <span class="ruby-value">0</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">ref</span> <span class="ruby-operator">?</span> <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">k</span> <span class="ruby-operator">:</span> <span class="ruby-operator">-</span><span class="ruby-operator">-</span><span class="ruby-identifier">k</span>) {
      <span class="ruby-keyword">while</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">j</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">fuzz</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;HERECOMMENT&#39;</span>) {
        <span class="ruby-identifier">fuzz</span> <span class="ruby-operator">+=</span> <span class="ruby-value">2</span>;
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">pattern</span>[<span class="ruby-identifier">j</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
        <span class="ruby-identifier">continue</span>;
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">typeof</span> <span class="ruby-identifier">pattern</span>[<span class="ruby-identifier">j</span>] <span class="ruby-operator">===</span> <span class="ruby-string">&#39;string&#39;</span>) {
        <span class="ruby-identifier">pattern</span>[<span class="ruby-identifier">j</span>] = [<span class="ruby-identifier">pattern</span>[<span class="ruby-identifier">j</span>]];
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">ref1</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">j</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">fuzz</span>), <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">pattern</span>[<span class="ruby-identifier">j</span>], <span class="ruby-identifier">ref1</span>) <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-value">-1</span>;
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">j</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">fuzz</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>;
  };

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">looksObjectish</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">j</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-keyword">end</span>, <span class="ruby-identifier">index</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">indexOfTag</span>(<span class="ruby-identifier">j</span>, <span class="ruby-string">&#39;@&#39;</span>, <span class="ruby-identifier">null</span>, <span class="ruby-string">&#39;:&#39;</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">-1</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">indexOfTag</span>(<span class="ruby-identifier">j</span>, <span class="ruby-identifier">null</span>, <span class="ruby-string">&#39;:&#39;</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">-1</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;
    }
    <span class="ruby-identifier">index</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">indexOfTag</span>(<span class="ruby-identifier">j</span>, <span class="ruby-constant">EXPRESSION_START</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">index</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">-1</span>) {
      <span class="ruby-keyword">end</span> = <span class="ruby-identifier">null</span>;
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">detectEnd</span>(<span class="ruby-identifier">index</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>, (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>) {
        <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref</span>;
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">EXPRESSION_END</span>, <span class="ruby-identifier">ref</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>;
      }), (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">end</span> = <span class="ruby-identifier">i</span>;
      }));
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-keyword">end</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;:&#39;</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
  };

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">findTagsBackwards</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">i</span>, <span class="ruby-identifier">tags</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">backStack</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref1</span>, <span class="ruby-identifier">ref2</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">ref5</span>;
    <span class="ruby-identifier">backStack</span> = [];
    <span class="ruby-keyword">while</span> (<span class="ruby-identifier">i</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">backStack</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">ref2</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span>), <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">tags</span>, <span class="ruby-identifier">ref2</span>) <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>) <span class="ruby-operator">&amp;&amp;</span> ((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span>), <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">EXPRESSION_START</span>, <span class="ruby-identifier">ref3</span>) <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">i</span>].<span class="ruby-identifier">generated</span>) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span>), <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">LINEBREAKS</span>, <span class="ruby-identifier">ref4</span>) <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>))) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span>), <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">EXPRESSION_END</span>, <span class="ruby-identifier">ref</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) {
        <span class="ruby-identifier">backStack</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span>));
      }
      <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">ref1</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span>), <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">EXPRESSION_START</span>, <span class="ruby-identifier">ref1</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">backStack</span>.<span class="ruby-identifier">length</span>) {
        <span class="ruby-identifier">backStack</span>.<span class="ruby-identifier">pop</span>();
      }
      <span class="ruby-identifier">i</span> <span class="ruby-operator">-=</span> <span class="ruby-value">1</span>;
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">ref5</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span>), <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">tags</span>, <span class="ruby-identifier">ref5</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>;
  };

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">addImplicitBracesAndParens</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">stack</span>, <span class="ruby-identifier">start</span>;
    <span class="ruby-identifier">stack</span> = [];
    <span class="ruby-identifier">start</span> = <span class="ruby-identifier">null</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">scanTokens</span>(<span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">tokens</span>) {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">endImplicitCall</span>, <span class="ruby-identifier">endImplicitObject</span>, <span class="ruby-identifier">forward</span>, <span class="ruby-identifier">inImplicit</span>, <span class="ruby-identifier">inImplicitCall</span>, <span class="ruby-identifier">inImplicitControl</span>, <span class="ruby-identifier">inImplicitObject</span>, <span class="ruby-identifier">newLine</span>, <span class="ruby-identifier">nextTag</span>, <span class="ruby-identifier">offset</span>, <span class="ruby-identifier">prevTag</span>, <span class="ruby-identifier">prevToken</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref1</span>, <span class="ruby-identifier">ref2</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">ref5</span>, <span class="ruby-identifier">s</span>, <span class="ruby-identifier">sameLine</span>, <span class="ruby-identifier">stackIdx</span>, <span class="ruby-identifier">stackTag</span>, <span class="ruby-identifier">stackTop</span>, <span class="ruby-identifier">startIdx</span>, <span class="ruby-identifier">startImplicitCall</span>, <span class="ruby-identifier">startImplicitObject</span>, <span class="ruby-identifier">startsLine</span>, <span class="ruby-identifier">tag</span>;
      <span class="ruby-identifier">tag</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>];
      <span class="ruby-identifier">prevTag</span> = (<span class="ruby-identifier">prevToken</span> = <span class="ruby-identifier">i</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> [])[<span class="ruby-value">0</span>];
      <span class="ruby-identifier">nextTag</span> = (<span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>] <span class="ruby-operator">:</span> [])[<span class="ruby-value">0</span>];
      <span class="ruby-identifier">stackTop</span> = <span class="ruby-identifier">function</span>() {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">stack</span>[<span class="ruby-identifier">stack</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>];
      };
      <span class="ruby-identifier">startIdx</span> = <span class="ruby-identifier">i</span>;
      <span class="ruby-identifier">forward</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">n</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">startIdx</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">n</span>;
      };
      <span class="ruby-identifier">inImplicit</span> = <span class="ruby-identifier">function</span>() {
        <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref1</span>;
        <span class="ruby-keyword">return</span> (<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">stackTop</span>()) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> (<span class="ruby-identifier">ref1</span> = <span class="ruby-identifier">ref</span>[<span class="ruby-value">2</span>]) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref1</span>.<span class="ruby-identifier">ours</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>;
      };
      <span class="ruby-identifier">inImplicitCall</span> = <span class="ruby-identifier">function</span>() {
        <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref</span>;
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">inImplicit</span>() <span class="ruby-operator">&amp;&amp;</span> ((<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">stackTop</span>()) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;(&#39;</span>;
      };
      <span class="ruby-identifier">inImplicitObject</span> = <span class="ruby-identifier">function</span>() {
        <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref</span>;
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">inImplicit</span>() <span class="ruby-operator">&amp;&amp;</span> ((<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">stackTop</span>()) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;{&#39;</span>;
      };
      <span class="ruby-identifier">inImplicitControl</span> = <span class="ruby-identifier">function</span>() {
        <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref</span>;
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">inImplicit</span> <span class="ruby-operator">&amp;&amp;</span> ((<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">stackTop</span>()) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;CONTROL&#39;</span>;
      };
      <span class="ruby-identifier">startImplicitCall</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">j</span>) {
        <span class="ruby-identifier">var</span> <span class="ruby-identifier">idx</span>;
        <span class="ruby-identifier">idx</span> = <span class="ruby-identifier">j</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">j</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">i</span>;
        <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">push</span>([
          <span class="ruby-string">&#39;(&#39;</span>, <span class="ruby-identifier">idx</span>, {
            <span class="ruby-identifier">ours</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
          }
        ]);
        <span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">splice</span>(<span class="ruby-identifier">idx</span>, <span class="ruby-value">0</span>, <span class="ruby-identifier">generate</span>(<span class="ruby-string">&#39;CALL_START&#39;</span>, <span class="ruby-string">&#39;(&#39;</span>));
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">j</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
          <span class="ruby-keyword">return</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>;
        }
      };
      <span class="ruby-identifier">endImplicitCall</span> = <span class="ruby-identifier">function</span>() {
        <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">pop</span>();
        <span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">splice</span>(<span class="ruby-identifier">i</span>, <span class="ruby-value">0</span>, <span class="ruby-identifier">generate</span>(<span class="ruby-string">&#39;CALL_END&#39;</span>, <span class="ruby-string">&#39;)&#39;</span>, [<span class="ruby-string">&#39;&#39;</span>, <span class="ruby-string">&#39;end of input&#39;</span>, <span class="ruby-identifier">token</span>[<span class="ruby-value">2</span>]]));
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>;
      };
      <span class="ruby-identifier">startImplicitObject</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">j</span>, <span class="ruby-identifier">startsLine</span>) {
        <span class="ruby-identifier">var</span> <span class="ruby-identifier">idx</span>, <span class="ruby-identifier">val</span>;
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">startsLine</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
          <span class="ruby-identifier">startsLine</span> = <span class="ruby-keyword">true</span>;
        }
        <span class="ruby-identifier">idx</span> = <span class="ruby-identifier">j</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">j</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">i</span>;
        <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">push</span>([
          <span class="ruby-string">&#39;{&#39;</span>, <span class="ruby-identifier">idx</span>, {
            <span class="ruby-identifier">sameLine</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>,
            <span class="ruby-identifier">startsLine</span><span class="ruby-operator">:</span> <span class="ruby-identifier">startsLine</span>,
            <span class="ruby-identifier">ours</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
          }
        ]);
        <span class="ruby-identifier">val</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">String</span>(<span class="ruby-string">&#39;{&#39;</span>);
        <span class="ruby-identifier">val</span>.<span class="ruby-identifier">generated</span> = <span class="ruby-keyword">true</span>;
        <span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">splice</span>(<span class="ruby-identifier">idx</span>, <span class="ruby-value">0</span>, <span class="ruby-identifier">generate</span>(<span class="ruby-string">&#39;{&#39;</span>, <span class="ruby-identifier">val</span>, <span class="ruby-identifier">token</span>));
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">j</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
          <span class="ruby-keyword">return</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>;
        }
      };
      <span class="ruby-identifier">endImplicitObject</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">j</span>) {
        <span class="ruby-identifier">j</span> = <span class="ruby-identifier">j</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">j</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">i</span>;
        <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">pop</span>();
        <span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">splice</span>(<span class="ruby-identifier">j</span>, <span class="ruby-value">0</span>, <span class="ruby-identifier">generate</span>(<span class="ruby-string">&#39;}&#39;</span>, <span class="ruby-string">&#39;}&#39;</span>, <span class="ruby-identifier">token</span>));
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>;
      };
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">inImplicitCall</span>() <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;IF&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;TRY&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;FINALLY&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;CATCH&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;CLASS&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;SWITCH&#39;</span>)) {
        <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">push</span>([
          <span class="ruby-string">&#39;CONTROL&#39;</span>, <span class="ruby-identifier">i</span>, {
            <span class="ruby-identifier">ours</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
          }
        ]);
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">forward</span>(<span class="ruby-value">1</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;INDENT&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">inImplicit</span>()) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">prevTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;=&gt;&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prevTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;-&gt;&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prevTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;[&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prevTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;(&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prevTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;,&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prevTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;{&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prevTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;TRY&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prevTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;ELSE&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prevTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;=&#39;</span>) {
          <span class="ruby-keyword">while</span> (<span class="ruby-identifier">inImplicitCall</span>()) {
            <span class="ruby-identifier">endImplicitCall</span>();
          }
        }
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">inImplicitControl</span>()) {
          <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">pop</span>();
        }
        <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">push</span>([<span class="ruby-identifier">tag</span>, <span class="ruby-identifier">i</span>]);
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">forward</span>(<span class="ruby-value">1</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">EXPRESSION_START</span>, <span class="ruby-identifier">tag</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) {
        <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">push</span>([<span class="ruby-identifier">tag</span>, <span class="ruby-identifier">i</span>]);
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">forward</span>(<span class="ruby-value">1</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">EXPRESSION_END</span>, <span class="ruby-identifier">tag</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) {
        <span class="ruby-keyword">while</span> (<span class="ruby-identifier">inImplicit</span>()) {
          <span class="ruby-keyword">if</span> (<span class="ruby-identifier">inImplicitCall</span>()) {
            <span class="ruby-identifier">endImplicitCall</span>();
          } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">inImplicitObject</span>()) {
            <span class="ruby-identifier">endImplicitObject</span>();
          } <span class="ruby-keyword">else</span> {
            <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">pop</span>();
          }
        }
        <span class="ruby-identifier">start</span> = <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">pop</span>();
      }
      <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">IMPLICIT_FUNC</span>, <span class="ruby-identifier">tag</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">token</span>.<span class="ruby-identifier">spaced</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;?&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>].<span class="ruby-identifier">spaced</span>) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">IMPLICIT_CALL</span>, <span class="ruby-identifier">nextTag</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">IMPLICIT_UNSPACED_CALL</span>, <span class="ruby-identifier">nextTag</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>((<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>]) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref</span>.<span class="ruby-identifier">spaced</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>((<span class="ruby-identifier">ref1</span> = <span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>]) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref1</span>.<span class="ruby-identifier">newLine</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>))) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;?&#39;</span>) {
          <span class="ruby-identifier">tag</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>] = <span class="ruby-string">&#39;FUNC_EXIST&#39;</span>;
        }
        <span class="ruby-identifier">startImplicitCall</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>);
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">forward</span>(<span class="ruby-value">2</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">IMPLICIT_FUNC</span>, <span class="ruby-identifier">tag</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">indexOfTag</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>, <span class="ruby-string">&#39;INDENT&#39;</span>, <span class="ruby-identifier">null</span>, <span class="ruby-string">&#39;:&#39;</span>) <span class="ruby-operator">&gt;</span> <span class="ruby-value">-1</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">findTagsBackwards</span>(<span class="ruby-identifier">i</span>, [<span class="ruby-string">&#39;CLASS&#39;</span>, <span class="ruby-string">&#39;EXTENDS&#39;</span>, <span class="ruby-string">&#39;IF&#39;</span>, <span class="ruby-string">&#39;CATCH&#39;</span>, <span class="ruby-string">&#39;SWITCH&#39;</span>, <span class="ruby-string">&#39;LEADING_WHEN&#39;</span>, <span class="ruby-string">&#39;FOR&#39;</span>, <span class="ruby-string">&#39;WHILE&#39;</span>, <span class="ruby-string">&#39;UNTIL&#39;</span>])) {
        <span class="ruby-identifier">startImplicitCall</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>);
        <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">push</span>([<span class="ruby-string">&#39;INDENT&#39;</span>, <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">2</span>]);
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">forward</span>(<span class="ruby-value">3</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;:&#39;</span>) {
        <span class="ruby-identifier">s</span> = (<span class="ruby-identifier">function</span>() {
          <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref2</span>;
          <span class="ruby-identifier">switch</span> (<span class="ruby-keyword">false</span>) {
            <span class="ruby-keyword">case</span> <span class="ruby-identifier">ref2</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>), <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">EXPRESSION_END</span>, <span class="ruby-identifier">ref2</span>) <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span><span class="ruby-operator">:</span>
              <span class="ruby-keyword">return</span> <span class="ruby-identifier">start</span>[<span class="ruby-value">1</span>];
            <span class="ruby-keyword">case</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">2</span>) <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;@&#39;</span><span class="ruby-operator">:</span>
              <span class="ruby-keyword">return</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">2</span>;
            <span class="ruby-identifier">default</span><span class="ruby-operator">:</span>
              <span class="ruby-keyword">return</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>;
          }
        }).<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>);
        <span class="ruby-keyword">while</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">s</span> <span class="ruby-operator">-</span> <span class="ruby-value">2</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;HERECOMMENT&#39;</span>) {
          <span class="ruby-identifier">s</span> <span class="ruby-operator">-=</span> <span class="ruby-value">2</span>;
        }
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">insideForDeclaration</span> = <span class="ruby-identifier">nextTag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;FOR&#39;</span>;
        <span class="ruby-identifier">startsLine</span> = <span class="ruby-identifier">s</span> <span class="ruby-operator">===</span> <span class="ruby-value">0</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">ref2</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">s</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>), <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">LINEBREAKS</span>, <span class="ruby-identifier">ref2</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">s</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>].<span class="ruby-identifier">newLine</span>;
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">stackTop</span>()) {
          <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">stackTop</span>(), <span class="ruby-identifier">stackTag</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">stackIdx</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">1</span>];
          <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">stackTag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;{&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">stackTag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;INDENT&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">stackIdx</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;{&#39;</span>) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">startsLine</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">s</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;,&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">s</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;{&#39;</span>)) {
            <span class="ruby-keyword">return</span> <span class="ruby-identifier">forward</span>(<span class="ruby-value">1</span>);
          }
        }
        <span class="ruby-identifier">startImplicitObject</span>(<span class="ruby-identifier">s</span>, <span class="ruby-operator">!</span><span class="ruby-operator">!</span><span class="ruby-identifier">startsLine</span>);
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">forward</span>(<span class="ruby-value">2</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">inImplicitObject</span>() <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">LINEBREAKS</span>, <span class="ruby-identifier">tag</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) {
        <span class="ruby-identifier">stackTop</span>()[<span class="ruby-value">2</span>].<span class="ruby-identifier">sameLine</span> = <span class="ruby-keyword">false</span>;
      }
      <span class="ruby-identifier">newLine</span> = <span class="ruby-identifier">prevTag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;OUTDENT&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">prevToken</span>.<span class="ruby-identifier">newLine</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">IMPLICIT_END</span>, <span class="ruby-identifier">tag</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">CALL_CLOSERS</span>, <span class="ruby-identifier">tag</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">newLine</span>) {
        <span class="ruby-keyword">while</span> (<span class="ruby-identifier">inImplicit</span>()) {
          <span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">stackTop</span>(), <span class="ruby-identifier">stackTag</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">stackIdx</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">1</span>], (<span class="ruby-identifier">ref5</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">2</span>], <span class="ruby-identifier">sameLine</span> = <span class="ruby-identifier">ref5</span>.<span class="ruby-identifier">sameLine</span>, <span class="ruby-identifier">startsLine</span> = <span class="ruby-identifier">ref5</span>.<span class="ruby-identifier">startsLine</span>);
          <span class="ruby-keyword">if</span> (<span class="ruby-identifier">inImplicitCall</span>() <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prevTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;,&#39;</span>) {
            <span class="ruby-identifier">endImplicitCall</span>();
          } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">inImplicitObject</span>() <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">insideForDeclaration</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">sameLine</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">tag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;TERMINATOR&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prevTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;:&#39;</span>) {
            <span class="ruby-identifier">endImplicitObject</span>();
          } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">inImplicitObject</span>() <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;TERMINATOR&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prevTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;,&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">startsLine</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">looksObjectish</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>))) {
            <span class="ruby-keyword">if</span> (<span class="ruby-identifier">nextTag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;HERECOMMENT&#39;</span>) {
              <span class="ruby-keyword">return</span> <span class="ruby-identifier">forward</span>(<span class="ruby-value">1</span>);
            }
            <span class="ruby-identifier">endImplicitObject</span>();
          } <span class="ruby-keyword">else</span> {
            <span class="ruby-keyword">break</span>;
          }
        }
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;,&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">looksObjectish</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">inImplicitObject</span>() <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">insideForDeclaration</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">nextTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;TERMINATOR&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">looksObjectish</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">2</span>))) {
        <span class="ruby-identifier">offset</span> = <span class="ruby-identifier">nextTag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;OUTDENT&#39;</span> <span class="ruby-operator">?</span> <span class="ruby-value">1</span> <span class="ruby-operator">:</span> <span class="ruby-value">0</span>;
        <span class="ruby-keyword">while</span> (<span class="ruby-identifier">inImplicitObject</span>()) {
          <span class="ruby-identifier">endImplicitObject</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">offset</span>);
        }
      }
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">forward</span>(<span class="ruby-value">1</span>);
    });
  };

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">addLocationDataToGeneratedTokens</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">scanTokens</span>(<span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">tokens</span>) {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">column</span>, <span class="ruby-identifier">line</span>, <span class="ruby-identifier">nextLocation</span>, <span class="ruby-identifier">prevLocation</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref1</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">token</span>[<span class="ruby-value">2</span>]) {
        <span class="ruby-keyword">return</span> <span class="ruby-value">1</span>;
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">token</span>.<span class="ruby-identifier">generated</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">token</span>.<span class="ruby-identifier">explicit</span>)) {
        <span class="ruby-keyword">return</span> <span class="ruby-value">1</span>;
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">===</span> <span class="ruby-string">&#39;{&#39;</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">nextLocation</span> = (<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>]) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>)) {
        <span class="ruby-identifier">line</span> = <span class="ruby-identifier">nextLocation</span>.<span class="ruby-identifier">first_line</span>, <span class="ruby-identifier">column</span> = <span class="ruby-identifier">nextLocation</span>.<span class="ruby-identifier">first_column</span>;
      } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">prevLocation</span> = (<span class="ruby-identifier">ref1</span> = <span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>]) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref1</span>[<span class="ruby-value">2</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) {
        <span class="ruby-identifier">line</span> = <span class="ruby-identifier">prevLocation</span>.<span class="ruby-identifier">last_line</span>, <span class="ruby-identifier">column</span> = <span class="ruby-identifier">prevLocation</span>.<span class="ruby-identifier">last_column</span>;
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">line</span> = <span class="ruby-identifier">column</span> = <span class="ruby-value">0</span>;
      }
      <span class="ruby-identifier">token</span>[<span class="ruby-value">2</span>] = {
        <span class="ruby-identifier">first_line</span><span class="ruby-operator">:</span> <span class="ruby-identifier">line</span>,
        <span class="ruby-identifier">first_column</span><span class="ruby-operator">:</span> <span class="ruby-identifier">column</span>,
        <span class="ruby-identifier">last_line</span><span class="ruby-operator">:</span> <span class="ruby-identifier">line</span>,
        <span class="ruby-identifier">last_column</span><span class="ruby-operator">:</span> <span class="ruby-identifier">column</span>
      };
      <span class="ruby-keyword">return</span> <span class="ruby-value">1</span>;
    });
  };

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">normalizeLines</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">action</span>, <span class="ruby-identifier">condition</span>, <span class="ruby-identifier">indent</span>, <span class="ruby-identifier">outdent</span>, <span class="ruby-identifier">starter</span>;
    <span class="ruby-identifier">starter</span> = <span class="ruby-identifier">indent</span> = <span class="ruby-identifier">outdent</span> = <span class="ruby-identifier">null</span>;
    <span class="ruby-identifier">condition</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>) {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref1</span>, <span class="ruby-identifier">ref2</span>, <span class="ruby-identifier">ref3</span>;
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">token</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;;&#39;</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">SINGLE_CLOSERS</span>, <span class="ruby-identifier">ref</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">===</span> <span class="ruby-string">&#39;TERMINATOR&#39;</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">ref1</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>), <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">EXPRESSION_CLOSE</span>, <span class="ruby-identifier">ref1</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>)) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">===</span> <span class="ruby-string">&#39;ELSE&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">starter</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;THEN&#39;</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(((<span class="ruby-identifier">ref2</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>]) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;CATCH&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref2</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;FINALLY&#39;</span>) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">starter</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;-&gt;&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">starter</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;=&gt;&#39;</span>)) <span class="ruby-operator">||</span> (<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">CALL_CLOSERS</span>, <span class="ruby-identifier">ref3</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>].<span class="ruby-identifier">newLine</span>;
    };
    <span class="ruby-identifier">action</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">splice</span>((<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;,&#39;</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">i</span>), <span class="ruby-value">0</span>, <span class="ruby-identifier">outdent</span>);
    };
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">scanTokens</span>(<span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">tokens</span>) {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">j</span>, <span class="ruby-identifier">k</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref1</span>, <span class="ruby-identifier">ref2</span>, <span class="ruby-identifier">tag</span>;
      <span class="ruby-identifier">tag</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;TERMINATOR&#39;</span>) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;ELSE&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>) <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;OUTDENT&#39;</span>) {
          <span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">splice</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">tokens</span>, [<span class="ruby-identifier">i</span>, <span class="ruby-value">1</span>].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">slice</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">indentation</span>())));
          <span class="ruby-keyword">return</span> <span class="ruby-value">1</span>;
        }
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>), <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">EXPRESSION_CLOSE</span>, <span class="ruby-identifier">ref</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) {
          <span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">splice</span>(<span class="ruby-identifier">i</span>, <span class="ruby-value">1</span>);
          <span class="ruby-keyword">return</span> <span class="ruby-value">0</span>;
        }
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;CATCH&#39;</span>) {
        <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-identifier">k</span> = <span class="ruby-value">1</span>; <span class="ruby-identifier">k</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-value">2</span>; <span class="ruby-identifier">j</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">k</span>) {
          <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>((<span class="ruby-identifier">ref1</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">j</span>)) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;OUTDENT&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref1</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;TERMINATOR&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref1</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;FINALLY&#39;</span>)) {
            <span class="ruby-identifier">continue</span>;
          }
          <span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">splice</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">tokens</span>, [<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">j</span>, <span class="ruby-value">0</span>].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">slice</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">indentation</span>())));
          <span class="ruby-keyword">return</span> <span class="ruby-value">2</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">j</span>;
        }
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">SINGLE_LINERS</span>, <span class="ruby-identifier">tag</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>) <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;INDENT&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;ELSE&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tag</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;IF&#39;</span>)) {
        <span class="ruby-identifier">starter</span> = <span class="ruby-identifier">tag</span>;
        <span class="ruby-identifier">ref2</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">indentation</span>(<span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">i</span>]), <span class="ruby-identifier">indent</span> = <span class="ruby-identifier">ref2</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">outdent</span> = <span class="ruby-identifier">ref2</span>[<span class="ruby-value">1</span>];
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">starter</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;THEN&#39;</span>) {
          <span class="ruby-identifier">indent</span>.<span class="ruby-identifier">fromThen</span> = <span class="ruby-keyword">true</span>;
        }
        <span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">splice</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>, <span class="ruby-value">0</span>, <span class="ruby-identifier">indent</span>);
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">detectEnd</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">2</span>, <span class="ruby-identifier">condition</span>, <span class="ruby-identifier">action</span>);
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;THEN&#39;</span>) {
          <span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">splice</span>(<span class="ruby-identifier">i</span>, <span class="ruby-value">1</span>);
        }
        <span class="ruby-keyword">return</span> <span class="ruby-value">1</span>;
      }
      <span class="ruby-keyword">return</span> <span class="ruby-value">1</span>;
    });
  };

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">tagPostfixConditionals</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">action</span>, <span class="ruby-identifier">condition</span>, <span class="ruby-identifier">original</span>;
    <span class="ruby-identifier">original</span> = <span class="ruby-identifier">null</span>;
    <span class="ruby-identifier">condition</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>) {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">prevTag</span>, <span class="ruby-identifier">tag</span>;
      <span class="ruby-identifier">tag</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>];
      <span class="ruby-identifier">prevTag</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>][<span class="ruby-value">0</span>];
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;TERMINATOR&#39;</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;INDENT&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">SINGLE_LINERS</span>, <span class="ruby-identifier">prevTag</span>) <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>);
    };
    <span class="ruby-identifier">action</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;INDENT&#39;</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">token</span>.<span class="ruby-identifier">generated</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">token</span>.<span class="ruby-identifier">fromThen</span>)) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">original</span>[<span class="ruby-value">0</span>] = <span class="ruby-string">&#39;POST_&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">original</span>[<span class="ruby-value">0</span>];
      }
    };
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">scanTokens</span>(<span class="ruby-identifier">function</span>(<span class="ruby-identifier">token</span>, <span class="ruby-identifier">i</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;IF&#39;</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-value">1</span>;
      }
      <span class="ruby-identifier">original</span> = <span class="ruby-identifier">token</span>;
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">detectEnd</span>(<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>, <span class="ruby-identifier">condition</span>, <span class="ruby-identifier">action</span>);
      <span class="ruby-keyword">return</span> <span class="ruby-value">1</span>;
    });
  };

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">indentation</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">origin</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">indent</span>, <span class="ruby-identifier">outdent</span>;
    <span class="ruby-identifier">indent</span> = [<span class="ruby-string">&#39;INDENT&#39;</span>, <span class="ruby-value">2</span>];
    <span class="ruby-identifier">outdent</span> = [<span class="ruby-string">&#39;OUTDENT&#39;</span>, <span class="ruby-value">2</span>];
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">origin</span>) {
      <span class="ruby-identifier">indent</span>.<span class="ruby-identifier">generated</span> = <span class="ruby-identifier">outdent</span>.<span class="ruby-identifier">generated</span> = <span class="ruby-keyword">true</span>;
      <span class="ruby-identifier">indent</span>.<span class="ruby-identifier">origin</span> = <span class="ruby-identifier">outdent</span>.<span class="ruby-identifier">origin</span> = <span class="ruby-identifier">origin</span>;
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">indent</span>.<span class="ruby-identifier">explicit</span> = <span class="ruby-identifier">outdent</span>.<span class="ruby-identifier">explicit</span> = <span class="ruby-keyword">true</span>;
    }
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">indent</span>, <span class="ruby-identifier">outdent</span>];
  };

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">generate</span> = <span class="ruby-identifier">generate</span>;

  <span class="ruby-constant">Rewriter</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">tag</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">i</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref</span>;
    <span class="ruby-keyword">return</span> (<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">i</span>]) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>;
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Rewriter</span>;

})();

<span class="ruby-constant">BALANCED_PAIRS</span> = [[<span class="ruby-string">&#39;(&#39;</span>, <span class="ruby-string">&#39;)&#39;</span>], [<span class="ruby-string">&#39;[&#39;</span>, <span class="ruby-string">&#39;]&#39;</span>], [<span class="ruby-string">&#39;{&#39;</span>, <span class="ruby-string">&#39;}&#39;</span>], [<span class="ruby-string">&#39;INDENT&#39;</span>, <span class="ruby-string">&#39;OUTDENT&#39;</span>], [<span class="ruby-string">&#39;CALL_START&#39;</span>, <span class="ruby-string">&#39;CALL_END&#39;</span>], [<span class="ruby-string">&#39;PARAM_START&#39;</span>, <span class="ruby-string">&#39;PARAM_END&#39;</span>], [<span class="ruby-string">&#39;INDEX_START&#39;</span>, <span class="ruby-string">&#39;INDEX_END&#39;</span>], [<span class="ruby-string">&#39;STRING_START&#39;</span>, <span class="ruby-string">&#39;STRING_END&#39;</span>], [<span class="ruby-string">&#39;REGEX_START&#39;</span>, <span class="ruby-string">&#39;REGEX_END&#39;</span>]];

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">INVERSES</span> = <span class="ruby-constant">INVERSES</span> = {};

<span class="ruby-constant">EXPRESSION_START</span> = [];

<span class="ruby-constant">EXPRESSION_END</span> = [];

<span class="ruby-keyword">for</span> (<span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len</span> = <span class="ruby-constant">BALANCED_PAIRS</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">k</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len</span>; <span class="ruby-identifier">k</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
  <span class="ruby-identifier">ref</span> = <span class="ruby-constant">BALANCED_PAIRS</span>[<span class="ruby-identifier">k</span>], <span class="ruby-identifier">left</span> = <span class="ruby-identifier">ref</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">rite</span> = <span class="ruby-identifier">ref</span>[<span class="ruby-value">1</span>];
  <span class="ruby-constant">EXPRESSION_START</span>.<span class="ruby-identifier">push</span>(<span class="ruby-constant">INVERSES</span>[<span class="ruby-identifier">rite</span>] = <span class="ruby-identifier">left</span>);
  <span class="ruby-constant">EXPRESSION_END</span>.<span class="ruby-identifier">push</span>(<span class="ruby-constant">INVERSES</span>[<span class="ruby-identifier">left</span>] = <span class="ruby-identifier">rite</span>);
}

<span class="ruby-constant">EXPRESSION_CLOSE</span> = [<span class="ruby-string">&#39;CATCH&#39;</span>, <span class="ruby-string">&#39;THEN&#39;</span>, <span class="ruby-string">&#39;ELSE&#39;</span>, <span class="ruby-string">&#39;FINALLY&#39;</span>].<span class="ruby-identifier">concat</span>(<span class="ruby-constant">EXPRESSION_END</span>);

<span class="ruby-constant">IMPLICIT_FUNC</span> = [<span class="ruby-string">&#39;IDENTIFIER&#39;</span>, <span class="ruby-string">&#39;SUPER&#39;</span>, <span class="ruby-string">&#39;)&#39;</span>, <span class="ruby-string">&#39;CALL_END&#39;</span>, <span class="ruby-string">&#39;]&#39;</span>, <span class="ruby-string">&#39;INDEX_END&#39;</span>, <span class="ruby-string">&#39;@&#39;</span>, <span class="ruby-string">&#39;THIS&#39;</span>];

<span class="ruby-constant">IMPLICIT_CALL</span> = [<span class="ruby-string">&#39;IDENTIFIER&#39;</span>, <span class="ruby-string">&#39;NUMBER&#39;</span>, <span class="ruby-string">&#39;STRING&#39;</span>, <span class="ruby-string">&#39;STRING_START&#39;</span>, <span class="ruby-string">&#39;JS&#39;</span>, <span class="ruby-string">&#39;REGEX&#39;</span>, <span class="ruby-string">&#39;REGEX_START&#39;</span>, <span class="ruby-string">&#39;NEW&#39;</span>, <span class="ruby-string">&#39;PARAM_START&#39;</span>, <span class="ruby-string">&#39;CLASS&#39;</span>, <span class="ruby-string">&#39;IF&#39;</span>, <span class="ruby-string">&#39;TRY&#39;</span>, <span class="ruby-string">&#39;SWITCH&#39;</span>, <span class="ruby-string">&#39;THIS&#39;</span>, <span class="ruby-string">&#39;BOOL&#39;</span>, <span class="ruby-string">&#39;NULL&#39;</span>, <span class="ruby-string">&#39;UNDEFINED&#39;</span>, <span class="ruby-string">&#39;UNARY&#39;</span>, <span class="ruby-string">&#39;YIELD&#39;</span>, <span class="ruby-string">&#39;UNARY_MATH&#39;</span>, <span class="ruby-string">&#39;SUPER&#39;</span>, <span class="ruby-string">&#39;THROW&#39;</span>, <span class="ruby-string">&#39;@&#39;</span>, <span class="ruby-string">&#39;-&gt;&#39;</span>, <span class="ruby-string">&#39;=&gt;&#39;</span>, <span class="ruby-string">&#39;[&#39;</span>, <span class="ruby-string">&#39;(&#39;</span>, <span class="ruby-string">&#39;{&#39;</span>, <span class="ruby-string">&#39;--&#39;</span>, <span class="ruby-string">&#39;++&#39;</span>];

<span class="ruby-constant">IMPLICIT_UNSPACED_CALL</span> = [<span class="ruby-string">&#39;+&#39;</span>, <span class="ruby-string">&#39;-&#39;</span>];

<span class="ruby-constant">IMPLICIT_END</span> = [<span class="ruby-string">&#39;POST_IF&#39;</span>, <span class="ruby-string">&#39;FOR&#39;</span>, <span class="ruby-string">&#39;WHILE&#39;</span>, <span class="ruby-string">&#39;UNTIL&#39;</span>, <span class="ruby-string">&#39;WHEN&#39;</span>, <span class="ruby-string">&#39;BY&#39;</span>, <span class="ruby-string">&#39;LOOP&#39;</span>, <span class="ruby-string">&#39;TERMINATOR&#39;</span>];

<span class="ruby-constant">SINGLE_LINERS</span> = [<span class="ruby-string">&#39;ELSE&#39;</span>, <span class="ruby-string">&#39;-&gt;&#39;</span>, <span class="ruby-string">&#39;=&gt;&#39;</span>, <span class="ruby-string">&#39;TRY&#39;</span>, <span class="ruby-string">&#39;FINALLY&#39;</span>, <span class="ruby-string">&#39;THEN&#39;</span>];

<span class="ruby-constant">SINGLE_CLOSERS</span> = [<span class="ruby-string">&#39;TERMINATOR&#39;</span>, <span class="ruby-string">&#39;CATCH&#39;</span>, <span class="ruby-string">&#39;FINALLY&#39;</span>, <span class="ruby-string">&#39;ELSE&#39;</span>, <span class="ruby-string">&#39;OUTDENT&#39;</span>, <span class="ruby-string">&#39;LEADING_WHEN&#39;</span>];

<span class="ruby-constant">LINEBREAKS</span> = [<span class="ruby-string">&#39;TERMINATOR&#39;</span>, <span class="ruby-string">&#39;INDENT&#39;</span>, <span class="ruby-string">&#39;OUTDENT&#39;</span>];

<span class="ruby-constant">CALL_CLOSERS</span> = [<span class="ruby-string">&#39;.&#39;</span>, <span class="ruby-string">&#39;?.&#39;</span>, <span class="ruby-string">&#39;::&#39;</span>, <span class="ruby-string">&#39;?::&#39;</span>];
</pre>

<p>}).call(this);</p>

<pre>return module.exports;</pre>

<p>})();<a href="http://'./lexer'">require</a> = (function() {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">exports</span> = {}, <span class="ruby-identifier">module</span> = {<span class="ruby-identifier">exports</span><span class="ruby-operator">:</span> <span class="ruby-identifier">exports</span>};
<span class="ruby-regexp">//</span> <span class="ruby-constant">Generated</span> <span class="ruby-identifier">by</span> <span class="ruby-constant">CoffeeScript</span> <span class="ruby-value">1.9</span><span class="ruby-value">.1</span>
</pre>

<p>(function() {</p>

<pre>var BOM, BOOL, CALLABLE, CODE, COFFEE_ALIASES, COFFEE_ALIAS_MAP, COFFEE_KEYWORDS, COMMENT, COMPARE, COMPOUND_ASSIGN, HERECOMMENT_ILLEGAL, HEREDOC_DOUBLE, HEREDOC_INDENT, HEREDOC_SINGLE, HEREGEX, HEREGEX_OMIT, IDENTIFIER, INDENTABLE_CLOSERS, INDEXABLE, INVALID_ESCAPE, INVERSES, JSTOKEN, JS_FORBIDDEN, JS_KEYWORDS, LEADING_BLANK_LINE, LINE_BREAK, LINE_CONTINUER, LOGIC, Lexer, MATH, MULTI_DENT, NOT_REGEX, NUMBER, OPERATOR, POSSIBLY_DIVISION, REGEX, REGEX_FLAGS, REGEX_ILLEGAL, RELATION, RESERVED, Rewriter, SHIFT, SIMPLE_STRING_OMIT, STRICT_PROSCRIBED, STRING_DOUBLE, STRING_OMIT, STRING_SINGLE, STRING_START, TRAILING_BLANK_LINE, TRAILING_SPACES, UNARY, UNARY_MATH, VALID_FLAGS, WHITESPACE, compact, count, invertLiterate, key, locationDataToString, ref, ref1, repeat, starts, throwSyntaxError,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i &lt; l; i++) { if (i in this &amp;&amp; this[i] === item) return i; } return -1; };

ref = require(&#39;./rewriter&#39;), Rewriter = ref.Rewriter, INVERSES = ref.INVERSES;

ref1 = require(&#39;./helpers&#39;), count = ref1.count, starts = ref1.starts, compact = ref1.compact, repeat = ref1.repeat, invertLiterate = ref1.invertLiterate, locationDataToString = ref1.locationDataToString, throwSyntaxError = ref1.throwSyntaxError;

exports.Lexer = Lexer = (function() {
  function Lexer() {}

  Lexer.prototype.tokenize = function(code, opts) {
    var consumed, end, i, ref2;
    if (opts == null) {
      opts = {};
    }
    this.literate = opts.literate;
    this.indent = 0;
    this.baseIndent = 0;
    this.indebt = 0;
    this.outdebt = 0;
    this.indents = [];
    this.ends = [];
    this.tokens = [];
    this.chunkLine = opts.line || 0;
    this.chunkColumn = opts.column || 0;
    code = this.clean(code);
    i = 0;
    while (this.chunk = code.slice(i)) {
      consumed = this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken();
      ref2 = this.getLineAndColumnFromChunk(consumed), this.chunkLine = ref2[0], this.chunkColumn = ref2[1];
      i += consumed;
      if (opts.untilBalanced &amp;&amp; this.ends.length === 0) {
        return {
          tokens: this.tokens,
          index: i
        };
      }
    }
    this.closeIndentation();
    if (end = this.ends.pop()) {
      this.error(&quot;missing &quot; + end.tag, end.origin[2]);
    }
    if (opts.rewrite === false) {
      return this.tokens;
    }
    return (new Rewriter).rewrite(this.tokens);
  };

  Lexer.prototype.clean = function(code) {
    if (code.charCodeAt(0) === BOM) {
      code = code.slice(1);
    }
    code = code.replace(/\r/g, &#39;&#39;).replace(TRAILING_SPACES, &#39;&#39;);
    if (WHITESPACE.test(code)) {
      code = &quot;\n&quot; + code;
      this.chunkLine--;
    }
    if (this.literate) {
      code = invertLiterate(code);
    }
    return code;
  };

  Lexer.prototype.identifierToken = function() {
    var colon, colonOffset, forcedIdentifier, id, idLength, input, match, poppedToken, prev, ref2, ref3, ref4, ref5, tag, tagToken;
    if (!(match = IDENTIFIER.exec(this.chunk))) {
      return 0;
    }
    input = match[0], id = match[1], colon = match[2];
    idLength = id.length;
    poppedToken = void 0;
    if (id === &#39;own&#39; &amp;&amp; this.tag() === &#39;FOR&#39;) {
      this.token(&#39;OWN&#39;, id);
      return id.length;
    }
    if (id === &#39;from&#39; &amp;&amp; this.tag() === &#39;YIELD&#39;) {
      this.token(&#39;FROM&#39;, id);
      return id.length;
    }
    ref2 = this.tokens, prev = ref2[ref2.length - 1];
    forcedIdentifier = colon || (prev != null) &amp;&amp; (((ref3 = prev[0]) === &#39;.&#39; || ref3 === &#39;?.&#39; || ref3 === &#39;::&#39; || ref3 === &#39;?::&#39;) || !prev.spaced &amp;&amp; prev[0] === &#39;@&#39;);
    tag = &#39;IDENTIFIER&#39;;
    if (!forcedIdentifier &amp;&amp; (indexOf.call(JS_KEYWORDS, id) &gt;= 0 || indexOf.call(COFFEE_KEYWORDS, id) &gt;= 0)) {
      tag = id.toUpperCase();
      if (tag === &#39;WHEN&#39; &amp;&amp; (ref4 = this.tag(), indexOf.call(LINE_BREAK, ref4) &gt;= 0)) {
        tag = &#39;LEADING_WHEN&#39;;
      } else if (tag === &#39;FOR&#39;) {
        this.seenFor = true;
      } else if (tag === &#39;UNLESS&#39;) {
        tag = &#39;IF&#39;;
      } else if (indexOf.call(UNARY, tag) &gt;= 0) {
        tag = &#39;UNARY&#39;;
      } else if (indexOf.call(RELATION, tag) &gt;= 0) {
        if (tag !== &#39;INSTANCEOF&#39; &amp;&amp; this.seenFor) {
          tag = &#39;FOR&#39; + tag;
          this.seenFor = false;
        } else {
          tag = &#39;RELATION&#39;;
          if (this.value() === &#39;!&#39;) {
            poppedToken = this.tokens.pop();
            id = &#39;!&#39; + id;
          }
        }
      }
    }
    if (indexOf.call(JS_FORBIDDEN, id) &gt;= 0) {
      if (forcedIdentifier) {
        tag = &#39;IDENTIFIER&#39;;
        id = new String(id);
        id.reserved = true;
      } else if (indexOf.call(RESERVED, id) &gt;= 0) {
        this.error(&quot;reserved word &#39;&quot; + id + &quot;&#39;&quot;, {
          length: id.length
        });
      }
    }
    if (!forcedIdentifier) {
      if (indexOf.call(COFFEE_ALIASES, id) &gt;= 0) {
        id = COFFEE_ALIAS_MAP[id];
      }
      tag = (function() {
        switch (id) {
          case &#39;!&#39;:
            return &#39;UNARY&#39;;
          case &#39;==&#39;:
          case &#39;!=&#39;:
            return &#39;COMPARE&#39;;
          case &#39;&amp;&amp;&#39;:
          case &#39;||&#39;:
            return &#39;LOGIC&#39;;
          case &#39;true&#39;:
          case &#39;false&#39;:
            return &#39;BOOL&#39;;
          case &#39;break&#39;:
          case &#39;continue&#39;:
            return &#39;STATEMENT&#39;;
          default:
            return tag;
        }
      })();
    }
    tagToken = this.token(tag, id, 0, idLength);
    tagToken.variable = !forcedIdentifier;
    if (poppedToken) {
      ref5 = [poppedToken[2].first_line, poppedToken[2].first_column], tagToken[2].first_line = ref5[0], tagToken[2].first_column = ref5[1];
    }
    if (colon) {
      colonOffset = input.lastIndexOf(&#39;:&#39;);
      this.token(&#39;:&#39;, &#39;:&#39;, colonOffset, colon.length);
    }
    return input.length;
  };

  Lexer.prototype.numberToken = function() {
    var binaryLiteral, lexedLength, match, number, octalLiteral;
    if (!(match = NUMBER.exec(this.chunk))) {
      return 0;
    }
    number = match[0];
    lexedLength = number.length;
    if (/^0[BOX]/.test(number)) {
      this.error(&quot;radix prefix in &#39;&quot; + number + &quot;&#39; must be lowercase&quot;, {
        offset: 1
      });
    } else if (/E/.test(number) &amp;&amp; !/^0x/.test(number)) {
      this.error(&quot;exponential notation in &#39;&quot; + number + &quot;&#39; must be indicated with a lowercase &#39;e&#39;&quot;, {
        offset: number.indexOf(&#39;E&#39;)
      });
    } else if (/^0\d*[89]/.test(number)) {
      this.error(&quot;decimal literal &#39;&quot; + number + &quot;&#39; must not be prefixed with &#39;0&#39;&quot;, {
        length: lexedLength
      });
    } else if (/^0\d+/.test(number)) {
      this.error(&quot;octal literal &#39;&quot; + number + &quot;&#39; must be prefixed with &#39;0o&#39;&quot;, {
        length: lexedLength
      });
    }
    if (octalLiteral = /^0o([0-7]+)/.exec(number)) {
      number = &#39;0x&#39; + parseInt(octalLiteral[1], 8).toString(16);
    }
    if (binaryLiteral = /^0b([01]+)/.exec(number)) {
      number = &#39;0x&#39; + parseInt(binaryLiteral[1], 2).toString(16);
    }
    this.token(&#39;NUMBER&#39;, number, 0, lexedLength);
    return lexedLength;
  };

  Lexer.prototype.stringToken = function() {
    var $, attempt, delimiter, doc, end, heredoc, i, indent, indentRegex, match, quote, ref2, ref3, regex, token, tokens;
    quote = (STRING_START.exec(this.chunk) || [])[0];
    if (!quote) {
      return 0;
    }
    regex = (function() {
      switch (quote) {
        case &quot;&#39;&quot;:
          return STRING_SINGLE;
        case &#39;&quot;&#39;:
          return STRING_DOUBLE;
        case &quot;&#39;&#39;&#39;&quot;:
          return HEREDOC_SINGLE;
        case &#39;&quot;&quot;&quot;&#39;:
          return HEREDOC_DOUBLE;
      }
    })();
    heredoc = quote.length === 3;
    ref2 = this.matchWithInterpolations(regex, quote), tokens = ref2.tokens, end = ref2.index;
    $ = tokens.length - 1;
    delimiter = quote.charAt(0);
    if (heredoc) {
      indent = null;
      doc = ((function() {
        var j, len, results;
        results = [];
        for (i = j = 0, len = tokens.length; j &lt; len; i = ++j) {
          token = tokens[i];
          if (token[0] === &#39;NEOSTRING&#39;) {
            results.push(token[1]);
          }
        }
        return results;
      })()).join(&#39;#{}&#39;);
      while (match = HEREDOC_INDENT.exec(doc)) {
        attempt = match[1];
        if (indent === null || (0 &lt; (ref3 = attempt.length) &amp;&amp; ref3 &lt; indent.length)) {
          indent = attempt;
        }
      }
      if (indent) {
        indentRegex = RegExp(&quot;^&quot; + indent, &quot;gm&quot;);
      }
      this.mergeInterpolationTokens(tokens, {
        delimiter: delimiter
      }, (function(_this) {
        return function(value, i) {
          value = _this.formatString(value);
          if (i === 0) {
            value = value.replace(LEADING_BLANK_LINE, &#39;&#39;);
          }
          if (i === $) {
            value = value.replace(TRAILING_BLANK_LINE, &#39;&#39;);
          }
          if (indentRegex) {
            value = value.replace(indentRegex, &#39;&#39;);
          }
          return value;
        };
      })(this));
    } else {
      this.mergeInterpolationTokens(tokens, {
        delimiter: delimiter
      }, (function(_this) {
        return function(value, i) {
          value = _this.formatString(value);
          value = value.replace(SIMPLE_STRING_OMIT, function(match, offset) {
            if ((i === 0 &amp;&amp; offset === 0) || (i === $ &amp;&amp; offset + match.length === value.length)) {
              return &#39;&#39;;
            } else {
              return &#39; &#39;;
            }
          });
          return value;
        };
      })(this));
    }
    return end;
  };

  Lexer.prototype.commentToken = function() {
    var comment, here, match;
    if (!(match = this.chunk.match(COMMENT))) {
      return 0;
    }
    comment = match[0], here = match[1];
    if (here) {
      if (match = HERECOMMENT_ILLEGAL.exec(comment)) {
        this.error(&quot;block comments cannot contain &quot; + match[0], {
          offset: match.index,
          length: match[0].length
        });
      }
      if (here.indexOf(&#39;\n&#39;) &gt;= 0) {
        here = here.replace(RegExp(&quot;\\n&quot; + (repeat(&#39; &#39;, this.indent)), &quot;g&quot;), &#39;\n&#39;);
      }
      this.token(&#39;HERECOMMENT&#39;, here, 0, comment.length);
    }
    return comment.length;
  };

  Lexer.prototype.jsToken = function() {
    var match, script;
    if (!(this.chunk.charAt(0) === &#39;`&#39; &amp;&amp; (match = JSTOKEN.exec(this.chunk)))) {
      return 0;
    }
    this.token(&#39;JS&#39;, (script = match[0]).slice(1, -1), 0, script.length);
    return script.length;
  };

  Lexer.prototype.regexToken = function() {
    var body, closed, end, flags, index, match, origin, prev, ref2, ref3, ref4, regex, tokens;
    switch (false) {
      case !(match = REGEX_ILLEGAL.exec(this.chunk)):
        this.error(&quot;regular expressions cannot begin with &quot; + match[2], {
          offset: match.index + match[1].length
        });
        break;
      case !(match = this.matchWithInterpolations(HEREGEX, &#39;///&#39;)):
        tokens = match.tokens, index = match.index;
        break;
      case !(match = REGEX.exec(this.chunk)):
        regex = match[0], body = match[1], closed = match[2];
        this.validateEscapes(body, {
          isRegex: true,
          offsetInChunk: 1
        });
        index = regex.length;
        ref2 = this.tokens, prev = ref2[ref2.length - 1];
        if (prev) {
          if (prev.spaced &amp;&amp; (ref3 = prev[0], indexOf.call(CALLABLE, ref3) &gt;= 0)) {
            if (!closed || POSSIBLY_DIVISION.test(regex)) {
              return 0;
            }
          } else if (ref4 = prev[0], indexOf.call(NOT_REGEX, ref4) &gt;= 0) {
            return 0;
          }
        }
        if (!closed) {
          this.error(&#39;missing / (unclosed regex)&#39;);
        }
        break;
      default:
        return 0;
    }
    flags = REGEX_FLAGS.exec(this.chunk.slice(index))[0];
    end = index + flags.length;
    origin = this.makeToken(&#39;REGEX&#39;, null, 0, end);
    switch (false) {
      case !!VALID_FLAGS.test(flags):
        this.error(&quot;invalid regular expression flags &quot; + flags, {
          offset: index,
          length: flags.length
        });
        break;
      case !(regex || tokens.length === 1):
        if (body == null) {
          body = this.formatHeregex(tokens[0][1]);
        }
        this.token(&#39;REGEX&#39;, &quot;&quot; + (this.makeDelimitedLiteral(body, {
          delimiter: &#39;/&#39;
        })) + flags, 0, end, origin);
        break;
      default:
        this.token(&#39;REGEX_START&#39;, &#39;(&#39;, 0, 0, origin);
        this.token(&#39;IDENTIFIER&#39;, &#39;RegExp&#39;, 0, 0);
        this.token(&#39;CALL_START&#39;, &#39;(&#39;, 0, 0);
        this.mergeInterpolationTokens(tokens, {
          delimiter: &#39;&quot;&#39;,
          double: true
        }, this.formatHeregex);
        if (flags) {
          this.token(&#39;,&#39;, &#39;,&#39;, index, 0);
          this.token(&#39;STRING&#39;, &#39;&quot;&#39; + flags + &#39;&quot;&#39;, index, flags.length);
        }
        this.token(&#39;)&#39;, &#39;)&#39;, end, 0);
        this.token(&#39;REGEX_END&#39;, &#39;)&#39;, end, 0);
    }
    return end;
  };

  Lexer.prototype.lineToken = function() {
    var diff, indent, match, noNewlines, size;
    if (!(match = MULTI_DENT.exec(this.chunk))) {
      return 0;
    }
    indent = match[0];
    this.seenFor = false;
    size = indent.length - 1 - indent.lastIndexOf(&#39;\n&#39;);
    noNewlines = this.unfinished();
    if (size - this.indebt === this.indent) {
      if (noNewlines) {
        this.suppressNewlines();
      } else {
        this.newlineToken(0);
      }
      return indent.length;
    }
    if (size &gt; this.indent) {
      if (noNewlines) {
        this.indebt = size - this.indent;
        this.suppressNewlines();
        return indent.length;
      }
      if (!this.tokens.length) {
        this.baseIndent = this.indent = size;
        return indent.length;
      }
      diff = size - this.indent + this.outdebt;
      this.token(&#39;INDENT&#39;, diff, indent.length - size, size);
      this.indents.push(diff);
      this.ends.push({
        tag: &#39;OUTDENT&#39;
      });
      this.outdebt = this.indebt = 0;
      this.indent = size;
    } else if (size &lt; this.baseIndent) {
      this.error(&#39;missing indentation&#39;, {
        offset: indent.length
      });
    } else {
      this.indebt = 0;
      this.outdentToken(this.indent - size, noNewlines, indent.length);
    }
    return indent.length;
  };

  Lexer.prototype.outdentToken = function(moveOut, noNewlines, outdentLength) {
    var decreasedIndent, dent, lastIndent, ref2;
    decreasedIndent = this.indent - moveOut;
    while (moveOut &gt; 0) {
      lastIndent = this.indents[this.indents.length - 1];
      if (!lastIndent) {
        moveOut = 0;
      } else if (lastIndent === this.outdebt) {
        moveOut -= this.outdebt;
        this.outdebt = 0;
      } else if (lastIndent &lt; this.outdebt) {
        this.outdebt -= lastIndent;
        moveOut -= lastIndent;
      } else {
        dent = this.indents.pop() + this.outdebt;
        if (outdentLength &amp;&amp; (ref2 = this.chunk[outdentLength], indexOf.call(INDENTABLE_CLOSERS, ref2) &gt;= 0)) {
          decreasedIndent -= dent - moveOut;
          moveOut = dent;
        }
        this.outdebt = 0;
        this.pair(&#39;OUTDENT&#39;);
        this.token(&#39;OUTDENT&#39;, moveOut, 0, outdentLength);
        moveOut -= dent;
      }
    }
    if (dent) {
      this.outdebt -= moveOut;
    }
    while (this.value() === &#39;;&#39;) {
      this.tokens.pop();
    }
    if (!(this.tag() === &#39;TERMINATOR&#39; || noNewlines)) {
      this.token(&#39;TERMINATOR&#39;, &#39;\n&#39;, outdentLength, 0);
    }
    this.indent = decreasedIndent;
    return this;
  };

  Lexer.prototype.whitespaceToken = function() {
    var match, nline, prev, ref2;
    if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === &#39;\n&#39;))) {
      return 0;
    }
    ref2 = this.tokens, prev = ref2[ref2.length - 1];
    if (prev) {
      prev[match ? &#39;spaced&#39; : &#39;newLine&#39;] = true;
    }
    if (match) {
      return match[0].length;
    } else {
      return 0;
    }
  };

  Lexer.prototype.newlineToken = function(offset) {
    while (this.value() === &#39;;&#39;) {
      this.tokens.pop();
    }
    if (this.tag() !== &#39;TERMINATOR&#39;) {
      this.token(&#39;TERMINATOR&#39;, &#39;\n&#39;, offset, 0);
    }
    return this;
  };

  Lexer.prototype.suppressNewlines = function() {
    if (this.value() === &#39;\\&#39;) {
      this.tokens.pop();
    }
    return this;
  };

  Lexer.prototype.literalToken = function() {
    var match, prev, ref2, ref3, ref4, ref5, ref6, tag, token, value;
    if (match = OPERATOR.exec(this.chunk)) {
      value = match[0];
      if (CODE.test(value)) {
        this.tagParameters();
      }
    } else {
      value = this.chunk.charAt(0);
    }
    tag = value;
    ref2 = this.tokens, prev = ref2[ref2.length - 1];
    if (value === &#39;=&#39; &amp;&amp; prev) {
      if (!prev[1].reserved &amp;&amp; (ref3 = prev[1], indexOf.call(JS_FORBIDDEN, ref3) &gt;= 0)) {
        this.error(&quot;reserved word &#39;&quot; + prev[1] + &quot;&#39; can&#39;t be assigned&quot;, prev[2]);
      }
      if ((ref4 = prev[1]) === &#39;||&#39; || ref4 === &#39;&amp;&amp;&#39;) {
        prev[0] = &#39;COMPOUND_ASSIGN&#39;;
        prev[1] += &#39;=&#39;;
        return value.length;
      }
    }
    if (value === &#39;;&#39;) {
      this.seenFor = false;
      tag = &#39;TERMINATOR&#39;;
    } else if (indexOf.call(MATH, value) &gt;= 0) {
      tag = &#39;MATH&#39;;
    } else if (indexOf.call(COMPARE, value) &gt;= 0) {
      tag = &#39;COMPARE&#39;;
    } else if (indexOf.call(COMPOUND_ASSIGN, value) &gt;= 0) {
      tag = &#39;COMPOUND_ASSIGN&#39;;
    } else if (indexOf.call(UNARY, value) &gt;= 0) {
      tag = &#39;UNARY&#39;;
    } else if (indexOf.call(UNARY_MATH, value) &gt;= 0) {
      tag = &#39;UNARY_MATH&#39;;
    } else if (indexOf.call(SHIFT, value) &gt;= 0) {
      tag = &#39;SHIFT&#39;;
    } else if (indexOf.call(LOGIC, value) &gt;= 0 || value === &#39;?&#39; &amp;&amp; (prev != null ? prev.spaced : void 0)) {
      tag = &#39;LOGIC&#39;;
    } else if (prev &amp;&amp; !prev.spaced) {
      if (value === &#39;(&#39; &amp;&amp; (ref5 = prev[0], indexOf.call(CALLABLE, ref5) &gt;= 0)) {
        if (prev[0] === &#39;?&#39;) {
          prev[0] = &#39;FUNC_EXIST&#39;;
        }
        tag = &#39;CALL_START&#39;;
      } else if (value === &#39;[&#39; &amp;&amp; (ref6 = prev[0], indexOf.call(INDEXABLE, ref6) &gt;= 0)) {
        tag = &#39;INDEX_START&#39;;
        switch (prev[0]) {
          case &#39;?&#39;:
            prev[0] = &#39;INDEX_SOAK&#39;;
        }
      }
    }
    token = this.makeToken(tag, value);
    switch (value) {
      case &#39;(&#39;:
      case &#39;{&#39;:
      case &#39;[&#39;:
        this.ends.push({
          tag: INVERSES[value],
          origin: token
        });
        break;
      case &#39;)&#39;:
      case &#39;}&#39;:
      case &#39;]&#39;:
        this.pair(value);
    }
    this.tokens.push(token);
    return value.length;
  };

  Lexer.prototype.tagParameters = function() {
    var i, stack, tok, tokens;
    if (this.tag() !== &#39;)&#39;) {
      return this;
    }
    stack = [];
    tokens = this.tokens;
    i = tokens.length;
    tokens[--i][0] = &#39;PARAM_END&#39;;
    while (tok = tokens[--i]) {
      switch (tok[0]) {
        case &#39;)&#39;:
          stack.push(tok);
          break;
        case &#39;(&#39;:
        case &#39;CALL_START&#39;:
          if (stack.length) {
            stack.pop();
          } else if (tok[0] === &#39;(&#39;) {
            tok[0] = &#39;PARAM_START&#39;;
            return this;
          } else {
            return this;
          }
      }
    }
    return this;
  };

  Lexer.prototype.closeIndentation = function() {
    return this.outdentToken(this.indent);
  };

  Lexer.prototype.matchWithInterpolations = function(regex, delimiter) {
    var close, column, firstToken, index, lastToken, line, nested, offsetInChunk, open, ref2, ref3, ref4, str, strPart, tokens;
    tokens = [];
    offsetInChunk = delimiter.length;
    if (this.chunk.slice(0, offsetInChunk) !== delimiter) {
      return null;
    }
    str = this.chunk.slice(offsetInChunk);
    while (true) {
      strPart = regex.exec(str)[0];
      this.validateEscapes(strPart, {
        isRegex: delimiter.charAt(0) === &#39;/&#39;,
        offsetInChunk: offsetInChunk
      });
      tokens.push(this.makeToken(&#39;NEOSTRING&#39;, strPart, offsetInChunk));
      str = str.slice(strPart.length);
      offsetInChunk += strPart.length;
      if (str.slice(0, 2) !== &#39;#{&#39;) {
        break;
      }
      ref2 = this.getLineAndColumnFromChunk(offsetInChunk + 1), line = ref2[0], column = ref2[1];
      ref3 = new Lexer().tokenize(str.slice(1), {
        line: line,
        column: column,
        untilBalanced: true
      }), nested = ref3.tokens, index = ref3.index;
      index += 1;
      open = nested[0], close = nested[nested.length - 1];
      open[0] = open[1] = &#39;(&#39;;
      close[0] = close[1] = &#39;)&#39;;
      close.origin = [&#39;&#39;, &#39;end of interpolation&#39;, close[2]];
      if (((ref4 = nested[1]) != null ? ref4[0] : void 0) === &#39;TERMINATOR&#39;) {
        nested.splice(1, 1);
      }
      tokens.push([&#39;TOKENS&#39;, nested]);
      str = str.slice(index);
      offsetInChunk += index;
    }
    if (str.slice(0, delimiter.length) !== delimiter) {
      this.error(&quot;missing &quot; + delimiter, {
        length: delimiter.length
      });
    }
    firstToken = tokens[0], lastToken = tokens[tokens.length - 1];
    firstToken[2].first_column -= delimiter.length;
    lastToken[2].last_column += delimiter.length;
    if (lastToken[1].length === 0) {
      lastToken[2].last_column -= 1;
    }
    return {
      tokens: tokens,
      index: offsetInChunk + delimiter.length
    };
  };

  Lexer.prototype.mergeInterpolationTokens = function(tokens, options, fn) {
    var converted, firstEmptyStringIndex, firstIndex, i, j, lastToken, len, locationToken, lparen, plusToken, ref2, rparen, tag, token, tokensToPush, value;
    if (tokens.length &gt; 1) {
      lparen = this.token(&#39;STRING_START&#39;, &#39;(&#39;, 0, 0);
    }
    firstIndex = this.tokens.length;
    for (i = j = 0, len = tokens.length; j &lt; len; i = ++j) {
      token = tokens[i];
      tag = token[0], value = token[1];
      switch (tag) {
        case &#39;TOKENS&#39;:
          if (value.length === 2) {
            continue;
          }
          locationToken = value[0];
          tokensToPush = value;
          break;
        case &#39;NEOSTRING&#39;:
          converted = fn(token[1], i);
          if (converted.length === 0) {
            if (i === 0) {
              firstEmptyStringIndex = this.tokens.length;
            } else {
              continue;
            }
          }
          if (i === 2 &amp;&amp; (firstEmptyStringIndex != null)) {
            this.tokens.splice(firstEmptyStringIndex, 2);
          }
          token[0] = &#39;STRING&#39;;
          token[1] = this.makeDelimitedLiteral(converted, options);
          locationToken = token;
          tokensToPush = [token];
      }
      if (this.tokens.length &gt; firstIndex) {
        plusToken = this.token(&#39;+&#39;, &#39;+&#39;);
        plusToken[2] = {
          first_line: locationToken[2].first_line,
          first_column: locationToken[2].first_column,
          last_line: locationToken[2].first_line,
          last_column: locationToken[2].first_column
        };
      }
      (ref2 = this.tokens).push.apply(ref2, tokensToPush);
    }
    if (lparen) {
      lastToken = tokens[tokens.length - 1];
      lparen.origin = [
        &#39;STRING&#39;, null, {
          first_line: lparen[2].first_line,
          first_column: lparen[2].first_column,
          last_line: lastToken[2].last_line,
          last_column: lastToken[2].last_column
        }
      ];
      rparen = this.token(&#39;STRING_END&#39;, &#39;)&#39;);
      return rparen[2] = {
        first_line: lastToken[2].last_line,
        first_column: lastToken[2].last_column,
        last_line: lastToken[2].last_line,
        last_column: lastToken[2].last_column
      };
    }
  };

  Lexer.prototype.pair = function(tag) {
    var lastIndent, prev, ref2, ref3, wanted;
    ref2 = this.ends, prev = ref2[ref2.length - 1];
    if (tag !== (wanted = prev != null ? prev.tag : void 0)) {
      if (&#39;OUTDENT&#39; !== wanted) {
        this.error(&quot;unmatched &quot; + tag);
      }
      ref3 = this.indents, lastIndent = ref3[ref3.length - 1];
      this.outdentToken(lastIndent, true);
      return this.pair(tag);
    }
    return this.ends.pop();
  };

  Lexer.prototype.getLineAndColumnFromChunk = function(offset) {
    var column, lastLine, lineCount, ref2, string;
    if (offset === 0) {
      return [this.chunkLine, this.chunkColumn];
    }
    if (offset &gt;= this.chunk.length) {
      string = this.chunk;
    } else {
      string = this.chunk.slice(0, +(offset - 1) + 1 || 9e9);
    }
    lineCount = count(string, &#39;\n&#39;);
    column = this.chunkColumn;
    if (lineCount &gt; 0) {
      ref2 = string.split(&#39;\n&#39;), lastLine = ref2[ref2.length - 1];
      column = lastLine.length;
    } else {
      column += string.length;
    }
    return [this.chunkLine + lineCount, column];
  };

  Lexer.prototype.makeToken = function(tag, value, offsetInChunk, length) {
    var lastCharacter, locationData, ref2, ref3, token;
    if (offsetInChunk == null) {
      offsetInChunk = 0;
    }
    if (length == null) {
      length = value.length;
    }
    locationData = {};
    ref2 = this.getLineAndColumnFromChunk(offsetInChunk), locationData.first_line = ref2[0], locationData.first_column = ref2[1];
    lastCharacter = Math.max(0, length - 1);
    ref3 = this.getLineAndColumnFromChunk(offsetInChunk + lastCharacter), locationData.last_line = ref3[0], locationData.last_column = ref3[1];
    token = [tag, value, locationData];
    return token;
  };

  Lexer.prototype.token = function(tag, value, offsetInChunk, length, origin) {
    var token;
    token = this.makeToken(tag, value, offsetInChunk, length);
    if (origin) {
      token.origin = origin;
    }
    this.tokens.push(token);
    return token;
  };

  Lexer.prototype.tag = function() {
    var ref2, token;
    ref2 = this.tokens, token = ref2[ref2.length - 1];
    return token != null ? token[0] : void 0;
  };

  Lexer.prototype.value = function() {
    var ref2, token;
    ref2 = this.tokens, token = ref2[ref2.length - 1];
    return token != null ? token[1] : void 0;
  };

  Lexer.prototype.unfinished = function() {
    var ref2;
    return LINE_CONTINUER.test(this.chunk) || ((ref2 = this.tag()) === &#39;\\&#39; || ref2 === &#39;.&#39; || ref2 === &#39;?.&#39; || ref2 === &#39;?::&#39; || ref2 === &#39;UNARY&#39; || ref2 === &#39;MATH&#39; || ref2 === &#39;UNARY_MATH&#39; || ref2 === &#39;+&#39; || ref2 === &#39;-&#39; || ref2 === &#39;YIELD&#39; || ref2 === &#39;**&#39; || ref2 === &#39;SHIFT&#39; || ref2 === &#39;RELATION&#39; || ref2 === &#39;COMPARE&#39; || ref2 === &#39;LOGIC&#39; || ref2 === &#39;THROW&#39; || ref2 === &#39;EXTENDS&#39;);
  };

  Lexer.prototype.formatString = function(str) {
    return str.replace(STRING_OMIT, &#39;$1&#39;);
  };

  Lexer.prototype.formatHeregex = function(str) {
    return str.replace(HEREGEX_OMIT, &#39;$1$2&#39;);
  };

  Lexer.prototype.validateEscapes = function(str, options) {
    var before, hex, invalidEscape, match, message, octal, ref2, unicode;
    if (options == null) {
      options = {};
    }
    match = INVALID_ESCAPE.exec(str);
    if (!match) {
      return;
    }
    match[0], before = match[1], octal = match[2], hex = match[3], unicode = match[4];
    if (options.isRegex &amp;&amp; octal &amp;&amp; octal.charAt(0) !== &#39;0&#39;) {
      return;
    }
    message = octal ? &quot;octal escape sequences are not allowed&quot; : &quot;invalid escape sequence&quot;;
    invalidEscape = &quot;\\&quot; + (octal || hex || unicode);
    return this.error(message + &quot; &quot; + invalidEscape, {
      offset: ((ref2 = options.offsetInChunk) != null ? ref2 : 0) + match.index + before.length,
      length: invalidEscape.length
    });
  };

  Lexer.prototype.makeDelimitedLiteral = function(body, options) {
    var regex;
    if (options == null) {
      options = {};
    }
    if (body === &#39;&#39; &amp;&amp; options.delimiter === &#39;/&#39;) {
      body = &#39;(?:)&#39;;
    }
    regex = RegExp(&quot;(\\\\\\\\)|(\\\\0(?=[1-7]))|\\\\?(&quot; + options.delimiter + &quot;)|\\\\?(?:(\\n)|(\\r)|(\\u2028)|(\\u2029))|(\\\\.)&quot;, &quot;g&quot;);
    body = body.replace(regex, function(match, backslash, nul, delimiter, lf, cr, ls, ps, other) {
      switch (false) {
        case !backslash:
          if (options.double) {
            return backslash + backslash;
          } else {
            return backslash;
          }
        case !nul:
          return &#39;\\x00&#39;;
        case !delimiter:
          return &quot;\\&quot; + delimiter;
        case !lf:
          return &#39;\\n&#39;;
        case !cr:
          return &#39;\\r&#39;;
        case !ls:
          return &#39;\\u2028&#39;;
        case !ps:
          return &#39;\\u2029&#39;;
        case !other:
          if (options.double) {
            return &quot;\\&quot; + other;
          } else {
            return other;
          }
      }
    });
    return &quot;&quot; + options.delimiter + body + options.delimiter;
  };

  Lexer.prototype.error = function(message, options) {
    var first_column, first_line, location, ref2, ref3, ref4;
    if (options == null) {
      options = {};
    }
    location = &#39;first_line&#39; in options ? options : ((ref3 = this.getLineAndColumnFromChunk((ref2 = options.offset) != null ? ref2 : 0), first_line = ref3[0], first_column = ref3[1], ref3), {
      first_line: first_line,
      first_column: first_column,
      last_column: first_column + ((ref4 = options.length) != null ? ref4 : 1) - 1
    });
    return throwSyntaxError(message, location);
  };

  return Lexer;

})();

JS_KEYWORDS = [&#39;true&#39;, &#39;false&#39;, &#39;null&#39;, &#39;this&#39;, &#39;new&#39;, &#39;delete&#39;, &#39;typeof&#39;, &#39;in&#39;, &#39;instanceof&#39;, &#39;return&#39;, &#39;throw&#39;, &#39;break&#39;, &#39;continue&#39;, &#39;debugger&#39;, &#39;yield&#39;, &#39;if&#39;, &#39;else&#39;, &#39;switch&#39;, &#39;for&#39;, &#39;while&#39;, &#39;do&#39;, &#39;try&#39;, &#39;catch&#39;, &#39;finally&#39;, &#39;class&#39;, &#39;extends&#39;, &#39;super&#39;];

COFFEE_KEYWORDS = [&#39;undefined&#39;, &#39;then&#39;, &#39;unless&#39;, &#39;until&#39;, &#39;loop&#39;, &#39;of&#39;, &#39;by&#39;, &#39;when&#39;];

COFFEE_ALIAS_MAP = {
  and: &#39;&amp;&amp;&#39;,
  or: &#39;||&#39;,
  is: &#39;==&#39;,
  isnt: &#39;!=&#39;,
  not: &#39;!&#39;,
  yes: &#39;true&#39;,
  no: &#39;false&#39;,
  on: &#39;true&#39;,
  off: &#39;false&#39;
};

COFFEE_ALIASES = (function() {
  var results;
  results = [];
  for (key in COFFEE_ALIAS_MAP) {
    results.push(key);
  }
  return results;
})();

COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(COFFEE_ALIASES);

RESERVED = [&#39;case&#39;, &#39;default&#39;, &#39;function&#39;, &#39;var&#39;, &#39;void&#39;, &#39;with&#39;, &#39;const&#39;, &#39;let&#39;, &#39;enum&#39;, &#39;export&#39;, &#39;import&#39;, &#39;native&#39;, &#39;implements&#39;, &#39;interface&#39;, &#39;package&#39;, &#39;private&#39;, &#39;protected&#39;, &#39;public&#39;, &#39;static&#39;];

STRICT_PROSCRIBED = [&#39;arguments&#39;, &#39;eval&#39;, &#39;yield*&#39;];

JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED);

exports.RESERVED = RESERVED.concat(JS_KEYWORDS).concat(COFFEE_KEYWORDS).concat(STRICT_PROSCRIBED);

exports.STRICT_PROSCRIBED = STRICT_PROSCRIBED;

BOM = 65279;

IDENTIFIER = /^(?!\d)((?:(?!\s)[$\w\x7f-\uffff])+)([^\n\S]*:(?!:))?/;

NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;

OPERATOR = /^(?:[-=]&gt;|[-+*\/%&lt;&gt;&amp;|^!?=]=|&gt;&gt;&gt;=?|([-+:])\1|([&amp;|&lt;&gt;*\/%])\2=?|\?(\.|::)|\.{2,3})/;

WHITESPACE = /^[^\n\S]+/;

COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|###$)|^(?:\s*#(?!##[^#]).*)+/;

CODE = /^[-=]&gt;/;

MULTI_DENT = /^(?:\n[^\n\S]*)+/;

JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;

STRING_START = /^(?:&#39;&#39;&#39;|&quot;&quot;&quot;|&#39;|&quot;)/;

STRING_SINGLE = /^(?:[^\\&#39;]|\\[\s\S])  ;

STRING_DOUBLE = /^(?:[^\\&quot;#]|\\[\s\S]|\#(?!\{))*/;

HEREDOC_SINGLE = /^(?:[^\\&#39;]|\\[\s\S]|&#39;(?!&#39;&#39;))*/;

HEREDOC_DOUBLE = /^(?:[^\\&quot;#]|\\[\s\S]|&quot;(?!&quot;&quot;)|\#(?!\{))*/;

STRING_OMIT = /((?:\\\\)+)|\\[^\S\n]*\n\s*/g;

SIMPLE_STRING_OMIT = /\s*\n\s*/g;

HEREDOC_INDENT = /\n+([^\n\S]*)(?=\S)/g;

REGEX = /^\/(?!\/)((?:[^[\/\n\\]|\\[^\n]|\[(?:\\[^\n]|[^\]\n\\])*\])*)(\/)?/;

REGEX_FLAGS = /^\w*/;

VALID_FLAGS = /^(?!.*(.).*\1)[imgy]*$/;

HEREGEX = /^(?:[^\\\/#]|\\[\s\S]|\/(?!\/\/)|\#(?!\{))*/;

HEREGEX_OMIT = /((?:\\\\)+)|\\(\s)|\s+(?:#.*)?/g;

REGEX_ILLEGAL = /^(\/|\/{3}\s*)(\*)/;

POSSIBLY_DIVISION = /^\/=?\s/;

HERECOMMENT_ILLEGAL = /\*\//;

LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;

INVALID_ESCAPE = /((?:^|[^\\])(?:\\\\)*)\\(?:(0[0-7]|[1-7])|(x(?![\da-fA-F]{2}).{0,2})|(u(?![\da-fA-F]{4}).{0,4}))/;

LEADING_BLANK_LINE = /^[^\n\S]*\n/;

TRAILING_BLANK_LINE = /\n[^\n\S]*$/;

TRAILING_SPACES = /\s+$/;

COMPOUND_ASSIGN = [&#39;-=&#39;, &#39;+=&#39;, &#39;/=&#39;, &#39;*=&#39;, &#39;%=&#39;, &#39;||=&#39;, &#39;&amp;&amp;=&#39;, &#39;?=&#39;, &#39;&lt;&lt;=&#39;, &#39;&gt;&gt;=&#39;, &#39;&gt;&gt;&gt;=&#39;, &#39;&amp;=&#39;, &#39;^=&#39;, &#39;|=&#39;, &#39;**=&#39;, &#39;//=&#39;, &#39;%%=&#39;];

UNARY = [&#39;NEW&#39;, &#39;TYPEOF&#39;, &#39;DELETE&#39;, &#39;DO&#39;];

UNARY_MATH = [&#39;!&#39;, &#39;~&#39;];

LOGIC = [&#39;&amp;&amp;&#39;, &#39;||&#39;, &#39;&amp;&#39;, &#39;|&#39;, &#39;^&#39;];

SHIFT = [&#39;&lt;&lt;&#39;, &#39;&gt;&gt;&#39;, &#39;&gt;&gt;&gt;&#39;];

COMPARE = [&#39;==&#39;, &#39;!=&#39;, &#39;&lt;&#39;, &#39;&gt;&#39;, &#39;&lt;=&#39;, &#39;&gt;=&#39;];

MATH = [&#39;*&#39;, &#39;/&#39;, &#39;%&#39;, &#39;//&#39;, &#39;%%&#39;];

RELATION = [&#39;IN&#39;, &#39;OF&#39;, &#39;INSTANCEOF&#39;];

BOOL = [&#39;TRUE&#39;, &#39;FALSE&#39;];

CALLABLE = [&#39;IDENTIFIER&#39;, &#39;)&#39;, &#39;]&#39;, &#39;?&#39;, &#39;@&#39;, &#39;THIS&#39;, &#39;SUPER&#39;];

INDEXABLE = CALLABLE.concat([&#39;NUMBER&#39;, &#39;STRING&#39;, &#39;STRING_END&#39;, &#39;REGEX&#39;, &#39;REGEX_END&#39;, &#39;BOOL&#39;, &#39;NULL&#39;, &#39;UNDEFINED&#39;, &#39;}&#39;, &#39;::&#39;]);

NOT_REGEX = INDEXABLE.concat([&#39;++&#39;, &#39;--&#39;]);

LINE_BREAK = [&#39;INDENT&#39;, &#39;OUTDENT&#39;, &#39;TERMINATOR&#39;];

INDENTABLE_CLOSERS = [&#39;)&#39;, &#39;}&#39;, &#39;]&#39;];</pre>

<p>}).call(this);</p>

<pre>return module.exports;</pre>

<p>})();<a href="http://'./parser'">require</a> = (function() {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">exports</span> = {}, <span class="ruby-identifier">module</span> = {<span class="ruby-identifier">exports</span><span class="ruby-operator">:</span> <span class="ruby-identifier">exports</span>};
   <span class="ruby-identifier">parser</span> <span class="ruby-identifier">generated</span> <span class="ruby-identifier">by</span> <span class="ruby-identifier">jison</span> <span class="ruby-value">0.4</span><span class="ruby-value">.15</span> <span class="ruby-operator">*</span><span class="ruby-regexp">/
</span></pre>

<p>/*</p>

<pre class="ruby"> <span class="ruby-constant">Returns</span> <span class="ruby-identifier">a</span> <span class="ruby-constant">Parser</span> <span class="ruby-identifier">object</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">following</span> <span class="ruby-identifier">structure</span><span class="ruby-operator">:</span>

 <span class="ruby-constant">Parser</span><span class="ruby-operator">:</span> {
   <span class="ruby-identifier">yy</span><span class="ruby-operator">:</span> {}
 }

 <span class="ruby-constant">Parser</span>.<span class="ruby-identifier">prototype</span><span class="ruby-operator">:</span> {
   <span class="ruby-identifier">yy</span><span class="ruby-operator">:</span> {},
   <span class="ruby-identifier">trace</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(),
   <span class="ruby-identifier">symbols_</span><span class="ruby-operator">:</span> {<span class="ruby-identifier">associative</span> <span class="ruby-identifier">list</span><span class="ruby-operator">:</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">==</span><span class="ruby-operator">&gt;</span> <span class="ruby-identifier">number</span>},
   <span class="ruby-identifier">terminals_</span><span class="ruby-operator">:</span> {<span class="ruby-identifier">associative</span> <span class="ruby-identifier">list</span><span class="ruby-operator">:</span> <span class="ruby-identifier">number</span> <span class="ruby-operator">==</span><span class="ruby-operator">&gt;</span> <span class="ruby-identifier">name</span>},
   <span class="ruby-identifier">productions_</span><span class="ruby-operator">:</span> [<span class="ruby-operator">...</span>],
   <span class="ruby-identifier">performAction</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span> <span class="ruby-identifier">anonymous</span>(<span class="ruby-identifier">yytext</span>, <span class="ruby-identifier">yyleng</span>, <span class="ruby-identifier">yylineno</span>, <span class="ruby-identifier">yy</span>, <span class="ruby-identifier">yystate</span>, <span class="ruby-identifier">$$</span>, <span class="ruby-identifier">_</span>$),
   <span class="ruby-identifier">table</span><span class="ruby-operator">:</span> [<span class="ruby-operator">...</span>],
   <span class="ruby-identifier">defaultActions</span><span class="ruby-operator">:</span> {<span class="ruby-operator">...</span>},
   <span class="ruby-identifier">parseError</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">str</span>, <span class="ruby-identifier">hash</span>),
   <span class="ruby-identifier">parse</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">input</span>),

   <span class="ruby-identifier">lexer</span><span class="ruby-operator">:</span> {
       <span class="ruby-constant">EOF</span><span class="ruby-operator">:</span> <span class="ruby-value">1</span>,
       <span class="ruby-identifier">parseError</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">str</span>, <span class="ruby-identifier">hash</span>),
       <span class="ruby-identifier">setInput</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">input</span>),
       <span class="ruby-identifier">input</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(),
       <span class="ruby-identifier">unput</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">str</span>),
       <span class="ruby-identifier">more</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(),
       <span class="ruby-identifier">less</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">n</span>),
       <span class="ruby-identifier">pastInput</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(),
       <span class="ruby-identifier">upcomingInput</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(),
       <span class="ruby-identifier">showPosition</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(),
       <span class="ruby-identifier">test_match</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">regex_match_array</span>, <span class="ruby-identifier">rule_index</span>),
       <span class="ruby-keyword">next</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(),
       <span class="ruby-identifier">lex</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(),
       <span class="ruby-keyword">begin</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">condition</span>),
       <span class="ruby-identifier">popState</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(),
       <span class="ruby-identifier">_currentRules</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(),
       <span class="ruby-identifier">topState</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(),
       <span class="ruby-identifier">pushState</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">condition</span>),

       <span class="ruby-identifier">options</span><span class="ruby-operator">:</span> {
           <span class="ruby-identifier">ranges</span><span class="ruby-operator">:</span> <span class="ruby-identifier">boolean</span>           (<span class="ruby-identifier">optional</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span> <span class="ruby-operator">==</span><span class="ruby-operator">&gt;</span> <span class="ruby-identifier">token</span> <span class="ruby-identifier">location</span> <span class="ruby-identifier">info</span> <span class="ruby-identifier">will</span> <span class="ruby-identifier">include</span> <span class="ruby-identifier">a</span> .<span class="ruby-identifier">range</span>[] <span class="ruby-identifier">member</span>)
           <span class="ruby-identifier">flex</span><span class="ruby-operator">:</span> <span class="ruby-identifier">boolean</span>             (<span class="ruby-identifier">optional</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span> <span class="ruby-operator">==</span><span class="ruby-operator">&gt;</span> <span class="ruby-identifier">flex</span><span class="ruby-operator">-</span><span class="ruby-identifier">like</span> <span class="ruby-identifier">lexing</span> <span class="ruby-identifier">behaviour</span> <span class="ruby-identifier">where</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">rules</span> <span class="ruby-identifier">are</span> <span class="ruby-identifier">tested</span> <span class="ruby-identifier">exhaustively</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">find</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">longest</span> <span class="ruby-identifier">match</span>)
           <span class="ruby-identifier">backtrack_lexer</span><span class="ruby-operator">:</span> <span class="ruby-identifier">boolean</span>  (<span class="ruby-identifier">optional</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span> <span class="ruby-operator">==</span><span class="ruby-operator">&gt;</span> <span class="ruby-identifier">lexer</span> <span class="ruby-identifier">regexes</span> <span class="ruby-identifier">are</span> <span class="ruby-identifier">tested</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">order</span> <span class="ruby-keyword">and</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">each</span> <span class="ruby-identifier">matching</span> <span class="ruby-identifier">regex</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">action</span> <span class="ruby-identifier">code</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">invoked</span>; <span class="ruby-identifier">the</span> <span class="ruby-identifier">lexer</span> <span class="ruby-identifier">terminates</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">scan</span> <span class="ruby-keyword">when</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">token</span> <span class="ruby-identifier">is</span> <span class="ruby-identifier">returned</span> <span class="ruby-identifier">by</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">action</span> <span class="ruby-identifier">code</span>)
       },

       <span class="ruby-identifier">performAction</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">yy</span>, <span class="ruby-identifier">yy_</span>, <span class="ruby-identifier">$avoiding_name_collisions</span>, <span class="ruby-constant">YY_START</span>),
       <span class="ruby-identifier">rules</span><span class="ruby-operator">:</span> [<span class="ruby-operator">...</span>],
       <span class="ruby-identifier">conditions</span><span class="ruby-operator">:</span> {<span class="ruby-identifier">associative</span> <span class="ruby-identifier">list</span><span class="ruby-operator">:</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">==</span><span class="ruby-operator">&gt;</span> <span class="ruby-identifier">set</span>},
   }
 }

 <span class="ruby-identifier">token</span> <span class="ruby-identifier">location</span> <span class="ruby-identifier">info</span> (@<span class="ruby-identifier">$,</span> <span class="ruby-identifier">_</span><span class="ruby-identifier">$,</span> <span class="ruby-identifier">etc</span>.)<span class="ruby-operator">:</span> {
   <span class="ruby-identifier">first_line</span><span class="ruby-operator">:</span> <span class="ruby-identifier">n</span>,
   <span class="ruby-identifier">last_line</span><span class="ruby-operator">:</span> <span class="ruby-identifier">n</span>,
   <span class="ruby-identifier">first_column</span><span class="ruby-operator">:</span> <span class="ruby-identifier">n</span>,
   <span class="ruby-identifier">last_column</span><span class="ruby-operator">:</span> <span class="ruby-identifier">n</span>,
   <span class="ruby-identifier">range</span><span class="ruby-operator">:</span> [<span class="ruby-identifier">start_number</span>, <span class="ruby-identifier">end_number</span>]       (<span class="ruby-identifier">where</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">numbers</span> <span class="ruby-identifier">are</span> <span class="ruby-identifier">indexes</span> <span class="ruby-identifier">into</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">input</span> <span class="ruby-identifier">string</span>, <span class="ruby-identifier">regular</span> <span class="ruby-identifier">zero</span><span class="ruby-operator">-</span><span class="ruby-identifier">based</span>)
 }

 <span class="ruby-identifier">the</span> <span class="ruby-identifier">parseError</span> <span class="ruby-identifier">function</span> <span class="ruby-identifier">receives</span> <span class="ruby-identifier">a</span> <span class="ruby-string">&#39;hash&#39;</span> <span class="ruby-identifier">object</span> <span class="ruby-identifier">with</span> <span class="ruby-identifier">these</span> <span class="ruby-identifier">members</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">lexer</span> <span class="ruby-keyword">and</span> <span class="ruby-identifier">parser</span> <span class="ruby-identifier">errors</span><span class="ruby-operator">:</span> {
   <span class="ruby-identifier">text</span><span class="ruby-operator">:</span>        (<span class="ruby-identifier">matched</span> <span class="ruby-identifier">text</span>)
   <span class="ruby-identifier">token</span><span class="ruby-operator">:</span>       (<span class="ruby-identifier">the</span> <span class="ruby-identifier">produced</span> <span class="ruby-identifier">terminal</span> <span class="ruby-identifier">token</span>, <span class="ruby-keyword">if</span> <span class="ruby-identifier">any</span>)
   <span class="ruby-identifier">line</span><span class="ruby-operator">:</span>        (<span class="ruby-identifier">yylineno</span>)
 }
 <span class="ruby-keyword">while</span> <span class="ruby-identifier">parser</span> (<span class="ruby-identifier">grammar</span>) <span class="ruby-identifier">errors</span> <span class="ruby-identifier">will</span> <span class="ruby-identifier">also</span> <span class="ruby-identifier">provide</span> <span class="ruby-identifier">these</span> <span class="ruby-identifier">members</span>, <span class="ruby-identifier">i</span>.<span class="ruby-identifier">e</span>. <span class="ruby-identifier">parser</span> <span class="ruby-identifier">errors</span> <span class="ruby-identifier">deliver</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">superset</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">attributes</span><span class="ruby-operator">:</span> {
   <span class="ruby-identifier">loc</span><span class="ruby-operator">:</span>         (<span class="ruby-identifier">yylloc</span>)
   <span class="ruby-identifier">expected</span><span class="ruby-operator">:</span>    (<span class="ruby-identifier">string</span> <span class="ruby-identifier">describing</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">set</span> <span class="ruby-identifier">of</span> <span class="ruby-identifier">expected</span> <span class="ruby-identifier">tokens</span>)
   <span class="ruby-identifier">recoverable</span><span class="ruby-operator">:</span> (<span class="ruby-identifier">boolean</span><span class="ruby-operator">:</span> <span class="ruby-constant">TRUE</span> <span class="ruby-keyword">when</span> <span class="ruby-identifier">the</span> <span class="ruby-identifier">parser</span> <span class="ruby-identifier">has</span> <span class="ruby-identifier">a</span> <span class="ruby-identifier">error</span> <span class="ruby-identifier">recovery</span> <span class="ruby-identifier">rule</span> <span class="ruby-identifier">available</span> <span class="ruby-keyword">for</span> <span class="ruby-identifier">this</span> <span class="ruby-identifier">particular</span> <span class="ruby-identifier">error</span>)
 }
<span class="ruby-regexp">/
</span></pre>

<p>var parser = (function(){ var o=function(k,v,o,l){for(o=o||{},<a
href="http://l">l=k.length;l;o[k</a>]=v);return o},$<a
href="http://1,20">V0=</a>,$<a href="http://1,75">V1=</a>,$<a
href="http://1,71">V2=</a>,$<a href="http://1,76">V3=</a>,$<a
href="http://1,77">V4=</a>,$<a href="http://1,73">V5=</a>,$<a
href="http://1,74">V6=</a>,$<a href="http://1,50">V7=</a>,$<a
href="http://1,52">V8=</a>,$<a href="http://1,53">V9=</a>,$<a
href="http://1,54">Va=</a>,$<a href="http://1,55">Vb=</a>,$<a
href="http://1,45">Vc=</a>,$<a href="http://1,46">Vd=</a>,$<a
href="http://1,27">Ve=</a>,$<a href="http://1,60">Vf=</a>,$<a
href="http://1,61">Vg=</a>,$<a href="http://1,70">Vh=</a>,$<a
href="http://1,43">Vi=</a>,$<a href="http://1,26">Vj=</a>,$<a
href="http://1,58">Vk=</a>,$<a href="http://1,59">Vl=</a>,$<a
href="http://1,57">Vm=</a>,$<a href="http://1,38">Vn=</a>,$<a
href="http://1,44">Vo=</a>,$<a href="http://1,56">Vp=</a>,$<a
href="http://1,65">Vq=</a>,$<a href="http://1,66">Vr=</a>,$<a
href="http://1,67">Vs=</a>,$<a href="http://1,68">Vt=</a>,$<a
href="http://1,42">Vu=</a>,$<a href="http://1,64">Vv=</a>,$<a
href="http://1,29">Vw=</a>,$<a href="http://1,30">Vx=</a>,$<a
href="http://1,31">Vy=</a>,$<a href="http://1,32">Vz=</a>,$<a
href="http://1,33">VA=</a>,$<a href="http://1,34">VB=</a>,$<a
href="http://1,35">VC=</a>,$<a href="http://1,78">VD=</a>,$<a
href="http://1,6,26,34,108">VE=</a>,$<a href="http://1,88">VF=</a>,$<a
href="http://1,81">VG=</a>,$<a href="http://1,80">VH=</a>,$<a
href="http://1,79">VI=</a>,$<a href="http://1,82">VJ=</a>,$<a
href="http://1,83">VK=</a>,$<a href="http://1,84">VL=</a>,$<a
href="http://1,85">VM=</a>,$<a href="http://1,86">VN=</a>,$<a
href="http://1,87">VO=</a>,$<a href="http://1,91">VP=</a>,$<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,110,111,112,116,117,132,135,136,141,142,143,144,145,146,147">VQ=</a>,$<a
href="http://1,97">VR=</a>,$<a href="http://1,98">VS=</a>,$<a
href="http://1,99">VT=</a>,$<a href="http://1,100">VU=</a>,$<a
href="http://1,102">VV=</a>,$<a href="http://1,103">VW=</a>,$<a
href="http://1,96">VX=</a>,$<a href="http://2,112">VY=</a>,$<a
href="http://1,6,25,26,34,55,60,63,72,73,74,75,77,79,80,84,90,91,92,97,99,108,110,111,112,116,117,132,135,136,141,142,143,144,145,146,147">VZ=</a>,$<a
href="http://2,79">V_=</a>,$<a href="http://1,108">V$=</a>,$<a
href="http://2,58">V01=</a>,$<a href="http://1,112">V11=</a>,$<a
href="http://1,117">V21=</a>,$<a href="http://1,118">V31=</a>,$<a
href="http://1,120">V41=</a>,$<a
href="http://1,6,25,26,34,46,55,60,63,72,73,74,75,77,79,80,84,90,91,92,97,99,108,110,111,112,116,117,132,135,136,141,142,143,144,145,146,147">V51=</a>,$<a
href="http://2,76">V61=</a>,$<a
href="http://1,6,26,34,55,60,63,79,84,92,97,99,108,110,111,112,116,117,132,135,136,141,142,143,144,145,146,147">V71=</a>,$<a
href="http://1,155">V81=</a>,$<a href="http://1,157">V91=</a>,$<a
href="http://1,152">Va1=</a>,$<a
href="http://1,6,25,26,34,46,55,60,63,72,73,74,75,77,79,80,84,86,90,91,92,97,99,108,110,111,112,116,117,132,135,136,139,140,141,142,143,144,145,146,147,148">Vb1=</a>,$<a
href="http://2,95">Vc1=</a>,$<a
href="http://1,6,25,26,34,49,55,60,63,72,73,74,75,77,79,80,84,90,91,92,97,99,108,110,111,112,116,117,132,135,136,141,142,143,144,145,146,147">Vd1=</a>,$<a
href="http://1,6,25,26,34,46,49,55,60,63,72,73,74,75,77,79,80,84,86,90,91,92,97,99,108,110,111,112,116,117,123,124,132,135,136,139,140,141,142,143,144,145,146,147,148">Ve1=</a>,$<a
href="http://1,206">Vf1=</a>,$<a href="http://1,205">Vg1=</a>,$<a
href="http://1,6,25,26,34,38,55,60,63,72,73,74,75,77,79,80,84,90,91,92,97,99,108,110,111,112,116,117,132,135,136,141,142,143,144,145,146,147">Vh1=</a>,$<a
href="http://2,56">Vi1=</a>,$<a href="http://1,216">Vj1=</a>,$<a
href="http://6,25,26,55,60">Vk1=</a>,$<a
href="http://6,25,26,46,55,60,63">Vl1=</a>,$<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,110,111,112,116,117,132,135,136,142,144,145,146,147">Vm1=</a>,$<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,110,111,112,116,117,132">Vn1=</a>,$<a
href="http://72,73,74,75,77,80,90,91">Vo1=</a>,$<a
href="http://1,235">Vp1=</a>,$<a href="http://2,133">Vq1=</a>,$<a
href="http://1,6,25,26,34,46,55,60,63,72,73,74,75,77,79,80,84,90,91,92,97,99,108,110,111,112,116,117,123,124,132,135,136,141,142,143,144,145,146,147">Vr1=</a>,$<a
href="http://1,244">Vs1=</a>,$<a
href="http://6,25,26,60,92,97">Vt1=</a>,$<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,117,132">Vu1=</a>,$<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,111,117,132">Vv1=</a>,$<a
href="http://123,124">Vw1=</a>,$<a href="http://60,123,124">Vx1=</a>,$<a
href="http://1,255">Vy1=</a>,$<a href="http://6,25,26,60,84">Vz1=</a>,$<a
href="http://6,25,26,49,60,84">VA1=</a>,$<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,110,111,112,116,117,132,135,136,144,145,146,147">VB1=</a>,$<a
href="http://11,28,30,32,33,36,37,40,41,42,43,44,51,52,53,57,58,79,82,85,89,94,95,96,102,106,107,110,112,114,116,125,131,133,134,135,136,137,139,140">VC1=</a>,$<a
href="http://2,122">VD1=</a>,$<a href="http://6,25,26">VE1=</a>,$<a
href="http://2,57">VF1=</a>,$<a href="http://1,268">VG1=</a>,$<a
href="http://1,269">VH1=</a>,$<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,104,105,108,110,111,112,116,117,127,129,132,135,136,141,142,143,144,145,146,147">VI1=</a>,$<a
href="http://26,127,129">VJ1=</a>,$<a
href="http://1,6,26,34,55,60,63,79,84,92,97,99,108,111,117,132">VK1=</a>,$<a
href="http://2,71">VL1=</a>,$<a href="http://1,291">VM1=</a>,$<a
href="http://1,292">VN1=</a>,$<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,110,111,112,116,117,127,132,135,136,141,142,143,144,145,146,147">VO1=</a>,$<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,110,112,116,117,132">VP1=</a>,$<a
href="http://1,303">VQ1=</a>,$<a href="http://1,304">VR1=</a>,$<a
href="http://6,25,26,60">VS1=</a>,$<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,104,108,110,111,112,116,117,132,135,136,141,142,143,144,145,146,147">VT1=</a>,$<a
href="http://25,60">VU1=</a>; var parser = {trace: function trace() { },
yy: {}, symbols_:
{error:2,Root:3,Body:4,Line:5,TERMINATOR:6,Expression:7,Statement:8,Return:9,Comment:10,STATEMENT:11,Value:12,Invocation:13,Code:14,Operation:15,Assign:16,If:17,Try:18,While:19,For:20,Switch:21,Class:22,Throw:23,Block:24,INDENT:25,OUTDENT:26,Identifier:27,IDENTIFIER:28,AlphaNumeric:29,NUMBER:30,String:31,STRING:32,STRING_START:33,STRING_END:34,Regex:35,REGEX:36,REGEX_START:37,REGEX_END:38,Literal:39,JS:40,DEBUGGER:41,UNDEFINED:42,NULL:43,BOOL:44,Assignable:45,=:46,AssignObj:47,ObjAssignable:48,::49,ThisProperty:50,RETURN:51,HERECOMMENT:52,PARAM_START:53,ParamList:54,PARAM_END:55,FuncGlyph:56,-&gt;:57,=&gt;:58,OptComma:59,,:60,Param:61,ParamVar:62,:63,Array:64,Object:65,Splat:66,SimpleAssignable:67,Accessor:68,Parenthetical:69,Range:70,This:71,.:72,?.:73,:::74,?:::75,Index:76,INDEX_START:77,IndexValue:78,INDEX_END:79,INDEX_SOAK:80,Slice:81,{:82,AssignList:83,}:<a
href="http://":96,"">84,CLASS:85,EXTENDS:86,OptFuncExist:87,Arguments:88,SUPER:89,FUNC_EXIST:90,CALL_START:91,CALL_END:92,ArgList:93,THIS:94,@:95,</a>:97,RangeDots:98,..:99,Arg:100,SimpleArgs:101,TRY:102,Catch:103,FINALLY:104,CATCH:105,THROW:106,(:107,):108,WhileSource:109,WHILE:110,WHEN:111,UNTIL:112,Loop:113,LOOP:114,ForBody:115,FOR:116,BY:117,ForStart:118,ForSource:119,ForVariables:120,OWN:121,ForValue:122,FORIN:123,FOROF:124,SWITCH:125,Whens:126,ELSE:127,When:128,LEADING_WHEN:129,IfBlock:130,IF:131,POST_IF:132,UNARY:133,UNARY_MATH:134,-:135,+:136,YIELD:137,FROM:138,:139,++:140,?:141,MATH:142,**:143,SHIFT:144,COMPARE:145,LOGIC:146,RELATION:147,COMPOUND_ASSIGN:148,$accept:0,$end:1},
terminals_:
{2:error,6:TERMINATOR,11:STATEMENT,25:INDENT,26:OUTDENT,28:IDENTIFIER,30:NUMBER,32:STRING,33:STRING_START,34:STRING_END,36:REGEX,37:REGEX_START,38:REGEX_END,40:JS,41:DEBUGGER,42:UNDEFINED,43:NULL,44:BOOL,46:=,49::,51:RETURN,52:HERECOMMENT,53:PARAM_START,55:PARAM_END,57:-&gt;,58:=&gt;,60:,,63:,72:.,73:?.,74:::,75:?::,77:INDEX_START,79:INDEX_END,80:INDEX_SOAK,82:{,84:},<a
href="http://",97:"">85:CLASS,86:EXTENDS,89:SUPER,90:FUNC_EXIST,91:CALL_START,92:CALL_END,94:THIS,95:@,96:</a>,99:..,102:TRY,104:FINALLY,105:CATCH,106:THROW,107:(,108:),110:WHILE,111:WHEN,112:UNTIL,114:LOOP,116:FOR,117:BY,121:OWN,123:FORIN,124:FOROF,125:SWITCH,127:ELSE,129:LEADING_WHEN,131:IF,132:POST_IF,133:UNARY,134:UNARY_MATH,135:-,136:+,137:YIELD,138:FROM,139:,140:++,141:?,142:MATH,143:**,144:SHIFT,145:COMPARE,146:LOGIC,147:RELATION,148:COMPOUND_ASSIGN},
productions_: [<a href="http://3,0">0,</a>,[<a
href="http://4,1">3,1],</a>,[<a href="http://4,2">4,3],</a>,[<a
href="http://5,1">5,1],</a>,[<a href="http://8,1">8,1],</a>,[<a
href="http://7,1">8,1],</a>,[<a href="http://7,1">7,1],</a>,[<a
href="http://7,1">7,1],</a>,[<a href="http://7,1">7,1],</a>,[<a
href="http://7,1">7,1],</a>,[<a href="http://7,1">7,1],</a>,[<a
href="http://24,2">7,1],</a>,[<a href="http://27,1">24,3],</a>,[<a
href="http://29,1">29,1],</a>,[<a href="http://31,3">31,1],</a>,[<a
href="http://35,3">35,1],</a>,[<a href="http://39,1">39,1],</a>,[<a
href="http://39,1">39,1],</a>,[<a href="http://39,1">39,1],</a>,[<a
href="http://16,3">39,1],</a>,[<a href="http://16,5">16,4],</a>,[<a
href="http://47,3">47,1],</a>,[<a href="http://47,1">47,5],</a>,[<a
href="http://48,1">48,1],</a>,[<a href="http://9,2">48,1],</a>,[<a
href="http://10,1">9,1],</a>,[<a href="http://14,2">14,5],</a>,[<a
href="http://56,1">56,1],</a>,[<a href="http://59,1">59,0],</a>,[<a
href="http://54,1">54,0],</a>,[<a href="http://54,4">54,3],</a>,[<a
href="http://61,1">54,6],</a>,[<a href="http://61,3">61,2],</a>,[<a
href="http://62,1">61,1],</a>,[<a href="http://62,1">62,1],</a>,[<a
href="http://66,2">62,1],</a>,[<a href="http://67,2">67,1],</a>,[<a
href="http://67,1">67,2],</a>,[<a href="http://45,1">45,1],</a>,[<a
href="http://12,1">45,1],</a>,[<a href="http://12,1">12,1],</a>,[<a
href="http://12,1">12,1],</a>,[<a href="http://68,2">68,2],</a>,[<a
href="http://68,2">68,2],</a>,[<a href="http://68,1">68,1],</a>,[<a
href="http://76,2">76,3],</a>,[<a href="http://78,1">78,1],</a>,[<a
href="http://83,0">65,4],</a>,[<a href="http://83,3">83,1],</a>,[<a
href="http://83,6">83,4],</a>,[<a href="http://22,2">22,1],</a>,[<a
href="http://22,4">22,3],</a>,[<a href="http://22,3">22,2],</a>,[<a
href="http://22,5">22,4],</a>,[<a href="http://13,3">13,3],</a>,[<a
href="http://13,2">13,1],</a>,[<a href="http://87,1">87,0],</a>,[<a
href="http://88,4">88,2],</a>,[<a href="http://71,1">71,1],</a>,[<a
href="http://64,2">50,2],</a>,[<a href="http://98,1">64,4],</a>,[<a
href="http://70,5">98,1],</a>,[<a href="http://81,2">81,3],</a>,[<a
href="http://81,1">81,2],</a>,[<a href="http://93,3">93,1],</a>,[<a
href="http://93,4">93,4],</a>,[<a href="http://100,1">93,6],</a>,[<a
href="http://100,1">100,1],</a>,[<a href="http://101,3">101,1],</a>,[<a
href="http://18,3">18,2],</a>,[<a href="http://18,5">18,4],</a>,[<a
href="http://103,3">103,3],</a>,[<a href="http://23,2">103,2],</a>,[<a
href="http://69,5">69,3],</a>,[<a href="http://109,4">109,2],</a>,[<a
href="http://109,4">109,2],</a>,[<a href="http://19,2">19,2],</a>,[<a
href="http://19,1">19,2],</a>,[<a href="http://113,2">113,2],</a>,[<a
href="http://20,2">20,2],</a>,[<a href="http://115,2">20,2],</a>,[<a
href="http://115,2">115,4],</a>,[<a href="http://118,3">118,2],</a>,[<a
href="http://122,1">122,1],</a>,[<a href="http://122,1">122,1],</a>,[<a
href="http://120,3">120,1],</a>,[<a href="http://119,2">119,2],</a>,[<a
href="http://119,4">119,4],</a>,[<a href="http://119,6">119,4],</a>,[<a
href="http://21,5">119,6],</a>,[<a href="http://21,4">21,7],</a>,[<a
href="http://126,1">21,6],</a>,[<a href="http://128,3">126,2],</a>,[<a
href="http://130,3">128,4],</a>,[<a href="http://17,1">130,5],</a>,[<a
href="http://17,3">17,3],</a>,[<a href="http://15,2">17,3],</a>,[<a
href="http://15,2">15,2],</a>,[<a href="http://15,2">15,2],</a>,[<a
href="http://15,3">15,2],</a>,[<a href="http://15,2">15,2],</a>,[<a
href="http://15,2">15,2],</a>,[<a href="http://15,3">15,2],</a>,[<a
href="http://15,3">15,3],</a>,[<a href="http://15,3">15,3],</a>,[<a
href="http://15,3">15,3],</a>,[<a href="http://15,3">15,3],</a>,[<a
href="http://15,4">15,5],</a>,[15,3]], performAction: function
anonymous(yytext, yyleng, yylineno, yy, yystate /* <a
href="http://1">action</a> */, $$ /* vstack */, _$ /* lstack */) { /* this
== yyval */</p>

<p>var $0 = $$.length - 1; switch (yystate) { case 1: return this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Block); break; case 2: return this.$ =
$$[$0]; break; case 3: this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(<a href="http://$0">yy.Block.wrap([$$</a>]));
break; case 4: this.$ = <a href="http://$0-2">yy.addLocationDataFn(_$</a>,
<a href="http://$0">_$</a>)($$[$<a href="http://$0">0-2].push($$</a>));
break; case 5: this.$ = $$[$0-1]; break; case 6: case 7: case 8: case 9:
case 11: case 12: case 13: case 14: case 15: case 16: case 17: case 18:
case 19: case 20: case 21: case 22: case 27: case 32: case 34: case 45:
case 46: case 47: case 48: case 56: case 57: case 67: case 68: case 69:
case 70: case 75: case 76: case 79: case 83: case 89: case 133: case 134:
case 136: case 166: case 167: case 183: case 189: this.$ = $$[$0]; break;
case 10: case 25: case 26: case 28: case 30: case 33: case 35: this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0">yy.Literal($$</a>));
break; case 23: this.$ = <a href="http://$0-1">yy.addLocationDataFn(_$</a>,
<a href="http://$0">_$</a>)(new yy.Block); break; case 24: case 31: case
90: this.$ = <a href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)($$[$0-1]); break; case 29: case 146: this.$ = <a
href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-1">yy.Parens($$</a>));
break; case 36: this.$ = <a href="http://$0">yy.addLocationDataFn(_$</a>,
<a href="http://$0">_$</a>)(new yy.Undefined); break; case 37: this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Null); break; case 38: this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0">yy.Bool($$</a>)); break;
case 39: this.$ = <a href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-2">yy.Assign($$</a>,
$$[$0])); break; case 40: this.$ = <a
href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-3">yy.Assign($$</a>,
$$[$0])); break; case 41: this.$ = <a
href="http://$0-4">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-4">yy.Assign($$</a>,
$$[$0-1])); break; case 42: case 72: case 77: case 78: case 80: case 81:
case 82: case 168: case 169: this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0">yy.Value($$</a>)); break;
case 43: this.$ = <a href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a
href="http://$0-2">yy.Assign(yy.addLocationDataFn(_$</a>)(new <a
href="http://$0-2">yy.Value($$</a>)), $$[$0], &#39;object&#39;)); break;
case 44: this.$ = <a href="http://$0-4">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a
href="http://$0-4">yy.Assign(yy.addLocationDataFn(_$</a>)(new <a
href="http://$0-4">yy.Value($$</a>)), $$[$0-1], &#39;object&#39;)); break;
case 49: this.$ = <a href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0">yy.Return($$</a>)); break;
case 50: this.$ = <a href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Return); break; case 51: this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0">yy.Comment($$</a>));
break; case 52: this.$ = <a href="http://$0-4">yy.addLocationDataFn(_$</a>,
<a href="http://$0">_$</a>)(new <a href="http://$0-3">yy.Code($$</a>,
$$[$0], $$[$0-1])); break; case 53: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Code([], $$[$0], $$[$0-1])); break; case
54: this.$ = <a href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(&#39;func&#39;); break; case 55: this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(&#39;boundfunc&#39;); break; case 58: case 95:
this.$ = <a href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)([]); break; case 59: case 96: case 128: case 170:
this.$ = <a href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)([$$[$0]]); break; case 60: case 97: case 129:
this.$ = <a href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)($$[$<a href="http://$0">0-2].concat($$</a>));
break; case 61: case 98: case 130: this.$ = <a
href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)($$[$<a href="http://$0">0-3].concat($$</a>));
break; case 62: case 99: case 132: this.$ = <a
href="http://$0-5">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)($$[$<a href="http://$0-2">0-5].concat($$</a>));
break; case 63: this.$ = <a href="http://$0">yy.addLocationDataFn(_$</a>,
<a href="http://$0">_$</a>)(new <a href="http://$0">yy.Param($$</a>));
break; case 64: this.$ = <a href="http://$0-1">yy.addLocationDataFn(_$</a>,
<a href="http://$0">_$</a>)(new <a href="http://$0-1">yy.Param($$</a>,
null, true)); break; case 65: this.$ = <a
href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-2">yy.Param($$</a>,
$$[$0])); break; case 66: case 135: this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Expansion); break; case 71: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-1">yy.Splat($$</a>));
break; case 73: this.$ = <a href="http://$0-1">yy.addLocationDataFn(_$</a>,
<a href="http://$0">_$</a>)($$[$<a href="http://$0">0-1].add($$</a>));
break; case 74: this.$ = <a href="http://$0-1">yy.addLocationDataFn(_$</a>,
<a href="http://$0">_$</a>)(new <a href="http://$0-1">yy.Value($$</a>,
[].<a href="http://$0">concat($$</a>))); break; case 84: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0">yy.Access($$</a>)); break;
case 85: this.$ = <a href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0">yy.Access($$</a>,
&#39;soak&#39;)); break; case 86: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)([<a
href="http://$0-1">yy.addLocationDataFn(_$</a>)(new yy.Access(new
yy.Literal(&#39;prototype&#39;))), <a
href="http://$0">yy.addLocationDataFn(_$</a>)(new <a
href="http://$0">yy.Access($$</a>))]); break; case 87: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)([<a
href="http://$0-1">yy.addLocationDataFn(_$</a>)(new yy.Access(new
yy.Literal(&#39;prototype&#39;), &#39;soak&#39;)), <a
href="http://$0">yy.addLocationDataFn(_$</a>)(new <a
href="http://$0">yy.Access($$</a>))]); break; case 88: this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Access(new
yy.Literal(&#39;prototype&#39;))); break; case 91: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(<a href="http://$0">yy.extend($$</a>, {</p>

<pre>  soak: true
}));</pre>

<p>break; case 92: this.$ = <a href="http://$0">yy.addLocationDataFn(_$</a>,
<a href="http://$0">_$</a>)(new <a href="http://$0">yy.Index($$</a>));
break; case 93: this.$ = <a href="http://$0">yy.addLocationDataFn(_$</a>,
<a href="http://$0">_$</a>)(new <a href="http://$0">yy.Slice($$</a>));
break; case 94: this.$ = <a href="http://$0-3">yy.addLocationDataFn(_$</a>,
<a href="http://$0">_$</a>)(new <a href="http://$0-2">yy.Obj($$</a>,
$$[$0-3].generated)); break; case 100: this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Class); break; case 101: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Class(null, null, $$[$0])); break; case
102: this.$ = <a href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Class(null, $$[$0])); break; case 103:
this.$ = <a href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Class(null, $$[$0-1], $$[$0])); break; case
104: this.$ = <a href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0">yy.Class($$</a>)); break;
case 105: this.$ = <a href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-1">yy.Class($$</a>, null,
$$[$0])); break; case 106: this.$ = <a
href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-2">yy.Class($$</a>,
$$[$0])); break; case 107: this.$ = <a
href="http://$0-4">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-3">yy.Class($$</a>,
$$[$0-1], $$[$0])); break; case 108: case 109: this.$ = <a
href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-2">yy.Call($$</a>, $$[$0],
$$[$0-1])); break; case 110: this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Call(&#39;super&#39;, [new yy.Splat(new
yy.Literal(&#39;arguments&#39;))])); break; case 111: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Call(&#39;super&#39;, $$[$0])); break; case
112: this.$ = <a href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(false); break; case 113: this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(true); break; case 114: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)([]); break; case 115: case 131: this.$ = <a
href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)($$[$0-2]); break; case 116: case 117: this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Value(new yy.Literal(&#39;this&#39;)));
break; case 118: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a
href="http://$0-1">yy.Value(yy.addLocationDataFn(_$</a>)(new
yy.Literal(&#39;this&#39;)), [<a
href="http://$0">yy.addLocationDataFn(_$</a>)(new <a
href="http://$0">yy.Access($$</a>))], &#39;this&#39;)); break; case 119:
this.$ = <a href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Arr([])); break; case 120: this.$ = <a
href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-2">yy.Arr($$</a>)); break;
case 121: this.$ = <a href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(&#39;inclusive&#39;); break; case 122: this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(&#39;exclusive&#39;); break; case 123: this.$ = <a
href="http://$0-4">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-3">yy.Range($$</a>,
$$[$0-1], $$[$0-2])); break; case 124: this.$ = <a
href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-2">yy.Range($$</a>, $$[$0],
$$[$0-1])); break; case 125: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-1">yy.Range($$</a>, null,
$$[$0])); break; case 126: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Range(null, $$[$0], $$[$0-1])); break; case
127: this.$ = <a href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Range(null, null, $$[$0])); break; case
137: this.$ = <a href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)([].<a href="http://$0-2">concat($$</a>, $$[$0]));
break; case 138: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0">yy.Try($$</a>)); break;
case 139: this.$ = <a href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-1">yy.Try($$</a>, $$[$<a
href="http://0">0]</a>, $$[$<a href="http://1">0]</a>)); break; case 140:
this.$ = <a href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-2">yy.Try($$</a>, null,
null, $$[$0])); break; case 141: this.$ = <a
href="http://$0-4">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-3">yy.Try($$</a>, $$[$<a
href="http://0">0-2]</a>, $$[$<a href="http://1">0-2]</a>, $$[$0])); break;
case 142: this.$ = <a href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)([$$[$0-1], $$[$0]]); break; case 143: this.$ = <a
href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)([<a
href="http://$0-1">yy.addLocationDataFn(_$</a>)(new <a
href="http://$0-1">yy.Value($$</a>)), $$[$0]]); break; case 144: this.$ =
<a href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)([null, $$[$0]]); break; case 145: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0">yy.Throw($$</a>)); break;
case 147: this.$ = <a href="http://$0-4">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-2">yy.Parens($$</a>));
break; case 148: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0">yy.While($$</a>)); break;
case 149: this.$ = <a href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-2">yy.While($$</a>, {</p>

<pre>  guard: $$[$0]
}));</pre>

<p>break; case 150: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0">yy.While($$</a>, {</p>

<pre>  invert: true
}));</pre>

<p>break; case 151: this.$ = <a
href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-2">yy.While($$</a>, {</p>

<pre>  invert: true,
  guard: $$[$0]
}));</pre>

<p>break; case 152: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)($$[$<a href="http://$0">0-1].addBody($$</a>));
break; case 153: case 154: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)($$[$<a
href="http://$0-1">0].addBody(yy.addLocationDataFn(_$</a>)(<a
href="http://$0-1">yy.Block.wrap([$$</a>])))); break; case 155: this.$ = <a
href="http://$0">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)($$[$0]); break; case 156: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a
href="http://$0-1">yy.While(yy.addLocationDataFn(_$</a>)(new <a
href="http://$0">yy.Literal(true))).addBody($$</a>)); break; case 157:
this.$ = <a href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a
href="http://$0-1">yy.While(yy.addLocationDataFn(_$</a>)(new <a
href="http://$0">yy.Literal(true))).addBody(yy.addLocationDataFn(_$</a>)(<a
href="http://$0">yy.Block.wrap([$$</a>])))); break; case 158: case 159:
this.$ = <a href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-1">yy.For($$</a>, $$[$0]));
break; case 160: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0">yy.For($$</a>, $$[$0-1]));
break; case 161: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)({</p>

<pre>  source: yy.addLocationDataFn(_$[$0])(new yy.Value($$[$0]))
});</pre>

<p>break; case 162: this.$ = <a
href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)({</p>

<pre>  source: yy.addLocationDataFn(_$[$0-2])(new yy.Value($$[$0-2])),
  step: $$[$0]
});</pre>

<p>break; case 163: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)((function () {</p>

<pre>  $$[$0].own = $$[$0-1].own;
  $$[$0].name = $$[$0-1][0];
  $$[$0].index = $$[$0-1][1];
  return $$[$0];
}()));</pre>

<p>break; case 164: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)($$[$0]); break; case 165: this.$ = <a
href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)((function () {</p>

<pre>  $$[$0].own = true;
  return $$[$0];
}()));</pre>

<p>break; case 171: this.$ = <a
href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)([$$[$0-2], $$[$0]]); break; case 172: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)({</p>

<pre>  source: $$[$0]
});</pre>

<p>break; case 173: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)({</p>

<pre>  source: $$[$0],
  object: true
});</pre>

<p>break; case 174: this.$ = <a
href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)({</p>

<pre>  source: $$[$0-2],
  guard: $$[$0]
});</pre>

<p>break; case 175: this.$ = <a
href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)({</p>

<pre>  source: $$[$0-2],
  guard: $$[$0],
  object: true
});</pre>

<p>break; case 176: this.$ = <a
href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)({</p>

<pre>  source: $$[$0-2],
  step: $$[$0]
});</pre>

<p>break; case 177: this.$ = <a
href="http://$0-5">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)({</p>

<pre>  source: $$[$0-4],
  guard: $$[$0-2],
  step: $$[$0]
});</pre>

<p>break; case 178: this.$ = <a
href="http://$0-5">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)({</p>

<pre>  source: $$[$0-4],
  step: $$[$0-2],
  guard: $$[$0]
});</pre>

<p>break; case 179: this.$ = <a
href="http://$0-4">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-3">yy.Switch($$</a>,
$$[$0-1])); break; case 180: this.$ = <a
href="http://$0-6">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-5">yy.Switch($$</a>,
$$[$0-3], $$[$0-1])); break; case 181: this.$ = <a
href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Switch(null, $$[$0-1])); break; case 182:
this.$ = <a href="http://$0-5">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Switch(null, $$[$0-3], $$[$0-1])); break;
case 184: this.$ = <a href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)($$[$<a href="http://$0">0-1].concat($$</a>));
break; case 185: this.$ = <a
href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)([[$$[$0-1], $$[$0]]]); break; case 186: this.$ =
<a href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)([[$$[$0-2], $$[$0-1]]]); break; case 187: this.$ =
<a href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-1">yy.If($$</a>, $$[$0], {</p>

<pre>  type: $$[$0-2]
}));</pre>

<p>break; case 188: this.$ = <a
href="http://$0-4">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)($$[$<a
href="http://$0-2">0-4].addElse(yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-1">yy.If($$</a>, $$[$0], {</p>

<pre>  type: $$[$0-2]
}))));</pre>

<p>break; case 190: this.$ = <a
href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)($$[$<a href="http://$0">0-2].addElse($$</a>));
break; case 191: case 192: this.$ = <a
href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0">yy.If($$</a>, <a
href="http://$0-2">yy.addLocationDataFn(_$</a>)(<a
href="http://$0-2">yy.Block.wrap([$$</a>])), {</p>

<pre>  type: $$[$0-1],
  statement: true
}));</pre>

<p>break; case 193: case 194: case 197: case 198: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-1">yy.Op($$</a>, $$[$0]));
break; case 195: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Op(&#39;-&#39;, $$[$0])); break; case 196:
this.$ = <a href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Op(&#39;+&#39;, $$[$0])); break; case 199:
this.$ = <a href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-2">yy.Op($$</a>.<a
href="http://$0-1">concat($$</a>), $$[$0])); break; case 200: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Op(&#39;&#39;, $$[$0])); break; case 201:
this.$ = <a href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Op(&#39;++&#39;, $$[$0])); break; case 202:
this.$ = <a href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Op(&#39;&#39;, $$[$0-1], null, true));
break; case 203: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Op(&#39;++&#39;, $$[$0-1], null, true));
break; case 204: this.$ = <a
href="http://$0-1">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-1">yy.Existence($$</a>));
break; case 205: this.$ = <a
href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Op(&#39;+&#39;, $$[$0-2], $$[$0])); break;
case 206: this.$ = <a href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new yy.Op(&#39;-&#39;, $$[$0-2], $$[$0])); break;
case 207: case 208: case 209: case 210: case 211: this.$ = <a
href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-1">yy.Op($$</a>, $$[$0-2],
$$[$0])); break; case 212: this.$ = <a
href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)((function () {</p>

<pre>  if ($$[$0-1].charAt(0) === &#39;!&#39;) {
    return new yy.Op($$[$0-1].slice(1), $$[$0-2], $$[$0]).invert();
  } else {
    return new yy.Op($$[$0-1], $$[$0-2], $$[$0]);
  }
}()));</pre>

<p>break; case 213: this.$ = <a
href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-2">yy.Assign($$</a>,
$$[$0], $$[$0-1])); break; case 214: this.$ = <a
href="http://$0-4">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-4">yy.Assign($$</a>,
$$[$0-1], $$[$0-3])); break; case 215: this.$ = <a
href="http://$0-3">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-3">yy.Assign($$</a>,
$$[$0], $$[$0-2])); break; case 216: this.$ = <a
href="http://$0-2">yy.addLocationDataFn(_$</a>, <a
href="http://$0">_$</a>)(new <a href="http://$0-2">yy.Extends($$</a>,
$$[$0])); break; } }, table: [{<a
href="http://2,1">1:</a>,3:1,4:2,5:3,7:4,8:5,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{<a
href="http://3">1:</a>},{<a href="http://2,2">1:</a>,6:$VD},<a
href="http://2,3">o($VE,</a>),<a
href="http://2,6">o($VE,</a>,{118:69,109:89,115:90,110:$Vq,112:$Vr,116:$Vt,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,7">o($VE,</a>,{118:69,109:92,115:93,110:$Vq,112:$Vr,116:$Vt,132:$VP}),<a
href="http://2,11">o($VQ,</a>,{87:94,68:95,76:101,72:$VR,73:$VS,74:$VT,75:$VU,77:$VV,80:$VW,90:$VX,91:$VY}),<a
href="http://2,12">o($VQ,</a>,{76:101,87:104,68:105,72:$VR,73:$VS,74:$VT,75:$VU,77:$VV,80:$VW,90:$VX,91:$VY}),<a
href="http://2,13">o($VQ,</a>),<a href="http://2,14">o($VQ,</a>),<a
href="http://2,15">o($VQ,</a>),<a href="http://2,16">o($VQ,</a>),<a
href="http://2,17">o($VQ,</a>),<a href="http://2,18">o($VQ,</a>),<a
href="http://2,19">o($VQ,</a>),<a href="http://2,20">o($VQ,</a>),<a
href="http://2,21">o($VQ,</a>),<a href="http://2,22">o($VQ,</a>),<a
href="http://2,8">o($VQ,</a>),<a href="http://2,9">o($VQ,</a>),<a
href="http://2,10">o($VQ,</a>),o($VZ,$V_,{<a
href="http://1,106">46:</a>}),<a href="http://2,80">o($VZ,</a>),<a
href="http://2,81">o($VZ,</a>),<a href="http://2,82">o($VZ,</a>),<a
href="http://2,83">o($VZ,</a>),<a
href="http://1,6,25,26,34,38,55,60,63,72,73,74,75,77,79,80,84,90,92,97,99,108,110,111,112,116,117,132,135,136,141,142,143,144,145,146,147">o(</a>,[2,110],{88:107,91:$V$}),<a
href="http://6,25,55,60">o(</a>,$V01,{54:109,61:110,62:111,27:113,50:114,64:115,65:116,28:$V1,63:$V11,82:$Vh,95:$V21,96:$V31}),{24:119,25:$V41},{7:121,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:123,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:124,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:125,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{<a
href="http://1,128">7:127,8:126,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,138:</a>,139:$VB,140:$VC},{12:130,13:131,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:132,50:63,64:47,65:48,67:129,69:23,70:24,71:25,82:$Vh,89:$Vj,94:$Vk,95:$Vl,96:$Vm,107:$Vp},{12:130,13:131,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:132,50:63,64:47,65:48,67:133,69:23,70:24,71:25,82:$Vh,89:$Vj,94:$Vk,95:$Vl,96:$Vm,107:$Vp},o($V51,$V61,{<a
href="http://1,137">86:</a>,<a href="http://1,134">139:</a>,<a
href="http://1,135">140:</a>,<a href="http://1,136">148:</a>}),<a
href="http://2,189">o($VQ,</a>,{<a
href="http://1,138">127:</a>}),{24:139,25:$V41},{24:140,25:$V41},<a
href="http://2,155">o($VQ,</a>),{24:141,25:$V41},{<a
href="http://1,143">7:142,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:</a>,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,100">o($V71,</a>,{<a
href="http://1,145">39:22,69:23,70:24,71:25,64:47,65:48,29:49,35:51,27:62,50:63,31:72,12:130,13:131,45:132,24:144,67:146,25:$V41,28:$V1,30:$V2,32:$V3,33:$V4,36:$V5,37:$V6,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,82:$Vh,86:</a>,89:$Vj,94:$Vk,95:$Vl,96:$Vm,107:$Vp}),{7:147,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,110,111,112,116,117,132,141,142,143,144,145,146,147">o(</a>,[2,50],{12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,9:18,10:19,45:21,39:22,69:23,70:24,71:25,56:28,67:36,130:37,109:39,113:40,115:41,64:47,65:48,29:49,35:51,27:62,50:63,118:69,31:72,8:122,7:148,11:$V0,28:$V1,30:$V2,32:$V3,33:$V4,36:$V5,37:$V6,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,51:$Vc,52:$Vd,53:$Ve,57:$Vf,58:$Vg,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,114:$Vs,125:$Vu,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC}),<a
href="http://2,51">o($VQ,</a>),<a href="http://2,77">o($V51,</a>),<a
href="http://2,78">o($V51,</a>),<a href="http://2,32">o($VZ,</a>),<a
href="http://2,33">o($VZ,</a>),<a href="http://2,34">o($VZ,</a>),<a
href="http://2,35">o($VZ,</a>),<a href="http://2,36">o($VZ,</a>),<a
href="http://2,37">o($VZ,</a>),<a href="http://2,38">o($VZ,</a>),{<a
href="http://1,150">4:149,5:3,7:4,8:5,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:</a>,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:151,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:$V81,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,63:$V91,64:47,65:48,66:156,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,93:153,94:$Vk,95:$Vl,96:$Vm,97:$Va1,100:154,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,116">o($VZ,</a>),<a
href="http://2,117">o($VZ,</a>,{27:158,28:$V1}),{<a
href="http://2,54">25:</a>},{<a href="http://2,55">25:</a>},<a
href="http://2,72">o($Vb1,</a>),<a
href="http://2,75">o($Vb1,</a>),{7:159,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:160,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:161,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:163,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,24:162,25:$V41,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{<a
href="http://1,166">27:168,28:$V1,50:169,64:170,65:171,70:164,82:$Vh,95:$V21,96:$Vm,120:165,121:</a>,122:167},{<a
href="http://1,173">119:172,123:</a>,<a href="http://1,174">124:</a>},<a
href="http://6,25,60,84">o(</a>,$Vc1,{31:72,83:175,47:176,48:177,10:178,27:179,29:180,50:181,28:$V1,30:$V2,32:$V3,33:$V4,52:$Vd,95:$V21}),<a
href="http://2,26">o($Vd1,</a>),<a href="http://2,27">o($Vd1,</a>),<a
href="http://2,30">o($VZ,</a>),{12:130,13:182,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:132,50:63,64:47,65:48,67:183,69:23,70:24,71:25,82:$Vh,89:$Vj,94:$Vk,95:$Vl,96:$Vm,107:$Vp},<a
href="http://2,25">o($Ve1,</a>),<a
href="http://2,28">o($Vd1,</a>),{4:184,5:3,7:4,8:5,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,5">o($VE,</a>,{7:4,8:5,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,9:18,10:19,45:21,39:22,69:23,70:24,71:25,56:28,67:36,130:37,109:39,113:40,115:41,64:47,65:48,29:49,35:51,27:62,50:63,118:69,31:72,5:185,11:$V0,28:$V1,30:$V2,32:$V3,33:$V4,36:$V5,37:$V6,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,51:$Vc,52:$Vd,53:$Ve,57:$Vf,58:$Vg,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,110:$Vq,112:$Vr,114:$Vs,116:$Vt,125:$Vu,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC}),<a
href="http://2,204">o($VQ,</a>),{7:186,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:187,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:188,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:189,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:190,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:191,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:192,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:193,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:194,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,154">o($VQ,</a>),<a
href="http://2,159">o($VQ,</a>),{7:195,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,153">o($VQ,</a>),<a
href="http://2,158">o($VQ,</a>),{88:196,91:$V$},<a
href="http://2,73">o($Vb1,</a>),{<a
href="http://2,113">91:</a>},{27:197,28:$V1},{27:198,28:$V1},<a
href="http://2,88">o($Vb1,</a>,{27:199,28:$V1}),{27:200,28:$V1},<a
href="http://2,89">o($Vb1,</a>),{7:202,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,63:$Vf1,64:47,65:48,67:36,69:23,70:24,71:25,78:201,81:203,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,98:204,99:$Vg1,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{76:207,77:$VV,80:$VW},{88:208,91:$V$},<a
href="http://2,74">o($Vb1,</a>),{<a href="http://1,210">6:</a>,<a
href="http://1,211">7:209,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:</a>,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,111">o($Vh1,</a>),{<a
href="http://1,212">7:214,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:$V81,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,63:$V91,64:47,65:48,66:156,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,92:</a>,93:213,94:$Vk,95:$Vl,96:$Vm,100:154,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://6,25">o(</a>,$Vi1,{<a
href="http://1,215">59:217,55:</a>,60:$Vj1}),<a
href="http://2,59">o($Vk1,</a>),<a href="http://2,63">o($Vk1,</a>,{<a
href="http://1,219">46:</a>,<a href="http://1,218">63:</a>}),<a
href="http://2,66">o($Vk1,</a>),<a href="http://2,67">o($Vl1,</a>),<a
href="http://2,68">o($Vl1,</a>),<a href="http://2,69">o($Vl1,</a>),<a
href="http://2,70">o($Vl1,</a>),{27:158,28:$V1},{7:214,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:$V81,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,63:$V91,64:47,65:48,66:156,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,93:153,94:$Vk,95:$Vl,96:$Vm,97:$Va1,100:154,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,53">o($VQ,</a>),{<a
href="http://1,220">4:221,5:3,7:4,8:5,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,26:</a>,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,110,111,112,116,117,132,135,136,142,143,144,145,146,147">o(</a>,[2,193],{118:69,109:89,115:90,141:$VI}),{109:92,110:$Vq,112:$Vr,115:93,116:$Vt,118:69,132:$VP},<a
href="http://2,194">o($Vm1,</a>,{118:69,109:89,115:90,141:$VI,143:$VK}),<a
href="http://2,195">o($Vm1,</a>,{118:69,109:89,115:90,141:$VI,143:$VK}),<a
href="http://2,196">o($Vm1,</a>,{118:69,109:89,115:90,141:$VI,143:$VK}),<a
href="http://2,197">o($VQ,</a>,{118:69,109:92,115:93}),<a
href="http://2,198">o($Vn1,</a>,{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),{7:222,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,200">o($VQ,</a>,{72:$V61,73:$V61,74:$V61,75:$V61,77:$V61,80:$V61,90:$V61,91:$V61}),{68:95,72:$VR,73:$VS,74:$VT,75:$VU,76:101,77:$VV,80:$VW,87:94,90:$VX,91:$VY},{68:105,72:$VR,73:$VS,74:$VT,75:$VU,76:101,77:$VV,80:$VW,87:104,90:$VX,91:$VY},<a
href="http://2,201">o($Vo1,$V_),o($VQ,</a>,{72:$V61,73:$V61,74:$V61,75:$V61,77:$V61,80:$V61,90:$V61,91:$V61}),<a
href="http://2,202">o($VQ,</a>),<a href="http://2,203">o($VQ,</a>),{<a
href="http://1,225">6:</a>,<a
href="http://1,224">7:223,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:</a>,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:226,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{<a
href="http://1,228">24:227,25:$V41,131:</a>},<a
href="http://2,138">o($VQ,</a>,{<a href="http://1,230">103:229,104:</a>,<a
href="http://1,231">105:</a>}),<a href="http://2,152">o($VQ,</a>),<a
href="http://2,160">o($VQ,</a>),{<a
href="http://1,232">25:</a>,109:89,110:$Vq,112:$Vr,115:90,116:$Vt,118:69,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO},{126:233,128:234,129:$Vp1},<a
href="http://2,101">o($VQ,</a>),{7:236,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,104">o($V71,</a>,{<a
href="http://1,238">24:237,25:$V41,72:$V61,73:$V61,74:$V61,75:$V61,77:$V61,80:$V61,90:$V61,91:$V61,86:</a>}),<a
href="http://2,145">o($Vn1,</a>,{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,49">o($Vn1,</a>,{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),{<a
href="http://1,239">6:$VD,108:</a>},{4:240,5:3,7:4,8:5,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://6,25,60,97">o(</a>,$Vq1,{<a
href="http://1,242">118:69,109:89,115:90,98:241,63:</a>,99:$Vg1,110:$Vq,112:$Vr,116:$Vt,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,119">o($Vr1,</a>),<a
href="http://6,25,97">o(</a>,$Vi1,{59:243,60:$Vs1}),<a
href="http://2,128">o($Vt1,</a>),{7:214,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:$V81,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,63:$V91,64:47,65:48,66:156,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,93:245,94:$Vk,95:$Vl,96:$Vm,100:154,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,134">o($Vt1,</a>),<a href="http://2,135">o($Vt1,</a>),<a
href="http://2,118">o($Ve1,</a>),{24:246,25:$V41,109:89,110:$Vq,112:$Vr,115:90,116:$Vt,118:69,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO},<a
href="http://2,148">o($Vu1,</a>,{<a
href="http://1,247">118:69,109:89,115:90,110:$Vq,111:</a>,112:$Vr,116:$Vt,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,150">o($Vu1,</a>,{<a
href="http://1,248">118:69,109:89,115:90,110:$Vq,111:</a>,112:$Vr,116:$Vt,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,156">o($VQ,</a>),<a
href="http://2,157">o($Vv1,</a>,{118:69,109:89,115:90,110:$Vq,112:$Vr,116:$Vt,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,110,111,112,116,132,135,136,141,142,143,144,145,146,147">o(</a>,[2,161],{<a
href="http://1,249">117:</a>}),<a
href="http://2,164">o($Vw1,</a>),{27:168,28:$V1,50:169,64:170,65:171,82:$Vh,95:$V21,96:$V31,120:250,122:167},<a
href="http://2,170">o($Vw1,</a>,{<a href="http://1,251">60:</a>}),<a
href="http://2,166">o($Vx1,</a>),<a href="http://2,167">o($Vx1,</a>),<a
href="http://2,168">o($Vx1,</a>),<a href="http://2,169">o($Vx1,</a>),<a
href="http://2,163">o($VQ,</a>),{7:252,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:253,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://6,25,84">o(</a>,$Vi1,{59:254,60:$Vy1}),<a
href="http://2,96">o($Vz1,</a>),<a href="http://2,42">o($Vz1,</a>,{<a
href="http://1,256">49:</a>}),<a href="http://2,45">o($Vz1,</a>),<a
href="http://2,46">o($VA1,</a>),<a href="http://2,47">o($VA1,</a>),<a
href="http://2,48">o($VA1,</a>),{<a
href="http://1,257">38:</a>,68:105,72:$VR,73:$VS,74:$VT,75:$VU,76:101,77:$VV,80:$VW,87:104,90:$VX,91:$VY},o($Vo1,$V61),{<a
href="http://1,258">6:$VD,34:</a>},<a href="http://2,4">o($VE,</a>),<a
href="http://2,205">o($VB1,</a>,{118:69,109:89,115:90,141:$VI,142:$VJ,143:$VK}),<a
href="http://2,206">o($VB1,</a>,{118:69,109:89,115:90,141:$VI,142:$VJ,143:$VK}),<a
href="http://2,207">o($Vm1,</a>,{118:69,109:89,115:90,141:$VI,143:$VK}),<a
href="http://2,208">o($Vm1,</a>,{118:69,109:89,115:90,141:$VI,143:$VK}),<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,110,111,112,116,117,132,144,145,146,147">o(</a>,[2,209],{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK}),<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,110,111,112,116,117,132,145,146">o(</a>,[2,210],{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,147:$VO}),<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,110,111,112,116,117,132,146">o(</a>,[2,211],{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,147:$VO}),<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,110,111,112,116,117,132,145,146,147">o(</a>,[2,212],{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL}),<a
href="http://2,192">o($Vv1,</a>,{118:69,109:89,115:90,110:$Vq,112:$Vr,116:$Vt,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,191">o($Vv1,</a>,{118:69,109:89,115:90,110:$Vq,112:$Vr,116:$Vt,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,108">o($Vh1,</a>),<a href="http://2,84">o($Vb1,</a>),<a
href="http://2,85">o($Vb1,</a>),<a href="http://2,86">o($Vb1,</a>),<a
href="http://2,87">o($Vb1,</a>),{<a href="http://1,259">79:</a>},{<a
href="http://2,92">63:$Vf1,79:</a>,98:260,99:$Vg1,109:89,110:$Vq,112:$Vr,115:90,116:$Vt,118:69,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO},{<a
href="http://2,93">79:</a>},{<a
href="http://2,127">7:261,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,79:</a>,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,121">o($VC1,</a>),<a
href="http://2,91">o($VC1,$VD1),o($Vb1,</a>),<a
href="http://2,109">o($Vh1,</a>),<a
href="http://2,39">o($Vn1,</a>,{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),{7:262,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:263,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,114">o($Vh1,</a>),<a
href="http://6,25,92">o(</a>,$Vi1,{59:264,60:$Vs1}),o($Vt1,$Vq1,{<a
href="http://1,265">118:69,109:89,115:90,63:</a>,110:$Vq,112:$Vr,116:$Vt,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),{56:266,57:$Vf,58:$Vg},o($VE1,$VF1,{62:111,27:113,50:114,64:115,65:116,61:267,28:$V1,63:$V11,82:$Vh,95:$V21,96:$V31}),{6:$VG1,25:$VH1},<a
href="http://2,64">o($Vk1,</a>),{7:270,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,23">o($VI1,</a>),{<a href="http://1,271">6:$VD,26:</a>},<a
href="http://2,199">o($Vn1,</a>,{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,213">o($Vn1,</a>,{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),{7:272,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:273,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,216">o($Vn1,</a>,{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,190">o($VQ,</a>),{7:274,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,139">o($VQ,</a>,{<a
href="http://1,275">104:</a>}),{24:276,25:$V41},{24:279,25:$V41,27:277,28:$V1,65:278,82:$Vh},{126:280,128:234,129:$Vp1},{<a
href="http://1,281">26:</a>,<a
href="http://1,282">127:</a>,128:283,129:$Vp1},<a
href="http://2,183">o($VJ1,</a>),{7:285,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,101:284,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,102">o($VK1,</a>,{118:69,109:89,115:90,24:286,25:$V41,110:$Vq,112:$Vr,116:$Vt,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,105">o($VQ,</a>),{7:287,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,146">o($VZ,</a>),{<a
href="http://1,288">6:$VD,26:</a>},{7:289,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://11,28,30,32,33,36,37,40,41,42,43,44,51,52,53,57,58,82,85,89,94,95,96,102,106,107,110,112,114,116,125,131,133,134,135,136,137,139,140">o(</a>,$VD1,{6:$VL1,25:$VL1,60:$VL1,97:$VL1}),{<a
href="http://1,290">6:$VM1,25:$VN1,97:</a>},<a
href="http://6,25,26,92,97">o(</a>,$VF1,{12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,9:18,10:19,45:21,39:22,69:23,70:24,71:25,56:28,67:36,130:37,109:39,113:40,115:41,64:47,65:48,29:49,35:51,27:62,50:63,118:69,31:72,8:122,66:156,7:214,100:293,11:$V0,28:$V1,30:$V2,32:$V3,33:$V4,36:$V5,37:$V6,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,51:$Vc,52:$Vd,53:$Ve,57:$Vf,58:$Vg,63:$V91,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,110:$Vq,112:$Vr,114:$Vs,116:$Vt,125:$Vu,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC}),o($VE1,$Vi1,{59:294,60:$Vs1}),<a
href="http://2,187">o($VO1,</a>),{7:295,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:296,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:297,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,165">o($Vw1,</a>),{27:168,28:$V1,50:169,64:170,65:171,82:$Vh,95:$V21,96:$V31,122:298},<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,110,112,116,132">o(</a>,[2,172],{<a
href="http://1,299">118:69,109:89,115:90,111:</a>,<a
href="http://1,300">117:</a>,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,173">o($VP1,</a>,{<a
href="http://1,301">118:69,109:89,115:90,111:</a>,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),{<a
href="http://1,302">6:$VQ1,25:$VR1,84:</a>},<a
href="http://6,25,26,84">o(</a>,$VF1,{31:72,48:177,10:178,27:179,29:180,50:181,47:305,28:$V1,30:$V2,32:$V3,33:$V4,52:$Vd,95:$V21}),{<a
href="http://1,307">7:306,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:</a>,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,31">o($VZ,</a>),<a href="http://2,29">o($Vd1,</a>),<a
href="http://2,90">o($Vb1,</a>),{<a
href="http://2,125">7:308,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,79:</a>,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{<a
href="http://2,126">79:</a>,109:89,110:$Vq,112:$Vr,115:90,116:$Vt,118:69,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO},<a
href="http://2,40">o($Vn1,</a>,{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),{<a
href="http://1,309">26:</a>,109:89,110:$Vq,112:$Vr,115:90,116:$Vt,118:69,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO},{<a
href="http://1,310">6:$VM1,25:$VN1,92:</a>},o($Vt1,$VL1),{24:311,25:$V41},<a
href="http://2,60">o($Vk1,</a>),{27:113,28:$V1,50:114,61:312,62:111,63:$V11,64:115,65:116,82:$Vh,95:$V21,96:$V31},o($VS1,$V01,{61:110,62:111,27:113,50:114,64:115,65:116,54:313,28:$V1,63:$V11,82:$Vh,95:$V21,96:$V31}),<a
href="http://2,65">o($Vk1,</a>,{118:69,109:89,115:90,110:$Vq,112:$Vr,116:$Vt,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,24">o($VI1,</a>),{<a
href="http://1,314">26:</a>,109:89,110:$Vq,112:$Vr,115:90,116:$Vt,118:69,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO},<a
href="http://2,215">o($Vn1,</a>,{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),{24:315,25:$V41,109:89,110:$Vq,112:$Vr,115:90,116:$Vt,118:69,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO},{24:316,25:$V41},<a
href="http://2,140">o($VQ,</a>),{24:317,25:$V41},{24:318,25:$V41},<a
href="http://2,144">o($VT1,</a>),{<a href="http://1,319">26:</a>,<a
href="http://1,320">127:</a>,128:283,129:$Vp1},<a
href="http://2,181">o($VQ,</a>),{24:321,25:$V41},<a
href="http://2,184">o($VJ1,</a>),{<a
href="http://1,323">24:322,25:$V41,60:</a>},<a
href="http://2,136">o($VU1,</a>,{118:69,109:89,115:90,110:$Vq,112:$Vr,116:$Vt,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,103">o($VQ,</a>),<a
href="http://2,106">o($VK1,</a>,{118:69,109:89,115:90,24:324,25:$V41,110:$Vq,112:$Vr,116:$Vt,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),{<a
href="http://1,325">108:</a>},{<a
href="http://1,326">97:</a>,109:89,110:$Vq,112:$Vr,115:90,116:$Vt,118:69,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO},<a
href="http://2,120">o($Vr1,</a>),{7:214,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,63:$V91,64:47,65:48,66:156,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,100:327,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:214,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,25:$V81,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,63:$V91,64:47,65:48,66:156,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,93:328,94:$Vk,95:$Vl,96:$Vm,100:154,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,129">o($Vt1,</a>),{<a
href="http://1,329">6:$VM1,25:$VN1,26:</a>},<a
href="http://2,149">o($Vv1,</a>,{118:69,109:89,115:90,110:$Vq,112:$Vr,116:$Vt,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,151">o($Vv1,</a>,{118:69,109:89,115:90,110:$Vq,112:$Vr,116:$Vt,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,162">o($Vv1,</a>,{118:69,109:89,115:90,110:$Vq,112:$Vr,116:$Vt,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,171">o($Vw1,</a>),{7:330,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:331,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:332,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,94">o($Vr1,</a>),{10:178,27:179,28:$V1,29:180,30:$V2,31:72,32:$V3,33:$V4,47:333,48:177,50:181,52:$Vd,95:$V21},o($VS1,$Vc1,{31:72,47:176,48:177,10:178,27:179,29:180,50:181,83:334,28:$V1,30:$V2,32:$V3,33:$V4,52:$Vd,95:$V21}),<a
href="http://2,97">o($Vz1,</a>),<a
href="http://2,43">o($Vz1,</a>,{118:69,109:89,115:90,110:$Vq,112:$Vr,116:$Vt,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),{7:335,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{<a
href="http://2,124">79:</a>,109:89,110:$Vq,112:$Vr,115:90,116:$Vt,118:69,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO},<a
href="http://2,41">o($VQ,</a>),<a href="http://2,115">o($Vh1,</a>),<a
href="http://2,52">o($VQ,</a>),<a
href="http://2,61">o($Vk1,</a>),o($VE1,$Vi1,{59:336,60:$Vj1}),<a
href="http://2,214">o($VQ,</a>),<a href="http://2,188">o($VO1,</a>),<a
href="http://2,141">o($VQ,</a>),<a href="http://2,142">o($VT1,</a>),<a
href="http://2,143">o($VT1,</a>),<a
href="http://2,179">o($VQ,</a>),{24:337,25:$V41},{<a
href="http://1,338">26:</a>},<a href="http://2,185">o($VJ1,</a>,{<a
href="http://1,339">6:</a>}),{7:340,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},<a
href="http://2,107">o($VQ,</a>),<a href="http://2,147">o($VZ,</a>),<a
href="http://2,123">o($VZ,</a>),<a
href="http://2,130">o($Vt1,</a>),o($VE1,$Vi1,{59:341,60:$Vs1}),<a
href="http://2,131">o($Vt1,</a>),<a
href="http://1,6,25,26,34,55,60,63,79,84,92,97,99,108,110,111,112,116,132">o(</a>,[2,174],{<a
href="http://1,342">118:69,109:89,115:90,117:</a>,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,176">o($VP1,</a>,{<a
href="http://1,343">118:69,109:89,115:90,111:</a>,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,175">o($Vn1,</a>,{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,98">o($Vz1,</a>),o($VE1,$Vi1,{59:344,60:$Vy1}),{<a
href="http://1,345">26:</a>,109:89,110:$Vq,112:$Vr,115:90,116:$Vt,118:69,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO},{<a
href="http://1,346">6:$VG1,25:$VH1,26:</a>},{<a
href="http://1,347">26:</a>},<a href="http://2,182">o($VQ,</a>),<a
href="http://2,186">o($VJ1,</a>),<a
href="http://2,137">o($VU1,</a>,{118:69,109:89,115:90,110:$Vq,112:$Vr,116:$Vt,132:$VF,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),{<a
href="http://1,348">6:$VM1,25:$VN1,26:</a>},{7:349,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{7:350,8:122,9:18,10:19,11:$V0,12:6,13:7,14:8,15:9,16:10,17:11,18:12,19:13,20:14,21:15,22:16,23:17,27:62,28:$V1,29:49,30:$V2,31:72,32:$V3,33:$V4,35:51,36:$V5,37:$V6,39:22,40:$V7,41:$V8,42:$V9,43:$Va,44:$Vb,45:21,50:63,51:$Vc,52:$Vd,53:$Ve,56:28,57:$Vf,58:$Vg,64:47,65:48,67:36,69:23,70:24,71:25,82:$Vh,85:$Vi,89:$Vj,94:$Vk,95:$Vl,96:$Vm,102:$Vn,106:$Vo,107:$Vp,109:39,110:$Vq,112:$Vr,113:40,114:$Vs,115:41,116:$Vt,118:69,125:$Vu,130:37,131:$Vv,133:$Vw,134:$Vx,135:$Vy,136:$Vz,137:$VA,139:$VB,140:$VC},{<a
href="http://1,351">6:$VQ1,25:$VR1,26:</a>},<a
href="http://2,44">o($Vz1,</a>),<a href="http://2,62">o($Vk1,</a>),<a
href="http://2,180">o($VQ,</a>),<a href="http://2,132">o($Vt1,</a>),<a
href="http://2,177">o($Vn1,</a>,{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,178">o($Vn1,</a>,{118:69,109:89,115:90,135:$VG,136:$VH,141:$VI,142:$VJ,143:$VK,144:$VL,145:$VM,146:$VN,147:$VO}),<a
href="http://2,99">o($Vz1,</a>)], defaultActions: {<a
href="http://2,54">60:</a>,<a href="http://2,55">61:</a>,<a
href="http://2,113">96:</a>,<a href="http://2,93">203:</a>}, parseError:
function parseError(str, hash) {</p>

<pre>if (hash.recoverable) {
    this.trace(str);
} else {
    throw new Error(str);
}</pre>

<p>}, parse: function parse(input) {</p>

<pre>var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = &#39;&#39;, yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
var args = lstack.slice.call(arguments, 1);
var lexer = Object.create(this.lexer);
var sharedState = { yy: {} };
for (var k in this.yy) {
    if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
        sharedState.yy[k] = this.yy[k];
    }
}
lexer.setInput(input, sharedState.yy);
sharedState.yy.lexer = lexer;
sharedState.yy.parser = this;
if (typeof lexer.yylloc == &#39;undefined&#39;) {
    lexer.yylloc = {};
}
var yyloc = lexer.yylloc;
lstack.push(yyloc);
var ranges = lexer.options &amp;&amp; lexer.options.ranges;
if (typeof sharedState.yy.parseError === &#39;function&#39;) {
    this.parseError = sharedState.yy.parseError;
} else {
    this.parseError = Object.getPrototypeOf(this).parseError;
}
function popStack(n) {
    stack.length = stack.length - 2 * n;
    vstack.length = vstack.length - n;
    lstack.length = lstack.length - n;
}
_token_stack:
    function lex() {
        var token;
        token = lexer.lex() || EOF;
        if (typeof token !== &#39;number&#39;) {
            token = self.symbols_[token] || token;
        }
        return token;
    }
var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
while (true) {
    state = stack[stack.length - 1];
    if (this.defaultActions[state]) {
        action = this.defaultActions[state];
    } else {
        if (symbol === null || typeof symbol == &#39;undefined&#39;) {
            symbol = lex();
        }
        action = table[state] &amp;&amp; table[state][symbol];
    }
                if (typeof action === &#39;undefined&#39; || !action.length || !action[0]) {
            var errStr = &#39;&#39;;
            expected = [];
            for (p in table[state]) {
                if (this.terminals_[p] &amp;&amp; p &gt; TERROR) {
                    expected.push(&#39;\&#39;&#39; + this.terminals_[p] + &#39;\&#39;&#39;);
                }
            }
            if (lexer.showPosition) {
                errStr = &#39;Parse error on line &#39; + (yylineno + 1) + &#39;:\n&#39; + lexer.showPosition() + &#39;\nExpecting &#39; + expected.join(&#39;, &#39;) + &#39;, got \&#39;&#39; + (this.terminals_[symbol] || symbol) + &#39;\&#39;&#39;;
            } else {
                errStr = &#39;Parse error on line &#39; + (yylineno + 1) + &#39;: Unexpected &#39; + (symbol == EOF ? &#39;end of input&#39; : &#39;\&#39;&#39; + (this.terminals_[symbol] || symbol) + &#39;\&#39;&#39;);
            }
            this.parseError(errStr, {
                text: lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer.yylineno,
                loc: yyloc,
                expected: expected
            });
        }
    if (action[0] instanceof Array &amp;&amp; action.length &gt; 1) {
        throw new Error(&#39;Parse Error: multiple actions possible at state: &#39; + state + &#39;, token: &#39; + symbol);
    }
    switch (action[0]) {
    case 1:
        stack.push(symbol);
        vstack.push(lexer.yytext);
        lstack.push(lexer.yylloc);
        stack.push(action[1]);
        symbol = null;
        if (!preErrorSymbol) {
            yyleng = lexer.yyleng;
            yytext = lexer.yytext;
            yylineno = lexer.yylineno;
            yyloc = lexer.yylloc;
            if (recovering &gt; 0) {
                recovering--;
            }
        } else {
            symbol = preErrorSymbol;
            preErrorSymbol = null;
        }
        break;
    case 2:
        len = this.productions_[action[1]][1];
        yyval.$ = vstack[vstack.length - len];
        yyval._$ = {
            first_line: lstack[lstack.length - (len || 1)].first_line,
            last_line: lstack[lstack.length - 1].last_line,
            first_column: lstack[lstack.length - (len || 1)].first_column,
            last_column: lstack[lstack.length - 1].last_column
        };
        if (ranges) {
            yyval._$.range = [
                lstack[lstack.length - (len || 1)].range[0],
                lstack[lstack.length - 1].range[1]
            ];
        }
        r = this.performAction.apply(yyval, [
            yytext,
            yyleng,
            yylineno,
            sharedState.yy,
            action[1],
            vstack,
            lstack
        ].concat(args));
        if (typeof r !== &#39;undefined&#39;) {
            return r;
        }
        if (len) {
            stack = stack.slice(0, -1 * len * 2);
            vstack = vstack.slice(0, -1 * len);
            lstack = lstack.slice(0, -1 * len);
        }
        stack.push(this.productions_[action[1]][0]);
        vstack.push(yyval.$);
        lstack.push(yyval._$);
        newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
        stack.push(newState);
        break;
    case 3:
        return true;
    }
}
return true;</pre>

<p>}};</p>

<p>function Parser () {</p>

<pre>this.yy = {};</pre>

<p>} Parser.prototype = parser;parser.Parser = Parser; return new Parser;
})();</p>

<p>if (typeof require !== &#39;undefined&#39; &amp;&amp; typeof exports !==
&#39;undefined&#39;) { exports.parser = parser; exports.Parser =
parser.Parser; exports.parse = function () { return
parser.parse.apply(parser, arguments); }; exports.main = function
commonjsMain(args) {</p>

<pre>if (!args[1]) {
    console.log(&#39;Usage: &#39;+args[0]+&#39; FILE&#39;);
    process.exit(1);
}
var source = require(&#39;fs&#39;).readFileSync(require(&#39;path&#39;).normalize(args[1]), &quot;utf8&quot;);
return exports.parser.parse(source);</pre>

<p>}; if (typeof module !== &#39;undefined&#39; &amp;&amp; require.main ===
module) {</p>

<pre>exports.main(process.argv.slice(1));</pre>

<p>} }</p>

<pre>return module.exports;</pre>

<p>})();<a href="http://'./scope'">require</a> = (function() {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">exports</span> = {}, <span class="ruby-identifier">module</span> = {<span class="ruby-identifier">exports</span><span class="ruby-operator">:</span> <span class="ruby-identifier">exports</span>};
<span class="ruby-regexp">//</span> <span class="ruby-constant">Generated</span> <span class="ruby-identifier">by</span> <span class="ruby-constant">CoffeeScript</span> <span class="ruby-value">1.9</span><span class="ruby-value">.1</span>
</pre>

<p>(function() {</p>

<pre>var Scope,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i &lt; l; i++) { if (i in this &amp;&amp; this[i] === item) return i; } return -1; };

exports.Scope = Scope = (function() {
  function Scope(parent, expressions, method, referencedVars) {
    var ref, ref1;
    this.parent = parent;
    this.expressions = expressions;
    this.method = method;
    this.referencedVars = referencedVars;
    this.variables = [
      {
        name: &#39;arguments&#39;,
        type: &#39;arguments&#39;
      }
    ];
    this.positions = {};
    if (!this.parent) {
      this.utilities = {};
    }
    this.root = (ref = (ref1 = this.parent) != null ? ref1.root : void 0) != null ? ref : this;
  }

  Scope.prototype.add = function(name, type, immediate) {
    if (this.shared &amp;&amp; !immediate) {
      return this.parent.add(name, type, immediate);
    }
    if (Object.prototype.hasOwnProperty.call(this.positions, name)) {
      return this.variables[this.positions[name]].type = type;
    } else {
      return this.positions[name] = this.variables.push({
        name: name,
        type: type
      }) - 1;
    }
  };

  Scope.prototype.namedMethod = function() {
    var ref;
    if (((ref = this.method) != null ? ref.name : void 0) || !this.parent) {
      return this.method;
    }
    return this.parent.namedMethod();
  };

  Scope.prototype.find = function(name) {
    if (this.check(name)) {
      return true;
    }
    this.add(name, &#39;var&#39;);
    return false;
  };

  Scope.prototype.parameter = function(name) {
    if (this.shared &amp;&amp; this.parent.check(name, true)) {
      return;
    }
    return this.add(name, &#39;param&#39;);
  };

  Scope.prototype.check = function(name) {
    var ref;
    return !!(this.type(name) || ((ref = this.parent) != null ? ref.check(name) : void 0));
  };

  Scope.prototype.temporary = function(name, index, single) {
    if (single == null) {
      single = false;
    }
    if (single) {
      return (index + parseInt(name, 36)).toString(36).replace(/\d/g, &#39;a&#39;);
    } else {
      return name + (index || &#39;&#39;);
    }
  };

  Scope.prototype.type = function(name) {
    var i, len, ref, v;
    ref = this.variables;
    for (i = 0, len = ref.length; i &lt; len; i++) {
      v = ref[i];
      if (v.name === name) {
        return v.type;
      }
    }
    return null;
  };

  Scope.prototype.freeVariable = function(name, options) {
    var index, ref, temp;
    if (options == null) {
      options = {};
    }
    index = 0;
    while (true) {
      temp = this.temporary(name, index, options.single);
      if (!(this.check(temp) || indexOf.call(this.root.referencedVars, temp) &gt;= 0)) {
        break;
      }
      index++;
    }
    if ((ref = options.reserve) != null ? ref : true) {
      this.add(temp, &#39;var&#39;, true);
    }
    return temp;
  };

  Scope.prototype.assign = function(name, value) {
    this.add(name, {
      value: value,
      assigned: true
    }, true);
    return this.hasAssignments = true;
  };

  Scope.prototype.hasDeclarations = function() {
    return !!this.declaredVariables().length;
  };

  Scope.prototype.declaredVariables = function() {
    var v;
    return ((function() {
      var i, len, ref, results;
      ref = this.variables;
      results = [];
      for (i = 0, len = ref.length; i &lt; len; i++) {
        v = ref[i];
        if (v.type === &#39;var&#39;) {
          results.push(v.name);
        }
      }
      return results;
    }).call(this)).sort();
  };

  Scope.prototype.assignedVariables = function() {
    var i, len, ref, results, v;
    ref = this.variables;
    results = [];
    for (i = 0, len = ref.length; i &lt; len; i++) {
      v = ref[i];
      if (v.type.assigned) {
        results.push(v.name + &quot; = &quot; + v.type.value);
      }
    }
    return results;
  };

  return Scope;

})();</pre>

<p>}).call(this);</p>

<pre>return module.exports;</pre>

<p>})();<a href="http://'./nodes'">require</a> = (function() {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">exports</span> = {}, <span class="ruby-identifier">module</span> = {<span class="ruby-identifier">exports</span><span class="ruby-operator">:</span> <span class="ruby-identifier">exports</span>};
<span class="ruby-regexp">//</span> <span class="ruby-constant">Generated</span> <span class="ruby-identifier">by</span> <span class="ruby-constant">CoffeeScript</span> <span class="ruby-value">1.9</span><span class="ruby-value">.1</span>
</pre>

<p>(function() {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-constant">Access</span>, <span class="ruby-constant">Arr</span>, <span class="ruby-constant">Assign</span>, <span class="ruby-constant">Base</span>, <span class="ruby-constant">Block</span>, <span class="ruby-constant">Call</span>, <span class="ruby-constant">Class</span>, <span class="ruby-constant">Code</span>, <span class="ruby-constant">CodeFragment</span>, <span class="ruby-constant">Comment</span>, <span class="ruby-constant">Existence</span>, <span class="ruby-constant">Expansion</span>, <span class="ruby-constant">Extends</span>, <span class="ruby-constant">For</span>, <span class="ruby-constant">HEXNUM</span>, <span class="ruby-constant">IDENTIFIER</span>, <span class="ruby-constant">IS_REGEX</span>, <span class="ruby-constant">IS_STRING</span>, <span class="ruby-constant">If</span>, <span class="ruby-constant">In</span>, <span class="ruby-constant">Index</span>, <span class="ruby-constant">LEVEL_ACCESS</span>, <span class="ruby-constant">LEVEL_COND</span>, <span class="ruby-constant">LEVEL_LIST</span>, <span class="ruby-constant">LEVEL_OP</span>, <span class="ruby-constant">LEVEL_PAREN</span>, <span class="ruby-constant">LEVEL_TOP</span>, <span class="ruby-constant">Literal</span>, <span class="ruby-constant">NEGATE</span>, <span class="ruby-constant">NO</span>, <span class="ruby-constant">NUMBER</span>, <span class="ruby-constant">Obj</span>, <span class="ruby-constant">Op</span>, <span class="ruby-constant">Param</span>, <span class="ruby-constant">Parens</span>, <span class="ruby-constant">RESERVED</span>, <span class="ruby-constant">Range</span>, <span class="ruby-constant">Return</span>, <span class="ruby-constant">SIMPLENUM</span>, <span class="ruby-constant">STRICT_PROSCRIBED</span>, <span class="ruby-constant">Scope</span>, <span class="ruby-constant">Slice</span>, <span class="ruby-constant">Splat</span>, <span class="ruby-constant">Switch</span>, <span class="ruby-constant">TAB</span>, <span class="ruby-constant">THIS</span>, <span class="ruby-constant">Throw</span>, <span class="ruby-constant">Try</span>, <span class="ruby-constant">UTILITIES</span>, <span class="ruby-constant">Value</span>, <span class="ruby-constant">While</span>, <span class="ruby-constant">YES</span>, <span class="ruby-identifier">addLocationDataFn</span>, <span class="ruby-identifier">compact</span>, <span class="ruby-identifier">del</span>, <span class="ruby-identifier">ends</span>, <span class="ruby-identifier">extend</span>, <span class="ruby-identifier">flatten</span>, <span class="ruby-identifier">fragmentsToText</span>, <span class="ruby-identifier">isComplexOrAssignable</span>, <span class="ruby-identifier">isLiteralArguments</span>, <span class="ruby-identifier">isLiteralThis</span>, <span class="ruby-identifier">locationDataToString</span>, <span class="ruby-identifier">merge</span>, <span class="ruby-identifier">multident</span>, <span class="ruby-identifier">parseNum</span>, <span class="ruby-identifier">ref1</span>, <span class="ruby-identifier">ref2</span>, <span class="ruby-identifier">some</span>, <span class="ruby-identifier">starts</span>, <span class="ruby-identifier">throwSyntaxError</span>, <span class="ruby-identifier">unfoldSoak</span>, <span class="ruby-identifier">utility</span>,
  <span class="ruby-identifier">extend1</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">child</span>, <span class="ruby-identifier">parent</span>) { <span class="ruby-keyword">for</span> (<span class="ruby-identifier">var</span> <span class="ruby-identifier">key</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">parent</span>) { <span class="ruby-keyword">if</span> (<span class="ruby-identifier">hasProp</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">key</span>)) <span class="ruby-identifier">child</span>[<span class="ruby-identifier">key</span>] = <span class="ruby-identifier">parent</span>[<span class="ruby-identifier">key</span>]; } <span class="ruby-identifier">function</span> <span class="ruby-identifier">ctor</span>() { <span class="ruby-identifier">this</span>.<span class="ruby-identifier">constructor</span> = <span class="ruby-identifier">child</span>; } <span class="ruby-identifier">ctor</span>.<span class="ruby-identifier">prototype</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">prototype</span>; <span class="ruby-identifier">child</span>.<span class="ruby-identifier">prototype</span> = <span class="ruby-identifier">new</span> <span class="ruby-identifier">ctor</span>(); <span class="ruby-identifier">child</span>.<span class="ruby-identifier">__super__</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">prototype</span>; <span class="ruby-keyword">return</span> <span class="ruby-identifier">child</span>; },
  <span class="ruby-identifier">hasProp</span> = {}.<span class="ruby-identifier">hasOwnProperty</span>,
  <span class="ruby-identifier">indexOf</span> = [].<span class="ruby-identifier">indexOf</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">item</span>) { <span class="ruby-keyword">for</span> (<span class="ruby-identifier">var</span> <span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">l</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">l</span>; <span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) { <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">this</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>[<span class="ruby-identifier">i</span>] <span class="ruby-operator">===</span> <span class="ruby-identifier">item</span>) <span class="ruby-keyword">return</span> <span class="ruby-identifier">i</span>; } <span class="ruby-keyword">return</span> <span class="ruby-value">-1</span>; },
  <span class="ruby-identifier">slice</span> = [].<span class="ruby-identifier">slice</span>;

<span class="ruby-constant">Error</span>.<span class="ruby-identifier">stackTraceLimit</span> = <span class="ruby-constant">Infinity</span>;

<span class="ruby-constant">Scope</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&#39;./scope&#39;</span>).<span class="ruby-constant">Scope</span>;

<span class="ruby-identifier">ref1</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&#39;./lexer&#39;</span>), <span class="ruby-constant">RESERVED</span> = <span class="ruby-identifier">ref1</span>.<span class="ruby-constant">RESERVED</span>, <span class="ruby-constant">STRICT_PROSCRIBED</span> = <span class="ruby-identifier">ref1</span>.<span class="ruby-constant">STRICT_PROSCRIBED</span>;

<span class="ruby-identifier">ref2</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&#39;./helpers&#39;</span>), <span class="ruby-identifier">compact</span> = <span class="ruby-identifier">ref2</span>.<span class="ruby-identifier">compact</span>, <span class="ruby-identifier">flatten</span> = <span class="ruby-identifier">ref2</span>.<span class="ruby-identifier">flatten</span>, <span class="ruby-identifier">extend</span> = <span class="ruby-identifier">ref2</span>.<span class="ruby-identifier">extend</span>, <span class="ruby-identifier">merge</span> = <span class="ruby-identifier">ref2</span>.<span class="ruby-identifier">merge</span>, <span class="ruby-identifier">del</span> = <span class="ruby-identifier">ref2</span>.<span class="ruby-identifier">del</span>, <span class="ruby-identifier">starts</span> = <span class="ruby-identifier">ref2</span>.<span class="ruby-identifier">starts</span>, <span class="ruby-identifier">ends</span> = <span class="ruby-identifier">ref2</span>.<span class="ruby-identifier">ends</span>, <span class="ruby-identifier">some</span> = <span class="ruby-identifier">ref2</span>.<span class="ruby-identifier">some</span>, <span class="ruby-identifier">addLocationDataFn</span> = <span class="ruby-identifier">ref2</span>.<span class="ruby-identifier">addLocationDataFn</span>, <span class="ruby-identifier">locationDataToString</span> = <span class="ruby-identifier">ref2</span>.<span class="ruby-identifier">locationDataToString</span>, <span class="ruby-identifier">throwSyntaxError</span> = <span class="ruby-identifier">ref2</span>.<span class="ruby-identifier">throwSyntaxError</span>;

<span class="ruby-identifier">exports</span>.<span class="ruby-identifier">extend</span> = <span class="ruby-identifier">extend</span>;

<span class="ruby-identifier">exports</span>.<span class="ruby-identifier">addLocationDataFn</span> = <span class="ruby-identifier">addLocationDataFn</span>;

<span class="ruby-constant">YES</span> = <span class="ruby-identifier">function</span>() {
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;
};

<span class="ruby-constant">NO</span> = <span class="ruby-identifier">function</span>() {
  <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
};

<span class="ruby-constant">THIS</span> = <span class="ruby-identifier">function</span>() {
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
};

<span class="ruby-constant">NEGATE</span> = <span class="ruby-identifier">function</span>() {
  <span class="ruby-identifier">this</span>.<span class="ruby-identifier">negated</span> = <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">negated</span>;
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
};

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">CodeFragment</span> = <span class="ruby-constant">CodeFragment</span> = (<span class="ruby-identifier">function</span>() {
  <span class="ruby-identifier">function</span> <span class="ruby-constant">CodeFragment</span>(<span class="ruby-identifier">parent</span>, <span class="ruby-identifier">code</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">code</span> = <span class="ruby-string">&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">code</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">locationData</span> = <span class="ruby-identifier">parent</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">locationData</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">type</span> = (<span class="ruby-identifier">parent</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> (<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">parent</span>.<span class="ruby-identifier">constructor</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">||</span> <span class="ruby-string">&#39;unknown&#39;</span>;
  }

  <span class="ruby-constant">CodeFragment</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">toString</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">code</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">locationData</span> <span class="ruby-operator">?</span> <span class="ruby-string">&quot;: &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">locationDataToString</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">locationData</span>) <span class="ruby-operator">:</span> <span class="ruby-string">&#39;&#39;</span>);
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">CodeFragment</span>;

})();

<span class="ruby-identifier">fragmentsToText</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">fragments</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">fragment</span>;
  <span class="ruby-keyword">return</span> ((<span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">results</span>;
    <span class="ruby-identifier">results</span> = [];
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">fragment</span> = <span class="ruby-identifier">fragments</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-identifier">results</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">fragment</span>.<span class="ruby-identifier">code</span>);
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">results</span>;
  })()).<span class="ruby-identifier">join</span>(<span class="ruby-string">&#39;&#39;</span>);
};

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Base</span> = <span class="ruby-constant">Base</span> = (<span class="ruby-identifier">function</span>() {
  <span class="ruby-identifier">function</span> <span class="ruby-constant">Base</span>() {}

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compile</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">lvl</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">lvl</span>));
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileToFragments</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">lvl</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">node</span>;
    <span class="ruby-identifier">o</span> = <span class="ruby-identifier">extend</span>({}, <span class="ruby-identifier">o</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">lvl</span>) {
      <span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> = <span class="ruby-identifier">lvl</span>;
    }
    <span class="ruby-identifier">node</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">unfoldSoak</span>(<span class="ruby-identifier">o</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>;
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">tab</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">indent</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">===</span> <span class="ruby-constant">LEVEL_TOP</span> <span class="ruby-operator">||</span> <span class="ruby-operator">!</span><span class="ruby-identifier">node</span>.<span class="ruby-identifier">isStatement</span>(<span class="ruby-identifier">o</span>)) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">compileNode</span>(<span class="ruby-identifier">o</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">compileClosure</span>(<span class="ruby-identifier">o</span>);
    }
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileClosure</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">args</span>, <span class="ruby-identifier">argumentsNode</span>, <span class="ruby-identifier">func</span>, <span class="ruby-identifier">jumpNode</span>, <span class="ruby-identifier">meth</span>, <span class="ruby-identifier">parts</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">jumpNode</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">jumps</span>()) {
      <span class="ruby-identifier">jumpNode</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&#39;cannot use a pure statement in an expression&#39;</span>);
    }
    <span class="ruby-identifier">o</span>.<span class="ruby-identifier">sharedScope</span> = <span class="ruby-keyword">true</span>;
    <span class="ruby-identifier">func</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Code</span>([], <span class="ruby-constant">Block</span>.<span class="ruby-identifier">wrap</span>([<span class="ruby-identifier">this</span>]));
    <span class="ruby-identifier">args</span> = [];
    <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">argumentsNode</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">contains</span>(<span class="ruby-identifier">isLiteralArguments</span>)) <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">contains</span>(<span class="ruby-identifier">isLiteralThis</span>)) {
      <span class="ruby-identifier">args</span> = [<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&#39;this&#39;</span>)];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">argumentsNode</span>) {
        <span class="ruby-identifier">meth</span> = <span class="ruby-string">&#39;apply&#39;</span>;
        <span class="ruby-identifier">args</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&#39;arguments&#39;</span>));
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">meth</span> = <span class="ruby-string">&#39;call&#39;</span>;
      }
      <span class="ruby-identifier">func</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">func</span>, [<span class="ruby-identifier">new</span> <span class="ruby-constant">Access</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">meth</span>))]);
    }
    <span class="ruby-identifier">parts</span> = (<span class="ruby-identifier">new</span> <span class="ruby-constant">Call</span>(<span class="ruby-identifier">func</span>, <span class="ruby-identifier">args</span>)).<span class="ruby-identifier">compileNode</span>(<span class="ruby-identifier">o</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">func</span>.<span class="ruby-identifier">isGenerator</span> <span class="ruby-operator">||</span> ((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">func</span>.<span class="ruby-identifier">base</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">isGenerator</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>)) {
      <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;(yield* &quot;</span>));
      <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;)&quot;</span>));
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">parts</span>;
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">cache</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">level</span>, <span class="ruby-identifier">isComplex</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">complex</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">sub</span>;
    <span class="ruby-identifier">complex</span> = <span class="ruby-identifier">isComplex</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">isComplex</span>(<span class="ruby-identifier">this</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isComplex</span>();
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">complex</span>) {
      <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;ref&#39;</span>));
      <span class="ruby-identifier">sub</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">ref</span>, <span class="ruby-identifier">this</span>);
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">level</span>) {
        <span class="ruby-keyword">return</span> [<span class="ruby-identifier">sub</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">level</span>), [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">ref</span>.<span class="ruby-identifier">value</span>)]];
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-keyword">return</span> [<span class="ruby-identifier">sub</span>, <span class="ruby-identifier">ref</span>];
      }
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">level</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">level</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">this</span>;
      <span class="ruby-keyword">return</span> [<span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref</span>];
    }
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">cacheToCodeFragments</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">cacheValues</span>) {
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">cacheValues</span>[<span class="ruby-value">0</span>]), <span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">cacheValues</span>[<span class="ruby-value">1</span>])];
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">makeReturn</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">res</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">me</span>;
    <span class="ruby-identifier">me</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">unwrapAll</span>();
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">res</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Call</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">res</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.push&quot;</span>), [<span class="ruby-identifier">me</span>]);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Return</span>(<span class="ruby-identifier">me</span>);
    }
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">contains</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">pred</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">node</span>;
    <span class="ruby-identifier">node</span> = <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">traverseChildren</span>(<span class="ruby-keyword">false</span>, <span class="ruby-identifier">function</span>(<span class="ruby-identifier">n</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">pred</span>(<span class="ruby-identifier">n</span>)) {
        <span class="ruby-identifier">node</span> = <span class="ruby-identifier">n</span>;
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
      }
    });
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>;
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">lastNonComment</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">list</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">i</span>;
    <span class="ruby-identifier">i</span> = <span class="ruby-identifier">list</span>.<span class="ruby-identifier">length</span>;
    <span class="ruby-keyword">while</span> (<span class="ruby-identifier">i</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">list</span>[<span class="ruby-identifier">i</span>] <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Comment</span>)) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">list</span>[<span class="ruby-identifier">i</span>];
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">null</span>;
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">toString</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">idt</span>, <span class="ruby-identifier">name</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">tree</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">idt</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
      <span class="ruby-identifier">idt</span> = <span class="ruby-string">&#39;&#39;</span>;
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
      <span class="ruby-identifier">name</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">constructor</span>.<span class="ruby-identifier">name</span>;
    }
    <span class="ruby-identifier">tree</span> = <span class="ruby-string">&#39;\n&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idt</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">name</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">soak</span>) {
      <span class="ruby-identifier">tree</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&#39;?&#39;</span>;
    }
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">eachChild</span>(<span class="ruby-identifier">function</span>(<span class="ruby-identifier">node</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">tree</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">toString</span>(<span class="ruby-identifier">idt</span> <span class="ruby-operator">+</span> <span class="ruby-constant">TAB</span>);
    });
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">tree</span>;
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">eachChild</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">func</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">attr</span>, <span class="ruby-identifier">child</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">k</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">len2</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">children</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
    }
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">children</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">attr</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>[<span class="ruby-identifier">attr</span>]) {
        <span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">flatten</span>([<span class="ruby-identifier">this</span>[<span class="ruby-identifier">attr</span>]]);
        <span class="ruby-keyword">for</span> (<span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len2</span> = <span class="ruby-identifier">ref4</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">k</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len2</span>; <span class="ruby-identifier">k</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
          <span class="ruby-identifier">child</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-identifier">k</span>];
          <span class="ruby-keyword">if</span> (<span class="ruby-identifier">func</span>(<span class="ruby-identifier">child</span>) <span class="ruby-operator">===</span> <span class="ruby-keyword">false</span>) {
            <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
          }
        }
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">traverseChildren</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">crossScope</span>, <span class="ruby-identifier">func</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">eachChild</span>(<span class="ruby-identifier">function</span>(<span class="ruby-identifier">child</span>) {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">recur</span>;
      <span class="ruby-identifier">recur</span> = <span class="ruby-identifier">func</span>(<span class="ruby-identifier">child</span>);
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">recur</span> <span class="ruby-operator">!=</span>= <span class="ruby-keyword">false</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">traverseChildren</span>(<span class="ruby-identifier">crossScope</span>, <span class="ruby-identifier">func</span>);
      }
    });
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">invert</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Op</span>(<span class="ruby-string">&#39;!&#39;</span>, <span class="ruby-identifier">this</span>);
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">unwrapAll</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">node</span>;
    <span class="ruby-identifier">node</span> = <span class="ruby-identifier">this</span>;
    <span class="ruby-keyword">while</span> (<span class="ruby-identifier">node</span> <span class="ruby-operator">!=</span>= (<span class="ruby-identifier">node</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">unwrap</span>())) {
      <span class="ruby-identifier">continue</span>;
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>;
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [];

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isStatement</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">jumps</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isComplex</span> = <span class="ruby-constant">YES</span>;

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isChainable</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isAssignable</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">unwrap</span> = <span class="ruby-constant">THIS</span>;

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">unfoldSoak</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">assigns</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">updateLocationDataIfMissing</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">locationData</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">locationData</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
    }
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">locationData</span> = <span class="ruby-identifier">locationData</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">eachChild</span>(<span class="ruby-identifier">function</span>(<span class="ruby-identifier">child</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">child</span>.<span class="ruby-identifier">updateLocationDataIfMissing</span>(<span class="ruby-identifier">locationData</span>);
    });
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">error</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">message</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">throwSyntaxError</span>(<span class="ruby-identifier">message</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">locationData</span>);
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">makeCode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">code</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">CodeFragment</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">code</span>);
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">wrapInBraces</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">fragments</span>) {
    <span class="ruby-keyword">return</span> [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39;(&#39;</span>), <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39;)&#39;</span>));
  };

  <span class="ruby-constant">Base</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">joinFragmentArrays</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">fragmentsList</span>, <span class="ruby-identifier">joinStr</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>;
    <span class="ruby-identifier">answer</span> = [];
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">fragmentsList</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">i</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">j</span>) {
      <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">fragmentsList</span>[<span class="ruby-identifier">i</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i</span>) {
        <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">joinStr</span>));
      }
      <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">fragments</span>);
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span>;
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Base</span>;

})();

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Block</span> = <span class="ruby-constant">Block</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Block</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Block</span>(<span class="ruby-identifier">nodes</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span> = <span class="ruby-identifier">compact</span>(<span class="ruby-identifier">flatten</span>(<span class="ruby-identifier">nodes</span> <span class="ruby-operator">||</span> []));
  }

  <span class="ruby-constant">Block</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;expressions&#39;</span>];

  <span class="ruby-constant">Block</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">push</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">node</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">node</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  };

  <span class="ruby-constant">Block</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">pop</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">pop</span>();
  };

  <span class="ruby-constant">Block</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">unshift</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">node</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">node</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  };

  <span class="ruby-constant">Block</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">unwrap</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">===</span> <span class="ruby-value">1</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>[<span class="ruby-value">0</span>];
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
    }
  };

  <span class="ruby-constant">Block</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isEmpty</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">length</span>;
  };

  <span class="ruby-constant">Block</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isStatement</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">exp</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">exp</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">exp</span>.<span class="ruby-identifier">isStatement</span>(<span class="ruby-identifier">o</span>)) {
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
  };

  <span class="ruby-constant">Block</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">jumps</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">exp</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">jumpNode</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">exp</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">jumpNode</span> = <span class="ruby-identifier">exp</span>.<span class="ruby-identifier">jumps</span>(<span class="ruby-identifier">o</span>)) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">jumpNode</span>;
      }
    }
  };

  <span class="ruby-constant">Block</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">makeReturn</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">res</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">expr</span>, <span class="ruby-identifier">len</span>;
    <span class="ruby-identifier">len</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">length</span>;
    <span class="ruby-keyword">while</span> (<span class="ruby-identifier">len</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span>) {
      <span class="ruby-identifier">expr</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>[<span class="ruby-identifier">len</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">expr</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Comment</span>)) {
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>[<span class="ruby-identifier">len</span>] = <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">makeReturn</span>(<span class="ruby-identifier">res</span>);
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">expr</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Return</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">expr</span>.<span class="ruby-identifier">expression</span>) {
          <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">splice</span>(<span class="ruby-identifier">len</span>, <span class="ruby-value">1</span>);
        }
        <span class="ruby-keyword">break</span>;
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  };

  <span class="ruby-constant">Block</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileToFragments</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">level</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
      <span class="ruby-identifier">o</span> = {};
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-constant">Block</span>.<span class="ruby-identifier">__super__</span>.<span class="ruby-identifier">compileToFragments</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">o</span>, <span class="ruby-identifier">level</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileRoot</span>(<span class="ruby-identifier">o</span>);
    }
  };

  <span class="ruby-constant">Block</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">compiledNodes</span>, <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">index</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">top</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">indent</span>;
    <span class="ruby-identifier">top</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">===</span> <span class="ruby-constant">LEVEL_TOP</span>;
    <span class="ruby-identifier">compiledNodes</span> = [];
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">index</span> = <span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">index</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">j</span>) {
      <span class="ruby-identifier">node</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">index</span>];
      <span class="ruby-identifier">node</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">unwrapAll</span>();
      <span class="ruby-identifier">node</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">unfoldSoak</span>(<span class="ruby-identifier">o</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">node</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Block</span>) {
        <span class="ruby-identifier">compiledNodes</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">compileNode</span>(<span class="ruby-identifier">o</span>));
      } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">top</span>) {
        <span class="ruby-identifier">node</span>.<span class="ruby-identifier">front</span> = <span class="ruby-keyword">true</span>;
        <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
        <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">node</span>.<span class="ruby-identifier">isStatement</span>(<span class="ruby-identifier">o</span>)) {
          <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span>));
          <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;;&quot;</span>));
        }
        <span class="ruby-identifier">compiledNodes</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">fragments</span>);
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">compiledNodes</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>));
      }
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">top</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">spaced</span>) {
        <span class="ruby-keyword">return</span> [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">joinFragmentArrays</span>(<span class="ruby-identifier">compiledNodes</span>, <span class="ruby-string">&#39;\n\n&#39;</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span>));
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">joinFragmentArrays</span>(<span class="ruby-identifier">compiledNodes</span>, <span class="ruby-string">&#39;\n&#39;</span>);
      }
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">compiledNodes</span>.<span class="ruby-identifier">length</span>) {
      <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">joinFragmentArrays</span>(<span class="ruby-identifier">compiledNodes</span>, <span class="ruby-string">&#39;, &#39;</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">answer</span> = [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;void 0&quot;</span>)];
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">compiledNodes</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">LEVEL_LIST</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">wrapInBraces</span>(<span class="ruby-identifier">answer</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span>;
    }
  };

  <span class="ruby-constant">Block</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileRoot</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">exp</span>, <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">prelude</span>, <span class="ruby-identifier">preludeExps</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">rest</span>;
    <span class="ruby-identifier">o</span>.<span class="ruby-identifier">indent</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">bare</span> <span class="ruby-operator">?</span> <span class="ruby-string">&#39;&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-constant">TAB</span>;
    <span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> = <span class="ruby-constant">LEVEL_TOP</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">spaced</span> = <span class="ruby-keyword">true</span>;
    <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Scope</span>(<span class="ruby-identifier">null</span>, <span class="ruby-identifier">this</span>, <span class="ruby-identifier">null</span>, (<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">referencedVars</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">:</span> []);
    <span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">locals</span> <span class="ruby-operator">||</span> [];
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref4</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">name</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">parameter</span>(<span class="ruby-identifier">name</span>);
    }
    <span class="ruby-identifier">prelude</span> = [];
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">o</span>.<span class="ruby-identifier">bare</span>) {
      <span class="ruby-identifier">preludeExps</span> = (<span class="ruby-identifier">function</span>() {
        <span class="ruby-identifier">var</span> <span class="ruby-identifier">k</span>, <span class="ruby-identifier">len2</span>, <span class="ruby-identifier">ref5</span>, <span class="ruby-identifier">results</span>;
        <span class="ruby-identifier">ref5</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>;
        <span class="ruby-identifier">results</span> = [];
        <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len2</span> = <span class="ruby-identifier">ref5</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">k</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len2</span>; <span class="ruby-identifier">i</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">k</span>) {
          <span class="ruby-identifier">exp</span> = <span class="ruby-identifier">ref5</span>[<span class="ruby-identifier">i</span>];
          <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">exp</span>.<span class="ruby-identifier">unwrap</span>() <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Comment</span>)) {
            <span class="ruby-keyword">break</span>;
          }
          <span class="ruby-identifier">results</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">exp</span>);
        }
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">results</span>;
      }).<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>);
      <span class="ruby-identifier">rest</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-identifier">preludeExps</span>.<span class="ruby-identifier">length</span>);
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span> = <span class="ruby-identifier">preludeExps</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">preludeExps</span>.<span class="ruby-identifier">length</span>) {
        <span class="ruby-identifier">prelude</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileNode</span>(<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">o</span>, {
          <span class="ruby-identifier">indent</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;&#39;</span>
        }));
        <span class="ruby-identifier">prelude</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span>));
      }
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span> = <span class="ruby-identifier">rest</span>;
    }
    <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileWithDeclarations</span>(<span class="ruby-identifier">o</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">bare</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">fragments</span>;
    }
    <span class="ruby-keyword">return</span> [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">prelude</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;(function() {\n&quot;</span>), <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n}).call(this);\n&quot;</span>));
  };

  <span class="ruby-constant">Block</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileWithDeclarations</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">assigns</span>, <span class="ruby-identifier">declars</span>, <span class="ruby-identifier">exp</span>, <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">post</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">ref5</span>, <span class="ruby-identifier">rest</span>, <span class="ruby-identifier">scope</span>, <span class="ruby-identifier">spaced</span>;
    <span class="ruby-identifier">fragments</span> = [];
    <span class="ruby-identifier">post</span> = [];
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">i</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">j</span>) {
      <span class="ruby-identifier">exp</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">i</span>];
      <span class="ruby-identifier">exp</span> = <span class="ruby-identifier">exp</span>.<span class="ruby-identifier">unwrap</span>();
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">exp</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Comment</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">exp</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Literal</span>)) {
        <span class="ruby-keyword">break</span>;
      }
    }
    <span class="ruby-identifier">o</span> = <span class="ruby-identifier">merge</span>(<span class="ruby-identifier">o</span>, {
      <span class="ruby-identifier">level</span><span class="ruby-operator">:</span> <span class="ruby-constant">LEVEL_TOP</span>
    });
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i</span>) {
      <span class="ruby-identifier">rest</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">splice</span>(<span class="ruby-identifier">i</span>, <span class="ruby-value">9e9</span>);
      <span class="ruby-identifier">ref4</span> = [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">spaced</span>, <span class="ruby-keyword">false</span>], <span class="ruby-identifier">spaced</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">this</span>.<span class="ruby-identifier">spaced</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">1</span>];
      <span class="ruby-identifier">ref5</span> = [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileNode</span>(<span class="ruby-identifier">o</span>), <span class="ruby-identifier">spaced</span>], <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">ref5</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">this</span>.<span class="ruby-identifier">spaced</span> = <span class="ruby-identifier">ref5</span>[<span class="ruby-value">1</span>];
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expressions</span> = <span class="ruby-identifier">rest</span>;
    }
    <span class="ruby-identifier">post</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileNode</span>(<span class="ruby-identifier">o</span>);
    <span class="ruby-identifier">scope</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">expressions</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">this</span>) {
      <span class="ruby-identifier">declars</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">hasDeclarations</span>();
      <span class="ruby-identifier">assigns</span> = <span class="ruby-identifier">scope</span>.<span class="ruby-identifier">hasAssignments</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">declars</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">assigns</span>) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i</span>) {
          <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39;\n&#39;</span>));
        }
        <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;var &quot;</span>));
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">declars</span>) {
          <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">declaredVariables</span>().<span class="ruby-identifier">join</span>(<span class="ruby-string">&#39;, &#39;</span>)));
        }
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">assigns</span>) {
          <span class="ruby-keyword">if</span> (<span class="ruby-identifier">declars</span>) {
            <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;,\n&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-constant">TAB</span>)));
          }
          <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">assignedVariables</span>().<span class="ruby-identifier">join</span>(<span class="ruby-string">&quot;,\n&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-constant">TAB</span>))));
        }
        <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;;\n&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">spaced</span> <span class="ruby-operator">?</span> <span class="ruby-string">&#39;\n&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&#39;&#39;</span>)));
      } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">post</span>.<span class="ruby-identifier">length</span>) {
        <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span>));
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">post</span>);
  };

  <span class="ruby-constant">Block</span>.<span class="ruby-identifier">wrap</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">nodes</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">nodes</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">===</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">nodes</span>[<span class="ruby-value">0</span>] <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Block</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">nodes</span>[<span class="ruby-value">0</span>];
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Block</span>(<span class="ruby-identifier">nodes</span>);
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Block</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Literal</span> = <span class="ruby-constant">Literal</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Literal</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">value1</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span> = <span class="ruby-identifier">value1</span>;
  }

  <span class="ruby-constant">Literal</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">makeReturn</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">isStatement</span>()) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-constant">Literal</span>.<span class="ruby-identifier">__super__</span>.<span class="ruby-identifier">makeReturn</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">arguments</span>);
    }
  };

  <span class="ruby-constant">Literal</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isAssignable</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-constant">IDENTIFIER</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>);
  };

  <span class="ruby-constant">Literal</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isStatement</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref3</span>;
    <span class="ruby-keyword">return</span> (<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;break&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;continue&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;debugger&#39;</span>;
  };

  <span class="ruby-constant">Literal</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isComplex</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Literal</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">assigns</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">name</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>;
  };

  <span class="ruby-constant">Literal</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">jumps</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;break&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>((<span class="ruby-identifier">o</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">loop</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">||</span> (<span class="ruby-identifier">o</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">block</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>))) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;continue&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">o</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">loop</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>)) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
    }
  };

  <span class="ruby-constant">Literal</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">code</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">code</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;this&#39;</span> <span class="ruby-operator">?</span> ((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">method</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">bound</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">method</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">reserved</span> <span class="ruby-operator">?</span> <span class="ruby-string">&quot;\&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\&quot;&quot;</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>;
    <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isStatement</span>() <span class="ruby-operator">?</span> <span class="ruby-string">&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">code</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;;&quot;</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">code</span>;
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">answer</span>)];
  };

  <span class="ruby-constant">Literal</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">toString</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-string">&#39; &quot;&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;&quot;&#39;</span>;
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Literal</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Undefined</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Undefined</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Undefined</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-constant">Undefined</span>.<span class="ruby-identifier">__super__</span>.<span class="ruby-identifier">constructor</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">arguments</span>);
  }

  <span class="ruby-constant">Undefined</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isAssignable</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Undefined</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isComplex</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Undefined</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">LEVEL_ACCESS</span> <span class="ruby-operator">?</span> <span class="ruby-string">&#39;(void 0)&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&#39;void 0&#39;</span>)];
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Undefined</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Null</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Null</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Null</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-constant">Null</span>.<span class="ruby-identifier">__super__</span>.<span class="ruby-identifier">constructor</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">arguments</span>);
  }

  <span class="ruby-constant">Null</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isAssignable</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Null</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isComplex</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Null</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;null&quot;</span>)];
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Null</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Bool</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Bool</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-constant">Bool</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isAssignable</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Bool</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isComplex</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Bool</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">val</span>)];
  };

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Bool</span>(<span class="ruby-identifier">val1</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">val</span> = <span class="ruby-identifier">val1</span>;
  }

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Bool</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Return</span> = <span class="ruby-constant">Return</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Return</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Return</span>(<span class="ruby-identifier">expression</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expression</span> = <span class="ruby-identifier">expression</span>;
  }

  <span class="ruby-constant">Return</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;expression&#39;</span>];

  <span class="ruby-constant">Return</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isStatement</span> = <span class="ruby-constant">YES</span>;

  <span class="ruby-constant">Return</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">makeReturn</span> = <span class="ruby-constant">THIS</span>;

  <span class="ruby-constant">Return</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">jumps</span> = <span class="ruby-constant">THIS</span>;

  <span class="ruby-constant">Return</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileToFragments</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">level</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">expr</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">expr</span> = (<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expression</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">makeReturn</span>() <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">expr</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">expr</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Return</span>)) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">level</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-constant">Return</span>.<span class="ruby-identifier">__super__</span>.<span class="ruby-identifier">compileToFragments</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">o</span>, <span class="ruby-identifier">level</span>);
    }
  };

  <span class="ruby-constant">Return</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">exprIsYieldReturn</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">answer</span> = [];
    <span class="ruby-identifier">exprIsYieldReturn</span> = (<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expression</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">typeof</span> <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">isYieldReturn</span> <span class="ruby-operator">===</span> <span class="ruby-string">&quot;function&quot;</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">isYieldReturn</span>() <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">exprIsYieldReturn</span>) {
      <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> (<span class="ruby-string">&quot;return&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">expression</span> <span class="ruby-operator">?</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&quot;&quot;</span>))));
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">expression</span>) {
      <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">expression</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_PAREN</span>));
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">exprIsYieldReturn</span>) {
      <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;;&quot;</span>));
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span>;
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Return</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Value</span> = <span class="ruby-constant">Value</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Value</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">base</span>, <span class="ruby-identifier">props</span>, <span class="ruby-identifier">tag</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">props</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">base</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">base</span>;
    }
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span> = <span class="ruby-identifier">base</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span> = <span class="ruby-identifier">props</span> <span class="ruby-operator">||</span> [];
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">tag</span>) {
      <span class="ruby-identifier">this</span>[<span class="ruby-identifier">tag</span>] = <span class="ruby-keyword">true</span>;
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  }

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;base&#39;</span>, <span class="ruby-string">&#39;properties&#39;</span>];

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">add</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">props</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">props</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">hasProperties</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">length</span>;
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">bareLiteral</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">type</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-identifier">type</span>;
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isArray</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">bareLiteral</span>(<span class="ruby-constant">Arr</span>);
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isRange</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">bareLiteral</span>(<span class="ruby-constant">Range</span>);
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isComplex</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">hasProperties</span>() <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">isComplex</span>();
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isAssignable</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">hasProperties</span>() <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">isAssignable</span>();
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isSimpleNumber</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">bareLiteral</span>(<span class="ruby-constant">Literal</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">SIMPLENUM</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">value</span>);
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isString</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">bareLiteral</span>(<span class="ruby-constant">Literal</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">IS_STRING</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">value</span>);
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isRegex</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">bareLiteral</span>(<span class="ruby-constant">Literal</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">IS_REGEX</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">value</span>);
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isAtomic</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>);
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">node</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">node</span>.<span class="ruby-identifier">soak</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Call</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isNotCallable</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isSimpleNumber</span>() <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isString</span>() <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isRegex</span>() <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isArray</span>() <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isRange</span>() <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isSplice</span>() <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isObject</span>();
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isStatement</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">isStatement</span>(<span class="ruby-identifier">o</span>);
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">assigns</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">name</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">assigns</span>(<span class="ruby-identifier">name</span>);
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">jumps</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">jumps</span>(<span class="ruby-identifier">o</span>);
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isObject</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">onlyGenerated</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">length</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
    }
    <span class="ruby-keyword">return</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Obj</span>) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">onlyGenerated</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">generated</span>);
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isSplice</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">lastProp</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>, <span class="ruby-identifier">lastProp</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>];
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">lastProp</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Slice</span>;
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">looksStatic</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">className</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref3</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">className</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">===</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> ((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">name</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;prototype&#39;</span>;
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">unwrap</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">length</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>;
    }
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">cacheReference</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">base</span>, <span class="ruby-identifier">bref</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">nref</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>, <span class="ruby-identifier">name</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>];
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&lt;</span> <span class="ruby-value">2</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">isComplex</span>() <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">name</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">isComplex</span>() <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>)) {
      <span class="ruby-keyword">return</span> [<span class="ruby-identifier">this</span>, <span class="ruby-identifier">this</span>];
    }
    <span class="ruby-identifier">base</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">0</span>, <span class="ruby-value">-1</span>));
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">base</span>.<span class="ruby-identifier">isComplex</span>()) {
      <span class="ruby-identifier">bref</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;base&#39;</span>));
      <span class="ruby-identifier">base</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Parens</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">bref</span>, <span class="ruby-identifier">base</span>)));
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">name</span>) {
      <span class="ruby-keyword">return</span> [<span class="ruby-identifier">base</span>, <span class="ruby-identifier">bref</span>];
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">name</span>.<span class="ruby-identifier">isComplex</span>()) {
      <span class="ruby-identifier">nref</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;name&#39;</span>));
      <span class="ruby-identifier">name</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Index</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">nref</span>, <span class="ruby-identifier">name</span>.<span class="ruby-identifier">index</span>));
      <span class="ruby-identifier">nref</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Index</span>(<span class="ruby-identifier">nref</span>);
    }
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">base</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">name</span>), <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">bref</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">base</span>.<span class="ruby-identifier">base</span>, [<span class="ruby-identifier">nref</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">name</span>])];
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">prop</span>, <span class="ruby-identifier">props</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">front</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">front</span>;
    <span class="ruby-identifier">props</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>;
    <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, (<span class="ruby-identifier">props</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">?</span> <span class="ruby-constant">LEVEL_ACCESS</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">null</span>));
    <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">this</span>.<span class="ruby-identifier">base</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Parens</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">length</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">SIMPLENUM</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">fragments</span>))) {
      <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39;.&#39;</span>));
    }
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">props</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">prop</span> = <span class="ruby-identifier">props</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">prop</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>));
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">fragments</span>;
  };

  <span class="ruby-constant">Value</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">unfoldSoak</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">unfoldedSoak</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">unfoldedSoak</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">unfoldedSoak</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">_this</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">function</span>() {
        <span class="ruby-identifier">var</span> <span class="ruby-identifier">fst</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">ifn</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">prop</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">snd</span>;
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">ifn</span> = <span class="ruby-identifier">_this</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">unfoldSoak</span>(<span class="ruby-identifier">o</span>)) {
          (<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">ifn</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">properties</span>).<span class="ruby-identifier">push</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">_this</span>.<span class="ruby-identifier">properties</span>);
          <span class="ruby-keyword">return</span> <span class="ruby-identifier">ifn</span>;
        }
        <span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">_this</span>.<span class="ruby-identifier">properties</span>;
        <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref4</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">i</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">j</span>) {
          <span class="ruby-identifier">prop</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-identifier">i</span>];
          <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">prop</span>.<span class="ruby-identifier">soak</span>) {
            <span class="ruby-identifier">continue</span>;
          }
          <span class="ruby-identifier">prop</span>.<span class="ruby-identifier">soak</span> = <span class="ruby-keyword">false</span>;
          <span class="ruby-identifier">fst</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">_this</span>.<span class="ruby-identifier">base</span>, <span class="ruby-identifier">_this</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">0</span>, <span class="ruby-identifier">i</span>));
          <span class="ruby-identifier">snd</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">_this</span>.<span class="ruby-identifier">base</span>, <span class="ruby-identifier">_this</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-identifier">i</span>));
          <span class="ruby-keyword">if</span> (<span class="ruby-identifier">fst</span>.<span class="ruby-identifier">isComplex</span>()) {
            <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;ref&#39;</span>));
            <span class="ruby-identifier">fst</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Parens</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">ref</span>, <span class="ruby-identifier">fst</span>));
            <span class="ruby-identifier">snd</span>.<span class="ruby-identifier">base</span> = <span class="ruby-identifier">ref</span>;
          }
          <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">If</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Existence</span>(<span class="ruby-identifier">fst</span>), <span class="ruby-identifier">snd</span>, {
            <span class="ruby-identifier">soak</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
          });
        }
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
      };
    })(<span class="ruby-identifier">this</span>)();
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Value</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Comment</span> = <span class="ruby-constant">Comment</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Comment</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Comment</span>(<span class="ruby-identifier">comment1</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">comment</span> = <span class="ruby-identifier">comment1</span>;
  }

  <span class="ruby-constant">Comment</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isStatement</span> = <span class="ruby-constant">YES</span>;

  <span class="ruby-constant">Comment</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">makeReturn</span> = <span class="ruby-constant">THIS</span>;

  <span class="ruby-constant">Comment</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">level</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">code</span>, <span class="ruby-identifier">comment</span>;
    <span class="ruby-identifier">comment</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">comment</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-node">/^(\s*)# /</span><span class="ruby-identifier">gm</span>, <span class="ruby-string">&quot;$1 * &quot;</span>);
    <span class="ruby-identifier">code</span> = <span class="ruby-string">&quot;/*&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">multident</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span>)) <span class="ruby-operator">+</span> (<span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">comment</span>, <span class="ruby-string">&#39;\n&#39;</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> <span class="ruby-operator">?</span> <span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">:</span> <span class="ruby-string">&#39;&#39;</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&quot; */&quot;</span>;
    <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">level</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span>) <span class="ruby-operator">===</span> <span class="ruby-constant">LEVEL_TOP</span>) {
      <span class="ruby-identifier">code</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">indent</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">code</span>;
    }
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">code</span>)];
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Comment</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Call</span> = <span class="ruby-constant">Call</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Call</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Call</span>(<span class="ruby-identifier">variable</span>, <span class="ruby-identifier">args1</span>, <span class="ruby-identifier">soak</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">args</span> = <span class="ruby-identifier">args1</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">args1</span> <span class="ruby-operator">:</span> [];
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">soak</span> = <span class="ruby-identifier">soak</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isNew</span> = <span class="ruby-keyword">false</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isSuper</span> = <span class="ruby-identifier">variable</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;super&#39;</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isSuper</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">variable</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">variable</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">variable</span>.<span class="ruby-identifier">isNotCallable</span>()) {
      <span class="ruby-identifier">variable</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&quot;literal is not a function&quot;</span>);
    }
  }

  <span class="ruby-constant">Call</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;variable&#39;</span>, <span class="ruby-string">&#39;args&#39;</span>];

  <span class="ruby-constant">Call</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">newInstance</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">base</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">base</span> = ((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">base</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">base</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Call</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">base</span>.<span class="ruby-identifier">isNew</span>) {
      <span class="ruby-identifier">base</span>.<span class="ruby-identifier">newInstance</span>();
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isNew</span> = <span class="ruby-keyword">true</span>;
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  };

  <span class="ruby-constant">Call</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">superReference</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">accesses</span>, <span class="ruby-identifier">base</span>, <span class="ruby-identifier">bref</span>, <span class="ruby-identifier">klass</span>, <span class="ruby-identifier">method</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">nref</span>, <span class="ruby-identifier">variable</span>;
    <span class="ruby-identifier">method</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">namedMethod</span>();
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">method</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">method</span>.<span class="ruby-identifier">klass</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) {
      <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">method</span>.<span class="ruby-identifier">klass</span>, <span class="ruby-identifier">name</span> = <span class="ruby-identifier">method</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">variable</span> = <span class="ruby-identifier">method</span>.<span class="ruby-identifier">variable</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">klass</span>.<span class="ruby-identifier">isComplex</span>()) {
        <span class="ruby-identifier">bref</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">parent</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;base&#39;</span>));
        <span class="ruby-identifier">base</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Parens</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">bref</span>, <span class="ruby-identifier">klass</span>)));
        <span class="ruby-identifier">variable</span>.<span class="ruby-identifier">base</span> = <span class="ruby-identifier">base</span>;
        <span class="ruby-identifier">variable</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">splice</span>(<span class="ruby-value">0</span>, <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">length</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">name</span>.<span class="ruby-identifier">isComplex</span>() <span class="ruby-operator">||</span> (<span class="ruby-identifier">name</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Index</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">name</span>.<span class="ruby-identifier">index</span>.<span class="ruby-identifier">isAssignable</span>())) {
        <span class="ruby-identifier">nref</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">parent</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;name&#39;</span>));
        <span class="ruby-identifier">name</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Index</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">nref</span>, <span class="ruby-identifier">name</span>.<span class="ruby-identifier">index</span>));
        <span class="ruby-identifier">variable</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">pop</span>();
        <span class="ruby-identifier">variable</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">name</span>);
      }
      <span class="ruby-identifier">accesses</span> = [<span class="ruby-identifier">new</span> <span class="ruby-constant">Access</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&#39;__super__&#39;</span>))];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">method</span>[<span class="ruby-string">&quot;static&quot;</span>]) {
        <span class="ruby-identifier">accesses</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Access</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&#39;constructor&#39;</span>)));
      }
      <span class="ruby-identifier">accesses</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">nref</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Index</span>(<span class="ruby-identifier">nref</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">name</span>);
      <span class="ruby-keyword">return</span> (<span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">bref</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">bref</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">klass</span>, <span class="ruby-identifier">accesses</span>)).<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">o</span>);
    } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">method</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">method</span>.<span class="ruby-identifier">ctor</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">method</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.__super__.constructor&quot;</span>;
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&#39;cannot call super outside of an instance method.&#39;</span>);
    }
  };

  <span class="ruby-constant">Call</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">superThis</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">method</span>;
    <span class="ruby-identifier">method</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">method</span>;
    <span class="ruby-keyword">return</span> (<span class="ruby-identifier">method</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">method</span>.<span class="ruby-identifier">klass</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">method</span>.<span class="ruby-identifier">context</span>) <span class="ruby-operator">||</span> <span class="ruby-string">&quot;this&quot;</span>;
  };

  <span class="ruby-constant">Call</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">unfoldSoak</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">call</span>, <span class="ruby-identifier">ifn</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">left</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">list</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">rite</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">soak</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">ifn</span> = <span class="ruby-identifier">unfoldSoak</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">this</span>, <span class="ruby-string">&#39;variable&#39;</span>)) {
          <span class="ruby-keyword">return</span> <span class="ruby-identifier">ifn</span>;
        }
        <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>).<span class="ruby-identifier">cacheReference</span>(<span class="ruby-identifier">o</span>), <span class="ruby-identifier">left</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">rite</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">1</span>];
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">left</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">superReference</span>(<span class="ruby-identifier">o</span>));
        <span class="ruby-identifier">rite</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">left</span>);
      }
      <span class="ruby-identifier">rite</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Call</span>(<span class="ruby-identifier">rite</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">args</span>);
      <span class="ruby-identifier">rite</span>.<span class="ruby-identifier">isNew</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isNew</span>;
      <span class="ruby-identifier">left</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&quot;typeof &quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">left</span>.<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">o</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot; === \&quot;function\&quot;&quot;</span>);
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">If</span>(<span class="ruby-identifier">left</span>, <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">rite</span>), {
        <span class="ruby-identifier">soak</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
      });
    }
    <span class="ruby-identifier">call</span> = <span class="ruby-identifier">this</span>;
    <span class="ruby-identifier">list</span> = [];
    <span class="ruby-keyword">while</span> (<span class="ruby-keyword">true</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">call</span>.<span class="ruby-identifier">variable</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Call</span>) {
        <span class="ruby-identifier">list</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">call</span>);
        <span class="ruby-identifier">call</span> = <span class="ruby-identifier">call</span>.<span class="ruby-identifier">variable</span>;
        <span class="ruby-identifier">continue</span>;
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">call</span>.<span class="ruby-identifier">variable</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span>)) {
        <span class="ruby-keyword">break</span>;
      }
      <span class="ruby-identifier">list</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">call</span>);
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>((<span class="ruby-identifier">call</span> = <span class="ruby-identifier">call</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">base</span>) <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Call</span>)) {
        <span class="ruby-keyword">break</span>;
      }
    }
    <span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">list</span>.<span class="ruby-identifier">reverse</span>();
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref4</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">call</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">ifn</span>) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">call</span>.<span class="ruby-identifier">variable</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Call</span>) {
          <span class="ruby-identifier">call</span>.<span class="ruby-identifier">variable</span> = <span class="ruby-identifier">ifn</span>;
        } <span class="ruby-keyword">else</span> {
          <span class="ruby-identifier">call</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">base</span> = <span class="ruby-identifier">ifn</span>;
        }
      }
      <span class="ruby-identifier">ifn</span> = <span class="ruby-identifier">unfoldSoak</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">call</span>, <span class="ruby-string">&#39;variable&#39;</span>);
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">ifn</span>;
  };

  <span class="ruby-constant">Call</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">arg</span>, <span class="ruby-identifier">argIndex</span>, <span class="ruby-identifier">compiledArgs</span>, <span class="ruby-identifier">compiledArray</span>, <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">preface</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>;
    <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span>) {
      <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">front</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">front</span>;
    }
    <span class="ruby-identifier">compiledArray</span> = <span class="ruby-constant">Splat</span>.<span class="ruby-identifier">compileSplattedArray</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">args</span>, <span class="ruby-keyword">true</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">compiledArray</span>.<span class="ruby-identifier">length</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileSplat</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">compiledArray</span>);
    }
    <span class="ruby-identifier">compiledArgs</span> = [];
    <span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">args</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">argIndex</span> = <span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref4</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">argIndex</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">j</span>) {
      <span class="ruby-identifier">arg</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-identifier">argIndex</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">argIndex</span>) {
        <span class="ruby-identifier">compiledArgs</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;, &quot;</span>));
      }
      <span class="ruby-identifier">compiledArgs</span>.<span class="ruby-identifier">push</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">compiledArgs</span>, <span class="ruby-identifier">arg</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>));
    }
    <span class="ruby-identifier">fragments</span> = [];
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">isSuper</span>) {
      <span class="ruby-identifier">preface</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">superReference</span>(<span class="ruby-identifier">o</span>) <span class="ruby-operator">+</span> (<span class="ruby-string">&quot;.call(&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">superThis</span>(<span class="ruby-identifier">o</span>)));
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">compiledArgs</span>.<span class="ruby-identifier">length</span>) {
        <span class="ruby-identifier">preface</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&quot;, &quot;</span>;
      }
      <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">preface</span>));
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">isNew</span>) {
        <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39;new &#39;</span>));
      }
      <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_ACCESS</span>));
      <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;(&quot;</span>));
    }
    <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">compiledArgs</span>);
    <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;)&quot;</span>));
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">fragments</span>;
  };

  <span class="ruby-constant">Call</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileSplat</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">splatArgs</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">base</span>, <span class="ruby-identifier">fun</span>, <span class="ruby-identifier">idt</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">ref</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">isSuper</span>) {
      <span class="ruby-keyword">return</span> [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>((<span class="ruby-identifier">this</span>.<span class="ruby-identifier">superReference</span>(<span class="ruby-identifier">o</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.apply(&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">superThis</span>(<span class="ruby-identifier">o</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;, &quot;</span>), <span class="ruby-identifier">splatArgs</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;)&quot;</span>));
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">isNew</span>) {
      <span class="ruby-identifier">idt</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-constant">TAB</span>;
      <span class="ruby-keyword">return</span> [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;(function(func, args, ctor) {\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idt</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;ctor.prototype = func.prototype;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idt</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;var child = new ctor, result = func.apply(child, args);\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idt</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;return Object(result) === result ? result : child;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;})(&quot;</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;, &quot;</span>), <span class="ruby-identifier">splatArgs</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;, function(){})&quot;</span>));
    }
    <span class="ruby-identifier">answer</span> = [];
    <span class="ruby-identifier">base</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>);
    <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">name</span> = <span class="ruby-identifier">base</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">pop</span>()) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">base</span>.<span class="ruby-identifier">isComplex</span>()) {
      <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;ref&#39;</span>);
      <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;(&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ref</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span>), <span class="ruby-identifier">base</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;)&quot;</span>), <span class="ruby-identifier">name</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>));
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">fun</span> = <span class="ruby-identifier">base</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_ACCESS</span>);
      <span class="ruby-keyword">if</span> (<span class="ruby-constant">SIMPLENUM</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">fun</span>))) {
        <span class="ruby-identifier">fun</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">wrapInBraces</span>(<span class="ruby-identifier">fun</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">name</span>) {
        <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">fun</span>);
        <span class="ruby-identifier">fun</span>.<span class="ruby-identifier">push</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">fun</span>, <span class="ruby-identifier">name</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>));
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">ref</span> = <span class="ruby-string">&#39;null&#39;</span>;
      }
      <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">fun</span>);
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;.apply(&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ref</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;, &quot;</span>), <span class="ruby-identifier">splatArgs</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;)&quot;</span>));
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Call</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Extends</span> = <span class="ruby-constant">Extends</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Extends</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Extends</span>(<span class="ruby-identifier">child1</span>, <span class="ruby-identifier">parent1</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">child</span> = <span class="ruby-identifier">child1</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">parent</span> = <span class="ruby-identifier">parent1</span>;
  }

  <span class="ruby-constant">Extends</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;child&#39;</span>, <span class="ruby-string">&#39;parent&#39;</span>];

  <span class="ruby-constant">Extends</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileToFragments</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Call</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">utility</span>(<span class="ruby-string">&#39;extend&#39;</span>, <span class="ruby-identifier">o</span>))), [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">child</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">parent</span>]).<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Extends</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Access</span> = <span class="ruby-constant">Access</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Access</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Access</span>(<span class="ruby-identifier">name1</span>, <span class="ruby-identifier">tag</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span> = <span class="ruby-identifier">name1</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">asKey</span> = <span class="ruby-keyword">true</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">soak</span> = <span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;soak&#39;</span>;
  }

  <span class="ruby-constant">Access</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;name&#39;</span>];

  <span class="ruby-constant">Access</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileToFragments</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">name</span>;
    <span class="ruby-identifier">name</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-constant">IDENTIFIER</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">name</span>))) {
      <span class="ruby-identifier">name</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;.&quot;</span>));
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">name</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;[&quot;</span>));
      <span class="ruby-identifier">name</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;]&quot;</span>));
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">name</span>;
  };

  <span class="ruby-constant">Access</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isComplex</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Access</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Index</span> = <span class="ruby-constant">Index</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Index</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Index</span>(<span class="ruby-identifier">index1</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">index</span> = <span class="ruby-identifier">index1</span>;
  }

  <span class="ruby-constant">Index</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;index&#39;</span>];

  <span class="ruby-constant">Index</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileToFragments</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">return</span> [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;[&quot;</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">index</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_PAREN</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;]&quot;</span>));
  };

  <span class="ruby-constant">Index</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isComplex</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">index</span>.<span class="ruby-identifier">isComplex</span>();
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Index</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Range</span> = <span class="ruby-constant">Range</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Range</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-constant">Range</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;from&#39;</span>, <span class="ruby-string">&#39;to&#39;</span>];

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Range</span>(<span class="ruby-identifier">from1</span>, <span class="ruby-identifier">to1</span>, <span class="ruby-identifier">tag</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">from</span> = <span class="ruby-identifier">from1</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">to</span> = <span class="ruby-identifier">to1</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">exclusive</span> = <span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;exclusive&#39;</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">equals</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">exclusive</span> <span class="ruby-operator">?</span> <span class="ruby-string">&#39;&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&#39;=&#39;</span>;
  }

  <span class="ruby-constant">Range</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileVariables</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">isComplex</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">ref5</span>, <span class="ruby-identifier">ref6</span>, <span class="ruby-identifier">step</span>;
    <span class="ruby-identifier">o</span> = <span class="ruby-identifier">merge</span>(<span class="ruby-identifier">o</span>, {
      <span class="ruby-identifier">top</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
    });
    <span class="ruby-identifier">isComplex</span> = <span class="ruby-identifier">del</span>(<span class="ruby-identifier">o</span>, <span class="ruby-string">&#39;isComplex&#39;</span>);
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">cacheToCodeFragments</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">from</span>.<span class="ruby-identifier">cache</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>, <span class="ruby-identifier">isComplex</span>)), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fromC</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fromVar</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">1</span>];
    <span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">cacheToCodeFragments</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">to</span>.<span class="ruby-identifier">cache</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>, <span class="ruby-identifier">isComplex</span>)), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toC</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toVar</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">1</span>];
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">step</span> = <span class="ruby-identifier">del</span>(<span class="ruby-identifier">o</span>, <span class="ruby-string">&#39;step&#39;</span>)) {
      <span class="ruby-identifier">ref5</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">cacheToCodeFragments</span>(<span class="ruby-identifier">step</span>.<span class="ruby-identifier">cache</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>, <span class="ruby-identifier">isComplex</span>)), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">step</span> = <span class="ruby-identifier">ref5</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">this</span>.<span class="ruby-identifier">stepVar</span> = <span class="ruby-identifier">ref5</span>[<span class="ruby-value">1</span>];
    }
    <span class="ruby-identifier">ref6</span> = [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">fromVar</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">NUMBER</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toVar</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">NUMBER</span>)], <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fromNum</span> = <span class="ruby-identifier">ref6</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toNum</span> = <span class="ruby-identifier">ref6</span>[<span class="ruby-value">1</span>];
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">stepVar</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">stepNum</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">stepVar</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">NUMBER</span>);
    }
  };

  <span class="ruby-constant">Range</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">cond</span>, <span class="ruby-identifier">condPart</span>, <span class="ruby-identifier">from</span>, <span class="ruby-identifier">gt</span>, <span class="ruby-identifier">idx</span>, <span class="ruby-identifier">idxName</span>, <span class="ruby-identifier">known</span>, <span class="ruby-identifier">lt</span>, <span class="ruby-identifier">namedIndex</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">stepPart</span>, <span class="ruby-identifier">to</span>, <span class="ruby-identifier">varPart</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">fromVar</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileVariables</span>(<span class="ruby-identifier">o</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">o</span>.<span class="ruby-identifier">index</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileArray</span>(<span class="ruby-identifier">o</span>);
    }
    <span class="ruby-identifier">known</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fromNum</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toNum</span>;
    <span class="ruby-identifier">idx</span> = <span class="ruby-identifier">del</span>(<span class="ruby-identifier">o</span>, <span class="ruby-string">&#39;index&#39;</span>);
    <span class="ruby-identifier">idxName</span> = <span class="ruby-identifier">del</span>(<span class="ruby-identifier">o</span>, <span class="ruby-string">&#39;name&#39;</span>);
    <span class="ruby-identifier">namedIndex</span> = <span class="ruby-identifier">idxName</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">idxName</span> <span class="ruby-operator">!=</span>= <span class="ruby-identifier">idx</span>;
    <span class="ruby-identifier">varPart</span> = <span class="ruby-identifier">idx</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fromC</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">toC</span> <span class="ruby-operator">!=</span>= <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toVar</span>) {
      <span class="ruby-identifier">varPart</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&quot;, &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toC</span>;
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">step</span> <span class="ruby-operator">!=</span>= <span class="ruby-identifier">this</span>.<span class="ruby-identifier">stepVar</span>) {
      <span class="ruby-identifier">varPart</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&quot;, &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">step</span>;
    }
    <span class="ruby-identifier">ref3</span> = [<span class="ruby-identifier">idx</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &lt;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">equals</span>, <span class="ruby-identifier">idx</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &gt;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">equals</span>], <span class="ruby-identifier">lt</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">gt</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">1</span>];
    <span class="ruby-identifier">condPart</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">stepNum</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">parseNum</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">stepNum</span>[<span class="ruby-value">0</span>]) <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">lt</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toVar</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">gt</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toVar</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">known</span> <span class="ruby-operator">?</span> ((<span class="ruby-identifier">ref4</span> = [<span class="ruby-identifier">parseNum</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">fromNum</span>[<span class="ruby-value">0</span>]), <span class="ruby-identifier">parseNum</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">toNum</span>[<span class="ruby-value">0</span>])], <span class="ruby-identifier">from</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">to</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">ref4</span>), <span class="ruby-identifier">from</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">to</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">lt</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">to</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">gt</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">to</span>) <span class="ruby-operator">:</span> (<span class="ruby-identifier">cond</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">stepVar</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">stepVar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &gt; 0&quot;</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fromVar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &lt;= &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toVar</span>, <span class="ruby-identifier">cond</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; ? &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">lt</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toVar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; : &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">gt</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toVar</span>);
    <span class="ruby-identifier">stepPart</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">stepVar</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">idx</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; += &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">stepVar</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">known</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">namedIndex</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">from</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">to</span> <span class="ruby-operator">?</span> <span class="ruby-string">&quot;++&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idx</span> <span class="ruby-operator">:</span> <span class="ruby-string">&quot;--&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idx</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">from</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">to</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">idx</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;++&quot;</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">idx</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;--&quot;</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">namedIndex</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">cond</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; ? ++&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idx</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; : --&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idx</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">cond</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; ? &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idx</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;++ : &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idx</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;--&quot;</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">namedIndex</span>) {
      <span class="ruby-identifier">varPart</span> = <span class="ruby-identifier">idxName</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">varPart</span>;
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">namedIndex</span>) {
      <span class="ruby-identifier">stepPart</span> = <span class="ruby-identifier">idxName</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">stepPart</span>;
    }
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">varPart</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">condPart</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">stepPart</span>)];
  };

  <span class="ruby-constant">Range</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileArray</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">args</span>, <span class="ruby-identifier">body</span>, <span class="ruby-identifier">cond</span>, <span class="ruby-identifier">hasArgs</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">idt</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">post</span>, <span class="ruby-identifier">pre</span>, <span class="ruby-identifier">range</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">result</span>, <span class="ruby-identifier">results</span>, <span class="ruby-identifier">vars</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">fromNum</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toNum</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">Math</span>.<span class="ruby-identifier">abs</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">fromNum</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toNum</span>) <span class="ruby-operator">&lt;=</span> <span class="ruby-value">20</span>) {
      <span class="ruby-identifier">range</span> = (<span class="ruby-identifier">function</span>() {
        <span class="ruby-identifier">results</span> = [];
        <span class="ruby-keyword">for</span> (<span class="ruby-identifier">var</span> <span class="ruby-identifier">j</span> = <span class="ruby-identifier">ref3</span> = <span class="ruby-operator">+</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">fromNum</span>, <span class="ruby-identifier">ref4</span> = <span class="ruby-operator">+</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">toNum</span>; <span class="ruby-identifier">ref3</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">ref4</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">ref4</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">j</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">ref4</span>; <span class="ruby-identifier">ref3</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">ref4</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">j</span><span class="ruby-operator">-</span><span class="ruby-operator">-</span>){ <span class="ruby-identifier">results</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">j</span>); }
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">results</span>;
      }).<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>);
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">exclusive</span>) {
        <span class="ruby-identifier">range</span>.<span class="ruby-identifier">pop</span>();
      }
      <span class="ruby-keyword">return</span> [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;[&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">range</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&#39;, &#39;</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;]&quot;</span>)];
    }
    <span class="ruby-identifier">idt</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-constant">TAB</span>;
    <span class="ruby-identifier">i</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;i&#39;</span>, {
      <span class="ruby-identifier">single</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
    });
    <span class="ruby-identifier">result</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;results&#39;</span>);
    <span class="ruby-identifier">pre</span> = <span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idt</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">result</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = [];&quot;</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">fromNum</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toNum</span>) {
      <span class="ruby-identifier">o</span>.<span class="ruby-identifier">index</span> = <span class="ruby-identifier">i</span>;
      <span class="ruby-identifier">body</span> = <span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileNode</span>(<span class="ruby-identifier">o</span>));
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">vars</span> = (<span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fromC</span>) <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">toC</span> <span class="ruby-operator">!=</span>= <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toVar</span> <span class="ruby-operator">?</span> <span class="ruby-string">&quot;, &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toC</span> <span class="ruby-operator">:</span> <span class="ruby-string">&#39;&#39;</span>);
      <span class="ruby-identifier">cond</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">fromVar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &lt;= &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toVar</span>;
      <span class="ruby-identifier">body</span> = <span class="ruby-string">&quot;var &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">vars</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">cond</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; ? &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &lt;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">equals</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toVar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; : &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &gt;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">equals</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">toVar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">cond</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; ? &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;++ : &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;--&quot;</span>;
    }
    <span class="ruby-identifier">post</span> = <span class="ruby-string">&quot;{ &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">result</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.push(&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;); }\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idt</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;return &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">result</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">indent</span>;
    <span class="ruby-identifier">hasArgs</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">node</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">contains</span>(<span class="ruby-identifier">isLiteralArguments</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>;
    };
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">hasArgs</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">from</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">hasArgs</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">to</span>)) {
      <span class="ruby-identifier">args</span> = <span class="ruby-string">&#39;, arguments&#39;</span>;
    }
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;(function() {&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">pre</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idt</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;for (&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">body</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;)&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">post</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;}).apply(this&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">args</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">args</span> <span class="ruby-operator">:</span> <span class="ruby-string">&#39;&#39;</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;)&quot;</span>)];
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Range</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Slice</span> = <span class="ruby-constant">Slice</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Slice</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-constant">Slice</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;range&#39;</span>];

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Slice</span>(<span class="ruby-identifier">range1</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">range</span> = <span class="ruby-identifier">range1</span>;
    <span class="ruby-constant">Slice</span>.<span class="ruby-identifier">__super__</span>.<span class="ruby-identifier">constructor</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>);
  }

  <span class="ruby-constant">Slice</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">compiled</span>, <span class="ruby-identifier">compiledText</span>, <span class="ruby-identifier">from</span>, <span class="ruby-identifier">fromCompiled</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">to</span>, <span class="ruby-identifier">toStr</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">range</span>, <span class="ruby-identifier">to</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">to</span>, <span class="ruby-identifier">from</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">from</span>;
    <span class="ruby-identifier">fromCompiled</span> = <span class="ruby-identifier">from</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">from</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_PAREN</span>) <span class="ruby-operator">||</span> [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39;0&#39;</span>)];
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">to</span>) {
      <span class="ruby-identifier">compiled</span> = <span class="ruby-identifier">to</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_PAREN</span>);
      <span class="ruby-identifier">compiledText</span> = <span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">compiled</span>);
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">range</span>.<span class="ruby-identifier">exclusive</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">+</span><span class="ruby-identifier">compiledText</span> <span class="ruby-operator">===</span> <span class="ruby-value">-1</span>)) {
        <span class="ruby-identifier">toStr</span> = <span class="ruby-string">&#39;, &#39;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">range</span>.<span class="ruby-identifier">exclusive</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">compiledText</span> <span class="ruby-operator">:</span> <span class="ruby-constant">SIMPLENUM</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">compiledText</span>) <span class="ruby-operator">?</span> <span class="ruby-string">&quot;&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-operator">+</span><span class="ruby-identifier">compiledText</span> <span class="ruby-operator">+</span> <span class="ruby-value">1</span>) <span class="ruby-operator">:</span> (<span class="ruby-identifier">compiled</span> = <span class="ruby-identifier">to</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_ACCESS</span>), <span class="ruby-string">&quot;+&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">compiled</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot; + 1 || 9e9&quot;</span>));
      }
    }
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;.slice(&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">fromCompiled</span>)) <span class="ruby-operator">+</span> (<span class="ruby-identifier">toStr</span> <span class="ruby-operator">||</span> <span class="ruby-string">&#39;&#39;</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;)&quot;</span>)];
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Slice</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Obj</span> = <span class="ruby-constant">Obj</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Obj</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Obj</span>(<span class="ruby-identifier">props</span>, <span class="ruby-identifier">generated</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">generated</span> = <span class="ruby-identifier">generated</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">generated</span> <span class="ruby-operator">:</span> <span class="ruby-keyword">false</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">objects</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span> = <span class="ruby-identifier">props</span> <span class="ruby-operator">||</span> [];
  }

  <span class="ruby-constant">Obj</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;properties&#39;</span>];

  <span class="ruby-constant">Obj</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">dynamicIndex</span>, <span class="ruby-identifier">hasDynamic</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">idt</span>, <span class="ruby-identifier">indent</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">join</span>, <span class="ruby-identifier">k</span>, <span class="ruby-identifier">key</span>, <span class="ruby-identifier">l</span>, <span class="ruby-identifier">lastNoncom</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">len2</span>, <span class="ruby-identifier">len3</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">oref</span>, <span class="ruby-identifier">prop</span>, <span class="ruby-identifier">props</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">value</span>;
    <span class="ruby-identifier">props</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">generated</span>) {
      <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">props</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
        <span class="ruby-identifier">node</span> = <span class="ruby-identifier">props</span>[<span class="ruby-identifier">j</span>];
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span>) {
          <span class="ruby-identifier">node</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&#39;cannot have an implicit value in an implicit object&#39;</span>);
        }
      }
    }
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">dynamicIndex</span> = <span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len2</span> = <span class="ruby-identifier">props</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">k</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len2</span>; <span class="ruby-identifier">dynamicIndex</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">k</span>) {
      <span class="ruby-identifier">prop</span> = <span class="ruby-identifier">props</span>[<span class="ruby-identifier">dynamicIndex</span>];
      <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">prop</span>.<span class="ruby-identifier">variable</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">prop</span>).<span class="ruby-identifier">base</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Parens</span>) {
        <span class="ruby-keyword">break</span>;
      }
    }
    <span class="ruby-identifier">hasDynamic</span> = <span class="ruby-identifier">dynamicIndex</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">length</span>;
    <span class="ruby-identifier">idt</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">indent</span> <span class="ruby-operator">+=</span> <span class="ruby-constant">TAB</span>;
    <span class="ruby-identifier">lastNoncom</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">lastNonComment</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>);
    <span class="ruby-identifier">answer</span> = [];
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">hasDynamic</span>) {
      <span class="ruby-identifier">oref</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;obj&#39;</span>);
      <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;(\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idt</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">oref</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span>));
    }
    <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;{&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">props</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">===</span> <span class="ruby-value">0</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">dynamicIndex</span> <span class="ruby-operator">===</span> <span class="ruby-value">0</span> <span class="ruby-operator">?</span> <span class="ruby-string">&#39;}&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&#39;\n&#39;</span>)));
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-identifier">l</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len3</span> = <span class="ruby-identifier">props</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">l</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len3</span>; <span class="ruby-identifier">i</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">l</span>) {
      <span class="ruby-identifier">prop</span> = <span class="ruby-identifier">props</span>[<span class="ruby-identifier">i</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">dynamicIndex</span>) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i</span> <span class="ruby-operator">!=</span>= <span class="ruby-value">0</span>) {
          <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idt</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;}&quot;</span>));
        }
        <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39;,\n&#39;</span>));
      }
      <span class="ruby-identifier">join</span> = <span class="ruby-identifier">i</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">props</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">dynamicIndex</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span> <span class="ruby-operator">?</span> <span class="ruby-string">&#39;&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">prop</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">lastNoncom</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">prop</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Comment</span> <span class="ruby-operator">?</span> <span class="ruby-string">&#39;\n&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&#39;,\n&#39;</span>;
      <span class="ruby-identifier">indent</span> = <span class="ruby-identifier">prop</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Comment</span> <span class="ruby-operator">?</span> <span class="ruby-string">&#39;&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">idt</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">hasDynamic</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">dynamicIndex</span>) {
        <span class="ruby-identifier">indent</span> <span class="ruby-operator">+=</span> <span class="ruby-constant">TAB</span>;
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">prop</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Assign</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prop</span>.<span class="ruby-identifier">variable</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prop</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">hasProperties</span>()) {
        <span class="ruby-identifier">prop</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&#39;Invalid object key&#39;</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">prop</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">prop</span>[<span class="ruby-string">&quot;this&quot;</span>]) {
        <span class="ruby-identifier">prop</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">prop</span>.<span class="ruby-identifier">properties</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">name</span>, <span class="ruby-identifier">prop</span>, <span class="ruby-string">&#39;object&#39;</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">prop</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Comment</span>)) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">dynamicIndex</span>) {
          <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">prop</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Assign</span>)) {
            <span class="ruby-identifier">prop</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">prop</span>, <span class="ruby-identifier">prop</span>, <span class="ruby-string">&#39;object&#39;</span>);
          }
          (<span class="ruby-identifier">prop</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">base</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">prop</span>.<span class="ruby-identifier">variable</span>).<span class="ruby-identifier">asKey</span> = <span class="ruby-keyword">true</span>;
        } <span class="ruby-keyword">else</span> {
          <span class="ruby-keyword">if</span> (<span class="ruby-identifier">prop</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Assign</span>) {
            <span class="ruby-identifier">key</span> = <span class="ruby-identifier">prop</span>.<span class="ruby-identifier">variable</span>;
            <span class="ruby-identifier">value</span> = <span class="ruby-identifier">prop</span>.<span class="ruby-identifier">value</span>;
          } <span class="ruby-keyword">else</span> {
            <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">prop</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">cache</span>(<span class="ruby-identifier">o</span>), <span class="ruby-identifier">key</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">value</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">1</span>];
          }
          <span class="ruby-identifier">prop</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">oref</span>), [<span class="ruby-identifier">new</span> <span class="ruby-constant">Access</span>(<span class="ruby-identifier">key</span>)]), <span class="ruby-identifier">value</span>);
        }
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">indent</span>) {
        <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">indent</span>));
      }
      <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">answer</span>, <span class="ruby-identifier">prop</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_TOP</span>));
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">join</span>) {
        <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">join</span>));
      }
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">hasDynamic</span>) {
      <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;,\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idt</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">oref</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;)&quot;</span>));
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">props</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">!=</span>= <span class="ruby-value">0</span>) {
        <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;}&quot;</span>));
      }
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">front</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">hasDynamic</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">wrapInBraces</span>(<span class="ruby-identifier">answer</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span>;
    }
  };

  <span class="ruby-constant">Obj</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">assigns</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">name</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">prop</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">properties</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">prop</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">prop</span>.<span class="ruby-identifier">assigns</span>(<span class="ruby-identifier">name</span>)) {
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Obj</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Arr</span> = <span class="ruby-constant">Arr</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Arr</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Arr</span>(<span class="ruby-identifier">objs</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">objects</span> = <span class="ruby-identifier">objs</span> <span class="ruby-operator">||</span> [];
  }

  <span class="ruby-constant">Arr</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;objects&#39;</span>];

  <span class="ruby-constant">Arr</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">compiledObjs</span>, <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">index</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">obj</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">objects</span>.<span class="ruby-identifier">length</span>) {
      <span class="ruby-keyword">return</span> [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39;[]&#39;</span>)];
    }
    <span class="ruby-identifier">o</span>.<span class="ruby-identifier">indent</span> <span class="ruby-operator">+=</span> <span class="ruby-constant">TAB</span>;
    <span class="ruby-identifier">answer</span> = <span class="ruby-constant">Splat</span>.<span class="ruby-identifier">compileSplattedArray</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">objects</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">answer</span>.<span class="ruby-identifier">length</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span>;
    }
    <span class="ruby-identifier">answer</span> = [];
    <span class="ruby-identifier">compiledObjs</span> = (<span class="ruby-identifier">function</span>() {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">results</span>;
      <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">objects</span>;
      <span class="ruby-identifier">results</span> = [];
      <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
        <span class="ruby-identifier">obj</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">j</span>];
        <span class="ruby-identifier">results</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">obj</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>));
      }
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">results</span>;
    }).<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>);
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">index</span> = <span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">compiledObjs</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">index</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">j</span>) {
      <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">compiledObjs</span>[<span class="ruby-identifier">index</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">index</span>) {
        <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;, &quot;</span>));
      }
      <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">answer</span>, <span class="ruby-identifier">fragments</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">answer</span>).<span class="ruby-identifier">indexOf</span>(<span class="ruby-string">&#39;\n&#39;</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) {
      <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;[\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">indent</span>));
      <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;]&quot;</span>));
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;[&quot;</span>));
      <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;]&quot;</span>));
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span>;
  };

  <span class="ruby-constant">Arr</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">assigns</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">name</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">obj</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">objects</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">obj</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">obj</span>.<span class="ruby-identifier">assigns</span>(<span class="ruby-identifier">name</span>)) {
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">true</span>;
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Arr</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Class</span> = <span class="ruby-constant">Class</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Class</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Class</span>(<span class="ruby-identifier">variable1</span>, <span class="ruby-identifier">parent1</span>, <span class="ruby-identifier">body1</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span> = <span class="ruby-identifier">variable1</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">parent</span> = <span class="ruby-identifier">parent1</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span> = <span class="ruby-identifier">body1</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">body1</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Block</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">boundFuncs</span> = [];
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">classBody</span> = <span class="ruby-keyword">true</span>;
  }

  <span class="ruby-constant">Class</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;variable&#39;</span>, <span class="ruby-string">&#39;parent&#39;</span>, <span class="ruby-string">&#39;body&#39;</span>];

  <span class="ruby-constant">Class</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">determineName</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">decl</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">tail</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">null</span>;
    }
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">properties</span>, <span class="ruby-identifier">tail</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>];
    <span class="ruby-identifier">decl</span> = <span class="ruby-identifier">tail</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">tail</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Access</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">tail</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">value</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">STRICT_PROSCRIBED</span>, <span class="ruby-identifier">decl</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&quot;class variable name may not be &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">decl</span>);
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">decl</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">decl</span> = <span class="ruby-constant">IDENTIFIER</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">decl</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">decl</span>);
  };

  <span class="ruby-constant">Class</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">setContext</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">name</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">traverseChildren</span>(<span class="ruby-keyword">false</span>, <span class="ruby-identifier">function</span>(<span class="ruby-identifier">node</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">node</span>.<span class="ruby-identifier">classBody</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Literal</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;this&#39;</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span> = <span class="ruby-identifier">name</span>;
      } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Code</span>) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">node</span>.<span class="ruby-identifier">bound</span>) {
          <span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">context</span> = <span class="ruby-identifier">name</span>;
        }
      }
    });
  };

  <span class="ruby-constant">Class</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">addBoundFunctions</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">bvar</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">boundFuncs</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">bvar</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-identifier">lhs</span> = (<span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&quot;this&quot;</span>), [<span class="ruby-identifier">new</span> <span class="ruby-constant">Access</span>(<span class="ruby-identifier">bvar</span>)])).<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">o</span>);
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">lhs</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">utility</span>(<span class="ruby-string">&#39;bind&#39;</span>, <span class="ruby-identifier">o</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;(&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">lhs</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;, this)&quot;</span>));
    }
  };

  <span class="ruby-constant">Class</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">addProperties</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">acc</span>, <span class="ruby-identifier">assign</span>, <span class="ruby-identifier">base</span>, <span class="ruby-identifier">exprs</span>, <span class="ruby-identifier">func</span>, <span class="ruby-identifier">props</span>;
    <span class="ruby-identifier">props</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">0</span>);
    <span class="ruby-identifier">exprs</span> = (<span class="ruby-identifier">function</span>() {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">results</span>;
      <span class="ruby-identifier">results</span> = [];
      <span class="ruby-keyword">while</span> (<span class="ruby-identifier">assign</span> = <span class="ruby-identifier">props</span>.<span class="ruby-identifier">shift</span>()) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">assign</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Assign</span>) {
          <span class="ruby-identifier">base</span> = <span class="ruby-identifier">assign</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">base</span>;
          <span class="ruby-identifier">delete</span> <span class="ruby-identifier">assign</span>.<span class="ruby-identifier">context</span>;
          <span class="ruby-identifier">func</span> = <span class="ruby-identifier">assign</span>.<span class="ruby-identifier">value</span>;
          <span class="ruby-keyword">if</span> (<span class="ruby-identifier">base</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;constructor&#39;</span>) {
            <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span>) {
              <span class="ruby-identifier">assign</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&#39;cannot define more than one constructor in a class&#39;</span>);
            }
            <span class="ruby-keyword">if</span> (<span class="ruby-identifier">func</span>.<span class="ruby-identifier">bound</span>) {
              <span class="ruby-identifier">assign</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&#39;cannot define a constructor as a bound function&#39;</span>);
            }
            <span class="ruby-keyword">if</span> (<span class="ruby-identifier">func</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Code</span>) {
              <span class="ruby-identifier">assign</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span> = <span class="ruby-identifier">func</span>;
            } <span class="ruby-keyword">else</span> {
              <span class="ruby-identifier">this</span>.<span class="ruby-identifier">externalCtor</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">classScope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;class&#39;</span>);
              <span class="ruby-identifier">assign</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">externalCtor</span>), <span class="ruby-identifier">func</span>);
            }
          } <span class="ruby-keyword">else</span> {
            <span class="ruby-keyword">if</span> (<span class="ruby-identifier">assign</span>.<span class="ruby-identifier">variable</span>[<span class="ruby-string">&quot;this&quot;</span>]) {
              <span class="ruby-identifier">func</span>[<span class="ruby-string">&quot;static&quot;</span>] = <span class="ruby-keyword">true</span>;
            } <span class="ruby-keyword">else</span> {
              <span class="ruby-identifier">acc</span> = <span class="ruby-identifier">base</span>.<span class="ruby-identifier">isComplex</span>() <span class="ruby-operator">?</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Index</span>(<span class="ruby-identifier">base</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Access</span>(<span class="ruby-identifier">base</span>);
              <span class="ruby-identifier">assign</span>.<span class="ruby-identifier">variable</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">name</span>), [<span class="ruby-identifier">new</span> <span class="ruby-constant">Access</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&#39;prototype&#39;</span>)), <span class="ruby-identifier">acc</span>]);
              <span class="ruby-keyword">if</span> (<span class="ruby-identifier">func</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Code</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">func</span>.<span class="ruby-identifier">bound</span>) {
                <span class="ruby-identifier">this</span>.<span class="ruby-identifier">boundFuncs</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">base</span>);
                <span class="ruby-identifier">func</span>.<span class="ruby-identifier">bound</span> = <span class="ruby-keyword">false</span>;
              }
            }
          }
        }
        <span class="ruby-identifier">results</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">assign</span>);
      }
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">results</span>;
    }).<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">compact</span>(<span class="ruby-identifier">exprs</span>);
  };

  <span class="ruby-constant">Class</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">walkBody</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">traverseChildren</span>(<span class="ruby-keyword">false</span>, (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">_this</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">child</span>) {
        <span class="ruby-identifier">var</span> <span class="ruby-identifier">cont</span>, <span class="ruby-identifier">exps</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">ref3</span>;
        <span class="ruby-identifier">cont</span> = <span class="ruby-keyword">true</span>;
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">child</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Class</span>) {
          <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
        }
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">child</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Block</span>) {
          <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">exps</span> = <span class="ruby-identifier">child</span>.<span class="ruby-identifier">expressions</span>;
          <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">i</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">j</span>) {
            <span class="ruby-identifier">node</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">i</span>];
            <span class="ruby-keyword">if</span> (<span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Assign</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">looksStatic</span>(<span class="ruby-identifier">name</span>)) {
              <span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span>[<span class="ruby-string">&quot;static&quot;</span>] = <span class="ruby-keyword">true</span>;
            } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">isObject</span>(<span class="ruby-keyword">true</span>)) {
              <span class="ruby-identifier">cont</span> = <span class="ruby-keyword">false</span>;
              <span class="ruby-identifier">exps</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">_this</span>.<span class="ruby-identifier">addProperties</span>(<span class="ruby-identifier">node</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">o</span>);
            }
          }
          <span class="ruby-identifier">child</span>.<span class="ruby-identifier">expressions</span> = <span class="ruby-identifier">exps</span> = <span class="ruby-identifier">flatten</span>(<span class="ruby-identifier">exps</span>);
        }
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">cont</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">child</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Class</span>);
      };
    })(<span class="ruby-identifier">this</span>));
  };

  <span class="ruby-constant">Class</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">hoistDirectivePrologue</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">expressions</span>, <span class="ruby-identifier">index</span>, <span class="ruby-identifier">node</span>;
    <span class="ruby-identifier">index</span> = <span class="ruby-value">0</span>;
    <span class="ruby-identifier">expressions</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">expressions</span>;
    <span class="ruby-keyword">while</span> ((<span class="ruby-identifier">node</span> = <span class="ruby-identifier">expressions</span>[<span class="ruby-identifier">index</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Comment</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">isString</span>()) {
      <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">index</span>;
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">directives</span> = <span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">splice</span>(<span class="ruby-value">0</span>, <span class="ruby-identifier">index</span>);
  };

  <span class="ruby-constant">Class</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">ensureConstructor</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">name</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Code</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">externalCtor</span>) {
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">externalCtor</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.apply(this, arguments)&quot;</span>));
      } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">parent</span>) {
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">name</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.__super__.constructor.apply(this, arguments)&quot;</span>));
      }
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">makeReturn</span>();
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span>);
    }
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span>.<span class="ruby-identifier">ctor</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span>.<span class="ruby-identifier">name</span> = <span class="ruby-identifier">name</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span>.<span class="ruby-identifier">klass</span> = <span class="ruby-identifier">null</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span>.<span class="ruby-identifier">noReturn</span> = <span class="ruby-keyword">true</span>;
  };

  <span class="ruby-constant">Class</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">args</span>, <span class="ruby-identifier">argumentsNode</span>, <span class="ruby-identifier">func</span>, <span class="ruby-identifier">jumpNode</span>, <span class="ruby-identifier">klass</span>, <span class="ruby-identifier">lname</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">superClass</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">jumpNode</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">jumps</span>()) {
      <span class="ruby-identifier">jumpNode</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&#39;Class bodies cannot contain pure statements&#39;</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">argumentsNode</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">contains</span>(<span class="ruby-identifier">isLiteralArguments</span>)) {
      <span class="ruby-identifier">argumentsNode</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&quot;Class bodies shouldn&#39;t reference arguments&quot;</span>);
    }
    <span class="ruby-identifier">name</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">determineName</span>() <span class="ruby-operator">||</span> <span class="ruby-string">&#39;_Class&#39;</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">name</span>.<span class="ruby-identifier">reserved</span>) {
      <span class="ruby-identifier">name</span> = <span class="ruby-string">&quot;_&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">name</span>;
    }
    <span class="ruby-identifier">lname</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">name</span>);
    <span class="ruby-identifier">func</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Code</span>([], <span class="ruby-constant">Block</span>.<span class="ruby-identifier">wrap</span>([<span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>]));
    <span class="ruby-identifier">args</span> = [];
    <span class="ruby-identifier">o</span>.<span class="ruby-identifier">classScope</span> = <span class="ruby-identifier">func</span>.<span class="ruby-identifier">makeScope</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>);
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">hoistDirectivePrologue</span>();
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">setContext</span>(<span class="ruby-identifier">name</span>);
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">walkBody</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">o</span>);
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ensureConstructor</span>(<span class="ruby-identifier">name</span>);
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">addBoundFunctions</span>(<span class="ruby-identifier">o</span>);
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">spaced</span> = <span class="ruby-keyword">true</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">lname</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">parent</span>) {
      <span class="ruby-identifier">superClass</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">classScope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;superClass&#39;</span>, {
        <span class="ruby-identifier">reserve</span><span class="ruby-operator">:</span> <span class="ruby-keyword">false</span>
      }));
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Extends</span>(<span class="ruby-identifier">lname</span>, <span class="ruby-identifier">superClass</span>));
      <span class="ruby-identifier">func</span>.<span class="ruby-identifier">params</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Param</span>(<span class="ruby-identifier">superClass</span>));
      <span class="ruby-identifier">args</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">parent</span>);
    }
    (<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">expressions</span>).<span class="ruby-identifier">unshift</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">directives</span>);
    <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Parens</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Call</span>(<span class="ruby-identifier">func</span>, <span class="ruby-identifier">args</span>));
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>) {
      <span class="ruby-identifier">klass</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>, <span class="ruby-identifier">klass</span>);
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">klass</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Class</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Assign</span> = <span class="ruby-constant">Assign</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Assign</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">variable1</span>, <span class="ruby-identifier">value1</span>, <span class="ruby-identifier">context</span>, <span class="ruby-identifier">options</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">forbidden</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span> = <span class="ruby-identifier">variable1</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span> = <span class="ruby-identifier">value1</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span> = <span class="ruby-identifier">context</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">param</span> = <span class="ruby-identifier">options</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">param</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">subpattern</span> = <span class="ruby-identifier">options</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">subpattern</span>;
    <span class="ruby-identifier">forbidden</span> = (<span class="ruby-identifier">ref3</span> = (<span class="ruby-identifier">name</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">unwrapAll</span>().<span class="ruby-identifier">value</span>), <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">STRICT_PROSCRIBED</span>, <span class="ruby-identifier">ref3</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">forbidden</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;object&#39;</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&quot;variable name may not be \&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\&quot;&quot;</span>);
    }
  }

  <span class="ruby-constant">Assign</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;variable&#39;</span>, <span class="ruby-string">&#39;value&#39;</span>];

  <span class="ruby-constant">Assign</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isStatement</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">return</span> (<span class="ruby-identifier">o</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">===</span> <span class="ruby-constant">LEVEL_TOP</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span>, <span class="ruby-string">&quot;?&quot;</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>;
  };

  <span class="ruby-constant">Assign</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">assigns</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">name</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>[<span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;object&#39;</span> <span class="ruby-operator">?</span> <span class="ruby-string">&#39;value&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&#39;variable&#39;</span>].<span class="ruby-identifier">assigns</span>(<span class="ruby-identifier">name</span>);
  };

  <span class="ruby-constant">Assign</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">unfoldSoak</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">unfoldSoak</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">this</span>, <span class="ruby-string">&#39;variable&#39;</span>);
  };

  <span class="ruby-constant">Assign</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">compiledName</span>, <span class="ruby-identifier">isValue</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">properties</span>, <span class="ruby-identifier">prototype</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">ref5</span>, <span class="ruby-identifier">ref6</span>, <span class="ruby-identifier">ref7</span>, <span class="ruby-identifier">val</span>, <span class="ruby-identifier">varBase</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">isValue</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">isArray</span>() <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">isObject</span>()) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compilePatternMatch</span>(<span class="ruby-identifier">o</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">isSplice</span>()) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileSplice</span>(<span class="ruby-identifier">o</span>);
      }
      <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;||=&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;&amp;&amp;=&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;?=&#39;</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileConditional</span>(<span class="ruby-identifier">o</span>);
      }
      <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;**=&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref4</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;//=&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref4</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;%%=&#39;</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileSpecialMath</span>(<span class="ruby-identifier">o</span>);
      }
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Code</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>[<span class="ruby-string">&quot;static&quot;</span>]) {
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">klass</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">base</span>;
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">name</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">properties</span>[<span class="ruby-value">0</span>];
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">variable</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>;
      } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (((<span class="ruby-identifier">ref5</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">properties</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref5</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">2</span>) {
        <span class="ruby-identifier">ref6</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">properties</span>, <span class="ruby-identifier">properties</span> = <span class="ruby-value">3</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-identifier">ref6</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">slice</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">ref6</span>, <span class="ruby-value">0</span>, <span class="ruby-identifier">j</span> = <span class="ruby-identifier">ref6</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">2</span>) <span class="ruby-operator">:</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, []), <span class="ruby-identifier">prototype</span> = <span class="ruby-identifier">ref6</span>[<span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>], <span class="ruby-identifier">name</span> = <span class="ruby-identifier">ref6</span>[<span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>];
        <span class="ruby-keyword">if</span> (((<span class="ruby-identifier">ref7</span> = <span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">name</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref7</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;prototype&#39;</span>) {
          <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">klass</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">base</span>, <span class="ruby-identifier">properties</span>);
          <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">name</span> = <span class="ruby-identifier">name</span>;
          <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">variable</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>;
        }
      }
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span>) {
      <span class="ruby-identifier">varBase</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">unwrapAll</span>();
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">varBase</span>.<span class="ruby-identifier">isAssignable</span>()) {
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&quot;\&quot;&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">o</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\&quot; cannot be assigned&quot;</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">typeof</span> <span class="ruby-identifier">varBase</span>.<span class="ruby-identifier">hasProperties</span> <span class="ruby-operator">===</span> <span class="ruby-string">&quot;function&quot;</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">varBase</span>.<span class="ruby-identifier">hasProperties</span>() <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>)) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">param</span>) {
          <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">varBase</span>.<span class="ruby-identifier">value</span>, <span class="ruby-string">&#39;var&#39;</span>);
        } <span class="ruby-keyword">else</span> {
          <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">find</span>(<span class="ruby-identifier">varBase</span>.<span class="ruby-identifier">value</span>);
        }
      }
    }
    <span class="ruby-identifier">val</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>);
    <span class="ruby-identifier">compiledName</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;object&#39;</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">compiledName</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;: &quot;</span>), <span class="ruby-identifier">val</span>);
    }
    <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">compiledName</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">||</span> <span class="ruby-string">&#39;=&#39;</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span>), <span class="ruby-identifier">val</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-constant">LEVEL_LIST</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span>;
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">wrapInBraces</span>(<span class="ruby-identifier">answer</span>);
    }
  };

  <span class="ruby-constant">Assign</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compilePatternMatch</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">acc</span>, <span class="ruby-identifier">assigns</span>, <span class="ruby-identifier">code</span>, <span class="ruby-identifier">expandedIdx</span>, <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">idx</span>, <span class="ruby-identifier">isObject</span>, <span class="ruby-identifier">ivar</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">obj</span>, <span class="ruby-identifier">objects</span>, <span class="ruby-identifier">olen</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">ref5</span>, <span class="ruby-identifier">ref6</span>, <span class="ruby-identifier">ref7</span>, <span class="ruby-identifier">ref8</span>, <span class="ruby-identifier">rest</span>, <span class="ruby-identifier">top</span>, <span class="ruby-identifier">val</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">vvar</span>, <span class="ruby-identifier">vvarText</span>;
    <span class="ruby-identifier">top</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">===</span> <span class="ruby-constant">LEVEL_TOP</span>;
    <span class="ruby-identifier">value</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>;
    <span class="ruby-identifier">objects</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">objects</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">olen</span> = <span class="ruby-identifier">objects</span>.<span class="ruby-identifier">length</span>)) {
      <span class="ruby-identifier">code</span> = <span class="ruby-identifier">value</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">LEVEL_OP</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">wrapInBraces</span>(<span class="ruby-identifier">code</span>);
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">code</span>;
      }
    }
    <span class="ruby-identifier">isObject</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">isObject</span>();
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">top</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">olen</span> <span class="ruby-operator">===</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>((<span class="ruby-identifier">obj</span> = <span class="ruby-identifier">objects</span>[<span class="ruby-value">0</span>]) <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Splat</span>)) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">obj</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Assign</span>) {
        <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">obj</span>, (<span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">variable</span>, <span class="ruby-identifier">idx</span> = <span class="ruby-identifier">ref4</span>.<span class="ruby-identifier">base</span>), <span class="ruby-identifier">obj</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">value</span>;
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">idx</span> = <span class="ruby-identifier">isObject</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">obj</span>[<span class="ruby-string">&quot;this&quot;</span>] <span class="ruby-operator">?</span> <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">properties</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">name</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">obj</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-value">0</span>);
      }
      <span class="ruby-identifier">acc</span> = <span class="ruby-constant">IDENTIFIER</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">idx</span>.<span class="ruby-identifier">unwrap</span>().<span class="ruby-identifier">value</span> <span class="ruby-operator">||</span> <span class="ruby-value">0</span>);
      <span class="ruby-identifier">value</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">value</span>);
      <span class="ruby-identifier">value</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">new</span> (<span class="ruby-identifier">acc</span> <span class="ruby-operator">?</span> <span class="ruby-constant">Access</span> <span class="ruby-operator">:</span> <span class="ruby-constant">Index</span>)(<span class="ruby-identifier">idx</span>));
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">ref5</span> = <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">unwrap</span>().<span class="ruby-identifier">value</span>, <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">RESERVED</span>, <span class="ruby-identifier">ref5</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) {
        <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&quot;assignment to a reserved word: &quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">obj</span>.<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">o</span>)));
      }
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">obj</span>, <span class="ruby-identifier">value</span>, <span class="ruby-identifier">null</span>, {
        <span class="ruby-identifier">param</span><span class="ruby-operator">:</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">param</span>
      }).<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_TOP</span>);
    }
    <span class="ruby-identifier">vvar</span> = <span class="ruby-identifier">value</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>);
    <span class="ruby-identifier">vvarText</span> = <span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">vvar</span>);
    <span class="ruby-identifier">assigns</span> = [];
    <span class="ruby-identifier">expandedIdx</span> = <span class="ruby-keyword">false</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-constant">IDENTIFIER</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">vvarText</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">assigns</span>(<span class="ruby-identifier">vvarText</span>)) {
      <span class="ruby-identifier">assigns</span>.<span class="ruby-identifier">push</span>([<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>((<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;ref&#39;</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span>)].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">slice</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">vvar</span>)));
      <span class="ruby-identifier">vvar</span> = [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">ref</span>)];
      <span class="ruby-identifier">vvarText</span> = <span class="ruby-identifier">ref</span>;
    }
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">objects</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">i</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">j</span>) {
      <span class="ruby-identifier">obj</span> = <span class="ruby-identifier">objects</span>[<span class="ruby-identifier">i</span>];
      <span class="ruby-identifier">idx</span> = <span class="ruby-identifier">i</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">isObject</span>) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">obj</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Assign</span>) {
          <span class="ruby-identifier">ref6</span> = <span class="ruby-identifier">obj</span>, (<span class="ruby-identifier">ref7</span> = <span class="ruby-identifier">ref6</span>.<span class="ruby-identifier">variable</span>, <span class="ruby-identifier">idx</span> = <span class="ruby-identifier">ref7</span>.<span class="ruby-identifier">base</span>), <span class="ruby-identifier">obj</span> = <span class="ruby-identifier">ref6</span>.<span class="ruby-identifier">value</span>;
        } <span class="ruby-keyword">else</span> {
          <span class="ruby-keyword">if</span> (<span class="ruby-identifier">obj</span>.<span class="ruby-identifier">base</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Parens</span>) {
            <span class="ruby-identifier">ref8</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">obj</span>.<span class="ruby-identifier">unwrapAll</span>()).<span class="ruby-identifier">cacheReference</span>(<span class="ruby-identifier">o</span>), <span class="ruby-identifier">obj</span> = <span class="ruby-identifier">ref8</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">idx</span> = <span class="ruby-identifier">ref8</span>[<span class="ruby-value">1</span>];
          } <span class="ruby-keyword">else</span> {
            <span class="ruby-identifier">idx</span> = <span class="ruby-identifier">obj</span>[<span class="ruby-string">&quot;this&quot;</span>] <span class="ruby-operator">?</span> <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">properties</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">name</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">obj</span>;
          }
        }
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">expandedIdx</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">obj</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Splat</span>) {
        <span class="ruby-identifier">name</span> = <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">unwrap</span>().<span class="ruby-identifier">value</span>;
        <span class="ruby-identifier">obj</span> = <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">unwrap</span>();
        <span class="ruby-identifier">val</span> = <span class="ruby-identifier">olen</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &lt;= &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">vvarText</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.length ? &quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">utility</span>(<span class="ruby-string">&#39;slice&#39;</span>, <span class="ruby-identifier">o</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.call(&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">vvarText</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;, &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">i</span>;
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">rest</span> = <span class="ruby-identifier">olen</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>) {
          <span class="ruby-identifier">ivar</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;i&#39;</span>, {
            <span class="ruby-identifier">single</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
          });
          <span class="ruby-identifier">val</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&quot;, &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ivar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">vvarText</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.length - &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">rest</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;) : (&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ivar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;, [])&quot;</span>;
        } <span class="ruby-keyword">else</span> {
          <span class="ruby-identifier">val</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&quot;) : []&quot;</span>;
        }
        <span class="ruby-identifier">val</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">val</span>);
        <span class="ruby-identifier">expandedIdx</span> = <span class="ruby-identifier">ivar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;++&quot;</span>;
      } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">expandedIdx</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">obj</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Expansion</span>) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">rest</span> = <span class="ruby-identifier">olen</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">i</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>) {
          <span class="ruby-keyword">if</span> (<span class="ruby-identifier">rest</span> <span class="ruby-operator">===</span> <span class="ruby-value">1</span>) {
            <span class="ruby-identifier">expandedIdx</span> = <span class="ruby-identifier">vvarText</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.length - 1&quot;</span>;
          } <span class="ruby-keyword">else</span> {
            <span class="ruby-identifier">ivar</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;i&#39;</span>, {
              <span class="ruby-identifier">single</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
            });
            <span class="ruby-identifier">val</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">ivar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">vvarText</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.length - &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">rest</span>);
            <span class="ruby-identifier">expandedIdx</span> = <span class="ruby-identifier">ivar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;++&quot;</span>;
            <span class="ruby-identifier">assigns</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">val</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>));
          }
        }
        <span class="ruby-identifier">continue</span>;
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">name</span> = <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">unwrap</span>().<span class="ruby-identifier">value</span>;
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">obj</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Splat</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">obj</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Expansion</span>) {
          <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&quot;multiple splats/expansions are disallowed in an assignment&quot;</span>);
        }
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">typeof</span> <span class="ruby-identifier">idx</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;number&#39;</span>) {
          <span class="ruby-identifier">idx</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">expandedIdx</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">idx</span>);
          <span class="ruby-identifier">acc</span> = <span class="ruby-keyword">false</span>;
        } <span class="ruby-keyword">else</span> {
          <span class="ruby-identifier">acc</span> = <span class="ruby-identifier">isObject</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">IDENTIFIER</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">idx</span>.<span class="ruby-identifier">unwrap</span>().<span class="ruby-identifier">value</span> <span class="ruby-operator">||</span> <span class="ruby-value">0</span>);
        }
        <span class="ruby-identifier">val</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">vvarText</span>), [<span class="ruby-identifier">new</span> (<span class="ruby-identifier">acc</span> <span class="ruby-operator">?</span> <span class="ruby-constant">Access</span> <span class="ruby-operator">:</span> <span class="ruby-constant">Index</span>)(<span class="ruby-identifier">idx</span>)]);
      }
      <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">name</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">RESERVED</span>, <span class="ruby-identifier">name</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) {
        <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&quot;assignment to a reserved word: &quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">obj</span>.<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">o</span>)));
      }
      <span class="ruby-identifier">assigns</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">obj</span>, <span class="ruby-identifier">val</span>, <span class="ruby-identifier">null</span>, {
        <span class="ruby-identifier">param</span><span class="ruby-operator">:</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">param</span>,
        <span class="ruby-identifier">subpattern</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
      }).<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>));
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">top</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">subpattern</span>)) {
      <span class="ruby-identifier">assigns</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">vvar</span>);
    }
    <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">joinFragmentArrays</span>(<span class="ruby-identifier">assigns</span>, <span class="ruby-string">&#39;, &#39;</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">LEVEL_LIST</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">fragments</span>;
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">wrapInBraces</span>(<span class="ruby-identifier">fragments</span>);
    }
  };

  <span class="ruby-constant">Assign</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileConditional</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">left</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">right</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">cacheReference</span>(<span class="ruby-identifier">o</span>), <span class="ruby-identifier">left</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">right</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">1</span>];
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">left</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">left</span>.<span class="ruby-identifier">base</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Literal</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">left</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&quot;this&quot;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">check</span>(<span class="ruby-identifier">left</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">value</span>)) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&quot;the variable \&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">left</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\&quot; can&#39;t be assigned with &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; because it has not been declared before&quot;</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span>, <span class="ruby-string">&quot;?&quot;</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) {
      <span class="ruby-identifier">o</span>.<span class="ruby-identifier">isExistentialEquals</span> = <span class="ruby-keyword">true</span>;
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">If</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Existence</span>(<span class="ruby-identifier">left</span>), <span class="ruby-identifier">right</span>, {
        <span class="ruby-identifier">type</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;if&#39;</span>
      }).<span class="ruby-identifier">addElse</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">right</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>, <span class="ruby-string">&#39;=&#39;</span>)).<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Op</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">0</span>, <span class="ruby-value">-1</span>), <span class="ruby-identifier">left</span>, <span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">right</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>, <span class="ruby-string">&#39;=&#39;</span>)).<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-constant">LEVEL_LIST</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">fragments</span>;
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">wrapInBraces</span>(<span class="ruby-identifier">fragments</span>);
      }
    }
  };

  <span class="ruby-constant">Assign</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileSpecialMath</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">left</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">right</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">cacheReference</span>(<span class="ruby-identifier">o</span>), <span class="ruby-identifier">left</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">right</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">1</span>];
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">left</span>, <span class="ruby-identifier">new</span> <span class="ruby-constant">Op</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">0</span>, <span class="ruby-value">-1</span>), <span class="ruby-identifier">right</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>)).<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
  };

  <span class="ruby-constant">Assign</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileSplice</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">exclusive</span>, <span class="ruby-identifier">from</span>, <span class="ruby-identifier">fromDecl</span>, <span class="ruby-identifier">fromRef</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">ref5</span>, <span class="ruby-identifier">to</span>, <span class="ruby-identifier">valDef</span>, <span class="ruby-identifier">valRef</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">pop</span>().<span class="ruby-identifier">range</span>, <span class="ruby-identifier">from</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">from</span>, <span class="ruby-identifier">to</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">to</span>, <span class="ruby-identifier">exclusive</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">exclusive</span>;
    <span class="ruby-identifier">name</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">variable</span>.<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">o</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">from</span>) {
      <span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">cacheToCodeFragments</span>(<span class="ruby-identifier">from</span>.<span class="ruby-identifier">cache</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_OP</span>)), <span class="ruby-identifier">fromDecl</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">fromRef</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">1</span>];
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">fromDecl</span> = <span class="ruby-identifier">fromRef</span> = <span class="ruby-string">&#39;0&#39;</span>;
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">to</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">from</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">from</span>.<span class="ruby-identifier">isSimpleNumber</span>() <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">to</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">to</span>.<span class="ruby-identifier">isSimpleNumber</span>()) {
        <span class="ruby-identifier">to</span> = <span class="ruby-identifier">to</span>.<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">o</span>) <span class="ruby-operator">-</span> <span class="ruby-identifier">fromRef</span>;
        <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">exclusive</span>) {
          <span class="ruby-identifier">to</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>;
        }
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">to</span> = <span class="ruby-identifier">to</span>.<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_ACCESS</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&#39; - &#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">fromRef</span>;
        <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">exclusive</span>) {
          <span class="ruby-identifier">to</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&#39; + 1&#39;</span>;
        }
      }
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">to</span> = <span class="ruby-string">&quot;9e9&quot;</span>;
    }
    <span class="ruby-identifier">ref5</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">cache</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>), <span class="ruby-identifier">valDef</span> = <span class="ruby-identifier">ref5</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">valRef</span> = <span class="ruby-identifier">ref5</span>[<span class="ruby-value">1</span>];
    <span class="ruby-identifier">answer</span> = [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;[].splice.apply(&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;, [&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">fromDecl</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;, &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">to</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;].concat(&quot;</span>), <span class="ruby-identifier">valDef</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;)), &quot;</span>), <span class="ruby-identifier">valRef</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">&gt;</span> <span class="ruby-constant">LEVEL_TOP</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">wrapInBraces</span>(<span class="ruby-identifier">answer</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span>;
    }
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Assign</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Code</span> = <span class="ruby-constant">Code</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Code</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Code</span>(<span class="ruby-identifier">params</span>, <span class="ruby-identifier">body</span>, <span class="ruby-identifier">tag</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">params</span> = <span class="ruby-identifier">params</span> <span class="ruby-operator">||</span> [];
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span> = <span class="ruby-identifier">body</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Block</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">bound</span> = <span class="ruby-identifier">tag</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;boundfunc&#39;</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isGenerator</span> = <span class="ruby-operator">!</span><span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">contains</span>(<span class="ruby-identifier">function</span>(<span class="ruby-identifier">node</span>) {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref3</span>;
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Op</span> <span class="ruby-operator">&amp;&amp;</span> ((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">operator</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;yield&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;yield*&#39;</span>);
    });
  }

  <span class="ruby-constant">Code</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;params&#39;</span>, <span class="ruby-string">&#39;body&#39;</span>];

  <span class="ruby-constant">Code</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isStatement</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span>;
  };

  <span class="ruby-constant">Code</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">jumps</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Code</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">makeScope</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">parentScope</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Scope</span>(<span class="ruby-identifier">parentScope</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>, <span class="ruby-identifier">this</span>);
  };

  <span class="ruby-constant">Code</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">boundfunc</span>, <span class="ruby-identifier">code</span>, <span class="ruby-identifier">exprs</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">k</span>, <span class="ruby-identifier">l</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">len2</span>, <span class="ruby-identifier">len3</span>, <span class="ruby-identifier">len4</span>, <span class="ruby-identifier">len5</span>, <span class="ruby-identifier">len6</span>, <span class="ruby-identifier">lit</span>, <span class="ruby-identifier">m</span>, <span class="ruby-identifier">p</span>, <span class="ruby-identifier">param</span>, <span class="ruby-identifier">params</span>, <span class="ruby-identifier">q</span>, <span class="ruby-identifier">r</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">ref5</span>, <span class="ruby-identifier">ref6</span>, <span class="ruby-identifier">ref7</span>, <span class="ruby-identifier">ref8</span>, <span class="ruby-identifier">splats</span>, <span class="ruby-identifier">uniqs</span>, <span class="ruby-identifier">val</span>, <span class="ruby-identifier">wasEmpty</span>, <span class="ruby-identifier">wrapper</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">bound</span> <span class="ruby-operator">&amp;&amp;</span> ((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">method</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">bound</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>)) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">method</span>.<span class="ruby-identifier">context</span>;
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">bound</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span> = <span class="ruby-string">&#39;_this&#39;</span>;
      <span class="ruby-identifier">wrapper</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Code</span>([<span class="ruby-identifier">new</span> <span class="ruby-constant">Param</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">context</span>))], <span class="ruby-identifier">new</span> <span class="ruby-constant">Block</span>([<span class="ruby-identifier">this</span>]));
      <span class="ruby-identifier">boundfunc</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Call</span>(<span class="ruby-identifier">wrapper</span>, [<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&#39;this&#39;</span>)]);
      <span class="ruby-identifier">boundfunc</span>.<span class="ruby-identifier">updateLocationDataIfMissing</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">locationData</span>);
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">boundfunc</span>.<span class="ruby-identifier">compileNode</span>(<span class="ruby-identifier">o</span>);
    }
    <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span> = <span class="ruby-identifier">del</span>(<span class="ruby-identifier">o</span>, <span class="ruby-string">&#39;classScope&#39;</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeScope</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>);
    <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">shared</span> = <span class="ruby-identifier">del</span>(<span class="ruby-identifier">o</span>, <span class="ruby-string">&#39;sharedScope&#39;</span>);
    <span class="ruby-identifier">o</span>.<span class="ruby-identifier">indent</span> <span class="ruby-operator">+=</span> <span class="ruby-constant">TAB</span>;
    <span class="ruby-identifier">delete</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">bare</span>;
    <span class="ruby-identifier">delete</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">isExistentialEquals</span>;
    <span class="ruby-identifier">params</span> = [];
    <span class="ruby-identifier">exprs</span> = [];
    <span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">params</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref4</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">param</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">param</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Expansion</span>)) {
        <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">parameter</span>(<span class="ruby-identifier">param</span>.<span class="ruby-identifier">asReference</span>(<span class="ruby-identifier">o</span>));
      }
    }
    <span class="ruby-identifier">ref5</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">params</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len2</span> = <span class="ruby-identifier">ref5</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">k</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len2</span>; <span class="ruby-identifier">k</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">param</span> = <span class="ruby-identifier">ref5</span>[<span class="ruby-identifier">k</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">param</span>.<span class="ruby-identifier">splat</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">param</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Expansion</span>)) {
        <span class="ruby-identifier">continue</span>;
      }
      <span class="ruby-identifier">ref6</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">params</span>;
      <span class="ruby-keyword">for</span> (<span class="ruby-identifier">l</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len3</span> = <span class="ruby-identifier">ref6</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">l</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len3</span>; <span class="ruby-identifier">l</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
        <span class="ruby-identifier">p</span> = <span class="ruby-identifier">ref6</span>[<span class="ruby-identifier">l</span>];
        <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">p</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Expansion</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">p</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">value</span>) {
          <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">add</span>(<span class="ruby-identifier">p</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">value</span>, <span class="ruby-string">&#39;var&#39;</span>, <span class="ruby-keyword">true</span>);
        }
      }
      <span class="ruby-identifier">splats</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Arr</span>((<span class="ruby-identifier">function</span>() {
        <span class="ruby-identifier">var</span> <span class="ruby-identifier">len4</span>, <span class="ruby-identifier">m</span>, <span class="ruby-identifier">ref7</span>, <span class="ruby-identifier">results</span>;
        <span class="ruby-identifier">ref7</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">params</span>;
        <span class="ruby-identifier">results</span> = [];
        <span class="ruby-keyword">for</span> (<span class="ruby-identifier">m</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len4</span> = <span class="ruby-identifier">ref7</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">m</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len4</span>; <span class="ruby-identifier">m</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
          <span class="ruby-identifier">p</span> = <span class="ruby-identifier">ref7</span>[<span class="ruby-identifier">m</span>];
          <span class="ruby-identifier">results</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">p</span>.<span class="ruby-identifier">asReference</span>(<span class="ruby-identifier">o</span>));
        }
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">results</span>;
      }).<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>))), <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&#39;arguments&#39;</span>)));
      <span class="ruby-keyword">break</span>;
    }
    <span class="ruby-identifier">ref7</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">params</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">m</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len4</span> = <span class="ruby-identifier">ref7</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">m</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len4</span>; <span class="ruby-identifier">m</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">param</span> = <span class="ruby-identifier">ref7</span>[<span class="ruby-identifier">m</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">param</span>.<span class="ruby-identifier">isComplex</span>()) {
        <span class="ruby-identifier">val</span> = <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">param</span>.<span class="ruby-identifier">asReference</span>(<span class="ruby-identifier">o</span>);
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">param</span>.<span class="ruby-identifier">value</span>) {
          <span class="ruby-identifier">val</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Op</span>(<span class="ruby-string">&#39;?&#39;</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">param</span>.<span class="ruby-identifier">value</span>);
        }
        <span class="ruby-identifier">exprs</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">param</span>.<span class="ruby-identifier">name</span>), <span class="ruby-identifier">val</span>, <span class="ruby-string">&#39;=&#39;</span>, {
          <span class="ruby-identifier">param</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
        }));
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">param</span>;
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">param</span>.<span class="ruby-identifier">value</span>) {
          <span class="ruby-identifier">lit</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">ref</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39; == null&#39;</span>);
          <span class="ruby-identifier">val</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">param</span>.<span class="ruby-identifier">name</span>), <span class="ruby-identifier">param</span>.<span class="ruby-identifier">value</span>, <span class="ruby-string">&#39;=&#39;</span>);
          <span class="ruby-identifier">exprs</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">If</span>(<span class="ruby-identifier">lit</span>, <span class="ruby-identifier">val</span>));
        }
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">splats</span>) {
        <span class="ruby-identifier">params</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">ref</span>);
      }
    }
    <span class="ruby-identifier">wasEmpty</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">isEmpty</span>();
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">splats</span>) {
      <span class="ruby-identifier">exprs</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">splats</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">exprs</span>.<span class="ruby-identifier">length</span>) {
      (<span class="ruby-identifier">ref8</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">expressions</span>).<span class="ruby-identifier">unshift</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">ref8</span>, <span class="ruby-identifier">exprs</span>);
    }
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-identifier">q</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len5</span> = <span class="ruby-identifier">params</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">q</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len5</span>; <span class="ruby-identifier">i</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">q</span>) {
      <span class="ruby-identifier">p</span> = <span class="ruby-identifier">params</span>[<span class="ruby-identifier">i</span>];
      <span class="ruby-identifier">params</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">p</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
      <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">parameter</span>(<span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">params</span>[<span class="ruby-identifier">i</span>]));
    }
    <span class="ruby-identifier">uniqs</span> = [];
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">eachParamName</span>(<span class="ruby-identifier">function</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">node</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">uniqs</span>, <span class="ruby-identifier">name</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) {
        <span class="ruby-identifier">node</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&quot;multiple parameters named &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">name</span>);
      }
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">uniqs</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">name</span>);
    });
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">wasEmpty</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">noReturn</span>)) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">makeReturn</span>();
    }
    <span class="ruby-identifier">code</span> = <span class="ruby-string">&#39;function&#39;</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">isGenerator</span>) {
      <span class="ruby-identifier">code</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&#39;*&#39;</span>;
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span>) {
      <span class="ruby-identifier">code</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&#39; &#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>;
    }
    <span class="ruby-identifier">code</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&#39;(&#39;</span>;
    <span class="ruby-identifier">answer</span> = [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">code</span>)];
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-identifier">r</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len6</span> = <span class="ruby-identifier">params</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">r</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len6</span>; <span class="ruby-identifier">i</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">r</span>) {
      <span class="ruby-identifier">p</span> = <span class="ruby-identifier">params</span>[<span class="ruby-identifier">i</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i</span>) {
        <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;, &quot;</span>));
      }
      <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">answer</span>, <span class="ruby-identifier">p</span>);
    }
    <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39;) {&#39;</span>));
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">isEmpty</span>()) {
      <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">compileWithDeclarations</span>(<span class="ruby-identifier">o</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span>));
    }
    <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39;}&#39;</span>));
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">ctor</span>) {
      <span class="ruby-keyword">return</span> [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span>)].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">slice</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">answer</span>));
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">front</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">LEVEL_ACCESS</span>)) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">wrapInBraces</span>(<span class="ruby-identifier">answer</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span>;
    }
  };

  <span class="ruby-constant">Code</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">eachParamName</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">iterator</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">param</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">results</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">params</span>;
    <span class="ruby-identifier">results</span> = [];
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">param</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-identifier">results</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">param</span>.<span class="ruby-identifier">eachName</span>(<span class="ruby-identifier">iterator</span>));
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">results</span>;
  };

  <span class="ruby-constant">Code</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">traverseChildren</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">crossScope</span>, <span class="ruby-identifier">func</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">crossScope</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-constant">Code</span>.<span class="ruby-identifier">__super__</span>.<span class="ruby-identifier">traverseChildren</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">crossScope</span>, <span class="ruby-identifier">func</span>);
    }
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Code</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Param</span> = <span class="ruby-constant">Param</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Param</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Param</span>(<span class="ruby-identifier">name1</span>, <span class="ruby-identifier">value1</span>, <span class="ruby-identifier">splat</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">name</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span> = <span class="ruby-identifier">name1</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">value</span> = <span class="ruby-identifier">value1</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">splat</span> = <span class="ruby-identifier">splat</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">ref3</span> = (<span class="ruby-identifier">name</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">unwrapAll</span>().<span class="ruby-identifier">value</span>), <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">STRICT_PROSCRIBED</span>, <span class="ruby-identifier">ref3</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&quot;parameter name \&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\&quot; is not allowed&quot;</span>);
    }
  }

  <span class="ruby-constant">Param</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;name&#39;</span>, <span class="ruby-string">&#39;value&#39;</span>];

  <span class="ruby-constant">Param</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileToFragments</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>);
  };

  <span class="ruby-constant">Param</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">asReference</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">name</span>, <span class="ruby-identifier">node</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">reference</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">reference</span>;
    }
    <span class="ruby-identifier">node</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">node</span>[<span class="ruby-string">&quot;this&quot;</span>]) {
      <span class="ruby-identifier">name</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">properties</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">name</span>.<span class="ruby-identifier">value</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">name</span>.<span class="ruby-identifier">reserved</span>) {
        <span class="ruby-identifier">name</span> = <span class="ruby-string">&quot;_&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">name</span>;
      }
      <span class="ruby-identifier">node</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-identifier">name</span>));
    } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">node</span>.<span class="ruby-identifier">isComplex</span>()) {
      <span class="ruby-identifier">node</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;arg&#39;</span>));
    }
    <span class="ruby-identifier">node</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">node</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">splat</span>) {
      <span class="ruby-identifier">node</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Splat</span>(<span class="ruby-identifier">node</span>);
    }
    <span class="ruby-identifier">node</span>.<span class="ruby-identifier">updateLocationDataIfMissing</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">locationData</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">reference</span> = <span class="ruby-identifier">node</span>;
  };

  <span class="ruby-constant">Param</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isComplex</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">isComplex</span>();
  };

  <span class="ruby-constant">Param</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">eachName</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">iterator</span>, <span class="ruby-identifier">name</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">atParam</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">node</span>, <span class="ruby-identifier">obj</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">name</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
      <span class="ruby-identifier">name</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>;
    }
    <span class="ruby-identifier">atParam</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">obj</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">iterator</span>(<span class="ruby-string">&quot;@&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">properties</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">name</span>.<span class="ruby-identifier">value</span>, <span class="ruby-identifier">obj</span>);
    };
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">name</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Literal</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">iterator</span>(<span class="ruby-identifier">name</span>.<span class="ruby-identifier">value</span>, <span class="ruby-identifier">name</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">name</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">atParam</span>(<span class="ruby-identifier">name</span>);
    }
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">name</span>.<span class="ruby-identifier">objects</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">obj</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">obj</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Assign</span>) {
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">eachName</span>(<span class="ruby-identifier">iterator</span>, <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">unwrap</span>());
      } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">obj</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Splat</span>) {
        <span class="ruby-identifier">node</span> = <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">unwrap</span>();
        <span class="ruby-identifier">iterator</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span>, <span class="ruby-identifier">node</span>);
      } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">obj</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span>) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">obj</span>.<span class="ruby-identifier">isArray</span>() <span class="ruby-operator">||</span> <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">isObject</span>()) {
          <span class="ruby-identifier">this</span>.<span class="ruby-identifier">eachName</span>(<span class="ruby-identifier">iterator</span>, <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">base</span>);
        } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">obj</span>[<span class="ruby-string">&quot;this&quot;</span>]) {
          <span class="ruby-identifier">atParam</span>(<span class="ruby-identifier">obj</span>);
        } <span class="ruby-keyword">else</span> {
          <span class="ruby-identifier">iterator</span>(<span class="ruby-identifier">obj</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">value</span>, <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">base</span>);
        }
      } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">obj</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Expansion</span>)) {
        <span class="ruby-identifier">obj</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&quot;illegal parameter &quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">obj</span>.<span class="ruby-identifier">compile</span>()));
      }
    }
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Param</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Splat</span> = <span class="ruby-constant">Splat</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Splat</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-constant">Splat</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;name&#39;</span>];

  <span class="ruby-constant">Splat</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isAssignable</span> = <span class="ruby-constant">YES</span>;

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Splat</span>(<span class="ruby-identifier">name</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span> = <span class="ruby-identifier">name</span>.<span class="ruby-identifier">compile</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">name</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">name</span>);
  }

  <span class="ruby-constant">Splat</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">assigns</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">name</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">assigns</span>(<span class="ruby-identifier">name</span>);
  };

  <span class="ruby-constant">Splat</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileToFragments</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
  };

  <span class="ruby-constant">Splat</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">unwrap</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>;
  };

  <span class="ruby-constant">Splat</span>.<span class="ruby-identifier">compileSplattedArray</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">list</span>, <span class="ruby-identifier">apply</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">args</span>, <span class="ruby-identifier">base</span>, <span class="ruby-identifier">compiledNode</span>, <span class="ruby-identifier">concatPart</span>, <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">index</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">last</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">node</span>;
    <span class="ruby-identifier">index</span> = <span class="ruby-value">-1</span>;
    <span class="ruby-keyword">while</span> ((<span class="ruby-identifier">node</span> = <span class="ruby-identifier">list</span>[<span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">index</span>]) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Splat</span>)) {
      <span class="ruby-identifier">continue</span>;
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">index</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-identifier">list</span>.<span class="ruby-identifier">length</span>) {
      <span class="ruby-keyword">return</span> [];
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">list</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">===</span> <span class="ruby-value">1</span>) {
      <span class="ruby-identifier">node</span> = <span class="ruby-identifier">list</span>[<span class="ruby-value">0</span>];
      <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>);
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">apply</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">fragments</span>;
      }
      <span class="ruby-keyword">return</span> [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">makeCode</span>((<span class="ruby-identifier">utility</span>(<span class="ruby-string">&#39;slice&#39;</span>, <span class="ruby-identifier">o</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.call(&quot;</span>), <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">node</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;)&quot;</span>));
    }
    <span class="ruby-identifier">args</span> = <span class="ruby-identifier">list</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-identifier">index</span>);
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">args</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">i</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">j</span>) {
      <span class="ruby-identifier">node</span> = <span class="ruby-identifier">args</span>[<span class="ruby-identifier">i</span>];
      <span class="ruby-identifier">compiledNode</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>);
      <span class="ruby-identifier">args</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Splat</span> <span class="ruby-operator">?</span> [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">makeCode</span>((<span class="ruby-identifier">utility</span>(<span class="ruby-string">&#39;slice&#39;</span>, <span class="ruby-identifier">o</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.call(&quot;</span>), <span class="ruby-identifier">compiledNode</span>, <span class="ruby-identifier">node</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;)&quot;</span>)) <span class="ruby-operator">:</span> [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;[&quot;</span>), <span class="ruby-identifier">compiledNode</span>, <span class="ruby-identifier">node</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;]&quot;</span>));
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">index</span> <span class="ruby-operator">===</span> <span class="ruby-value">0</span>) {
      <span class="ruby-identifier">node</span> = <span class="ruby-identifier">list</span>[<span class="ruby-value">0</span>];
      <span class="ruby-identifier">concatPart</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">joinFragmentArrays</span>(<span class="ruby-identifier">args</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">1</span>), <span class="ruby-string">&#39;, &#39;</span>);
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">args</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;.concat(&quot;</span>), <span class="ruby-identifier">concatPart</span>, <span class="ruby-identifier">node</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;)&quot;</span>));
    }
    <span class="ruby-identifier">base</span> = (<span class="ruby-identifier">function</span>() {
      <span class="ruby-identifier">var</span> <span class="ruby-identifier">k</span>, <span class="ruby-identifier">len2</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">results</span>;
      <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">list</span>.<span class="ruby-identifier">slice</span>(<span class="ruby-value">0</span>, <span class="ruby-identifier">index</span>);
      <span class="ruby-identifier">results</span> = [];
      <span class="ruby-keyword">for</span> (<span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len2</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">k</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len2</span>; <span class="ruby-identifier">k</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
        <span class="ruby-identifier">node</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">k</span>];
        <span class="ruby-identifier">results</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">node</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>));
      }
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">results</span>;
    })();
    <span class="ruby-identifier">base</span> = <span class="ruby-identifier">list</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">joinFragmentArrays</span>(<span class="ruby-identifier">base</span>, <span class="ruby-string">&#39;, &#39;</span>);
    <span class="ruby-identifier">concatPart</span> = <span class="ruby-identifier">list</span>[<span class="ruby-identifier">index</span>].<span class="ruby-identifier">joinFragmentArrays</span>(<span class="ruby-identifier">args</span>, <span class="ruby-string">&#39;, &#39;</span>);
    <span class="ruby-identifier">last</span> = <span class="ruby-identifier">list</span>[<span class="ruby-identifier">list</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>];
    <span class="ruby-keyword">return</span> [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">list</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;[&quot;</span>), <span class="ruby-identifier">base</span>, <span class="ruby-identifier">list</span>[<span class="ruby-identifier">index</span>].<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;].concat(&quot;</span>), <span class="ruby-identifier">concatPart</span>, <span class="ruby-identifier">last</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;)&quot;</span>));
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Splat</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Expansion</span> = <span class="ruby-constant">Expansion</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Expansion</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Expansion</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-constant">Expansion</span>.<span class="ruby-identifier">__super__</span>.<span class="ruby-identifier">constructor</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">arguments</span>);
  }

  <span class="ruby-constant">Expansion</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isComplex</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Expansion</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&#39;Expansion must be used inside a destructuring assignment or parameter list&#39;</span>);
  };

  <span class="ruby-constant">Expansion</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">asReference</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  };

  <span class="ruby-constant">Expansion</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">eachName</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">iterator</span>) {};

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Expansion</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">While</span> = <span class="ruby-constant">While</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">While</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">While</span>(<span class="ruby-identifier">condition</span>, <span class="ruby-identifier">options</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">condition</span> = (<span class="ruby-identifier">options</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">invert</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">?</span> <span class="ruby-identifier">condition</span>.<span class="ruby-identifier">invert</span>() <span class="ruby-operator">:</span> <span class="ruby-identifier">condition</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">guard</span> = <span class="ruby-identifier">options</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">guard</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>;
  }

  <span class="ruby-constant">While</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;condition&#39;</span>, <span class="ruby-string">&#39;guard&#39;</span>, <span class="ruby-string">&#39;body&#39;</span>];

  <span class="ruby-constant">While</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isStatement</span> = <span class="ruby-constant">YES</span>;

  <span class="ruby-constant">While</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">makeReturn</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">res</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">res</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-constant">While</span>.<span class="ruby-identifier">__super__</span>.<span class="ruby-identifier">makeReturn</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">arguments</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">returns</span> = <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">jumps</span>({
        <span class="ruby-identifier">loop</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
      });
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
    }
  };

  <span class="ruby-constant">While</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">addBody</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">body1</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span> = <span class="ruby-identifier">body1</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  };

  <span class="ruby-constant">While</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">jumps</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">expressions</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">jumpNode</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">node</span>;
    <span class="ruby-identifier">expressions</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">expressions</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">length</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
    }
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">node</span> = <span class="ruby-identifier">expressions</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">jumpNode</span> = <span class="ruby-identifier">node</span>.<span class="ruby-identifier">jumps</span>({
        <span class="ruby-identifier">loop</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
      })) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">jumpNode</span>;
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-keyword">false</span>;
  };

  <span class="ruby-constant">While</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">body</span>, <span class="ruby-identifier">rvar</span>, <span class="ruby-identifier">set</span>;
    <span class="ruby-identifier">o</span>.<span class="ruby-identifier">indent</span> <span class="ruby-operator">+=</span> <span class="ruby-constant">TAB</span>;
    <span class="ruby-identifier">set</span> = <span class="ruby-string">&#39;&#39;</span>;
    <span class="ruby-identifier">body</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">body</span>.<span class="ruby-identifier">isEmpty</span>()) {
      <span class="ruby-identifier">body</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39;&#39;</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">returns</span>) {
        <span class="ruby-identifier">body</span>.<span class="ruby-identifier">makeReturn</span>(<span class="ruby-identifier">rvar</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;results&#39;</span>));
        <span class="ruby-identifier">set</span> = <span class="ruby-string">&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">rvar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = [];\n&quot;</span>;
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">guard</span>) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">body</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>) {
          <span class="ruby-identifier">body</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">If</span>((<span class="ruby-identifier">new</span> <span class="ruby-constant">Parens</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">guard</span>)).<span class="ruby-identifier">invert</span>(), <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&quot;continue&quot;</span>)));
        } <span class="ruby-keyword">else</span> {
          <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">guard</span>) {
            <span class="ruby-identifier">body</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">wrap</span>([<span class="ruby-identifier">new</span> <span class="ruby-constant">If</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">guard</span>, <span class="ruby-identifier">body</span>)]);
          }
        }
      }
      <span class="ruby-identifier">body</span> = [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span>), <span class="ruby-identifier">body</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_TOP</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span>));
    }
    <span class="ruby-identifier">answer</span> = [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">set</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;while (&quot;</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">condition</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_PAREN</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;) {&quot;</span>), <span class="ruby-identifier">body</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;}&quot;</span>));
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">returns</span>) {
      <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;return &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">rvar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;;&quot;</span>));
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span>;
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">While</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Op</span> = <span class="ruby-constant">Op</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-constant">CONVERSIONS</span>, <span class="ruby-constant">INVERSIONS</span>;

  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Op</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Op</span>(<span class="ruby-identifier">op</span>, <span class="ruby-identifier">first</span>, <span class="ruby-identifier">second</span>, <span class="ruby-identifier">flip</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">op</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;in&#39;</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">In</span>(<span class="ruby-identifier">first</span>, <span class="ruby-identifier">second</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">op</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;do&#39;</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">generateDo</span>(<span class="ruby-identifier">first</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">op</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;new&#39;</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">first</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Call</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">first</span>[<span class="ruby-string">&quot;do&quot;</span>] <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">first</span>.<span class="ruby-identifier">isNew</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">first</span>.<span class="ruby-identifier">newInstance</span>();
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">first</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Code</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">first</span>.<span class="ruby-identifier">bound</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">first</span>[<span class="ruby-string">&quot;do&quot;</span>]) {
        <span class="ruby-identifier">first</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Parens</span>(<span class="ruby-identifier">first</span>);
      }
    }
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span> = <span class="ruby-constant">CONVERSIONS</span>[<span class="ruby-identifier">op</span>] <span class="ruby-operator">||</span> <span class="ruby-identifier">op</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span> = <span class="ruby-identifier">first</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">second</span> = <span class="ruby-identifier">second</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">flip</span> = <span class="ruby-operator">!</span><span class="ruby-operator">!</span><span class="ruby-identifier">flip</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  }

  <span class="ruby-constant">CONVERSIONS</span> = {
    <span class="ruby-string">&#39;==&#39;</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;===&#39;</span>,
    <span class="ruby-string">&#39;!=&#39;</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;!==&#39;</span>,
    <span class="ruby-string">&#39;of&#39;</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;in&#39;</span>,
    <span class="ruby-string">&#39;yieldfrom&#39;</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;yield*&#39;</span>
  };

  <span class="ruby-constant">INVERSIONS</span> = {
    <span class="ruby-string">&#39;!==&#39;</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;===&#39;</span>,
    <span class="ruby-string">&#39;===&#39;</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;!==&#39;</span>
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;first&#39;</span>, <span class="ruby-string">&#39;second&#39;</span>];

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isSimpleNumber</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isYield</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref3</span>;
    <span class="ruby-keyword">return</span> (<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;yield&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;yield*&#39;</span>;
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isYieldReturn</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isYield</span>() <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Return</span>;
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isUnary</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">second</span>;
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isComplex</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref3</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">isUnary</span>() <span class="ruby-operator">&amp;&amp;</span> ((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;+&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;-&#39;</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">isSimpleNumber</span>());
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isChainable</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref3</span>;
    <span class="ruby-keyword">return</span> (<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;&lt;&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;&gt;&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;&gt;=&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;&lt;=&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;===&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;!==&#39;</span>;
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">invert</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">allInvertable</span>, <span class="ruby-identifier">curr</span>, <span class="ruby-identifier">fst</span>, <span class="ruby-identifier">op</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">isChainable</span>() <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">isChainable</span>()) {
      <span class="ruby-identifier">allInvertable</span> = <span class="ruby-keyword">true</span>;
      <span class="ruby-identifier">curr</span> = <span class="ruby-identifier">this</span>;
      <span class="ruby-keyword">while</span> (<span class="ruby-identifier">curr</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">curr</span>.<span class="ruby-identifier">operator</span>) {
        <span class="ruby-identifier">allInvertable</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">allInvertable</span> = <span class="ruby-identifier">curr</span>.<span class="ruby-identifier">operator</span> <span class="ruby-keyword">in</span> <span class="ruby-constant">INVERSIONS</span>);
        <span class="ruby-identifier">curr</span> = <span class="ruby-identifier">curr</span>.<span class="ruby-identifier">first</span>;
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">allInvertable</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Parens</span>(<span class="ruby-identifier">this</span>).<span class="ruby-identifier">invert</span>();
      }
      <span class="ruby-identifier">curr</span> = <span class="ruby-identifier">this</span>;
      <span class="ruby-keyword">while</span> (<span class="ruby-identifier">curr</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">curr</span>.<span class="ruby-identifier">operator</span>) {
        <span class="ruby-identifier">curr</span>.<span class="ruby-identifier">invert</span> = <span class="ruby-operator">!</span><span class="ruby-identifier">curr</span>.<span class="ruby-identifier">invert</span>;
        <span class="ruby-identifier">curr</span>.<span class="ruby-identifier">operator</span> = <span class="ruby-constant">INVERSIONS</span>[<span class="ruby-identifier">curr</span>.<span class="ruby-identifier">operator</span>];
        <span class="ruby-identifier">curr</span> = <span class="ruby-identifier">curr</span>.<span class="ruby-identifier">first</span>;
      }
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
    } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">op</span> = <span class="ruby-constant">INVERSIONS</span>[<span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span>]) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span> = <span class="ruby-identifier">op</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">unwrap</span>() <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Op</span>) {
        <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">invert</span>();
      }
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
    } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">second</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Parens</span>(<span class="ruby-identifier">this</span>).<span class="ruby-identifier">invert</span>();
    } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;!&#39;</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">fst</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">unwrap</span>()) <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Op</span> <span class="ruby-operator">&amp;&amp;</span> ((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">fst</span>.<span class="ruby-identifier">operator</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;!&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;in&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;instanceof&#39;</span>)) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">fst</span>;
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Op</span>(<span class="ruby-string">&#39;!&#39;</span>, <span class="ruby-identifier">this</span>);
    }
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">unfoldSoak</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref3</span>;
    <span class="ruby-keyword">return</span> ((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;++&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;--&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;delete&#39;</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">unfoldSoak</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">this</span>, <span class="ruby-string">&#39;first&#39;</span>);
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">generateDo</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">exp</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">call</span>, <span class="ruby-identifier">func</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">param</span>, <span class="ruby-identifier">passedParams</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">passedParams</span> = [];
    <span class="ruby-identifier">func</span> = <span class="ruby-identifier">exp</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Assign</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">exp</span>.<span class="ruby-identifier">value</span>.<span class="ruby-identifier">unwrap</span>()) <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Code</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">exp</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">func</span>.<span class="ruby-identifier">params</span> <span class="ruby-operator">||</span> [];
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">param</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">param</span>.<span class="ruby-identifier">value</span>) {
        <span class="ruby-identifier">passedParams</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">param</span>.<span class="ruby-identifier">value</span>);
        <span class="ruby-identifier">delete</span> <span class="ruby-identifier">param</span>.<span class="ruby-identifier">value</span>;
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">passedParams</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">param</span>);
      }
    }
    <span class="ruby-identifier">call</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Call</span>(<span class="ruby-identifier">exp</span>, <span class="ruby-identifier">passedParams</span>);
    <span class="ruby-identifier">call</span>[<span class="ruby-string">&quot;do&quot;</span>] = <span class="ruby-keyword">true</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">call</span>;
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">isChain</span>, <span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">rhs</span>;
    <span class="ruby-identifier">isChain</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isChainable</span>() <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">isChainable</span>();
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">isChain</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">front</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">front</span>;
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;delete&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">check</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">unwrapAll</span>().<span class="ruby-identifier">value</span>)) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&#39;delete operand may not be argument or var&#39;</span>);
    }
    <span class="ruby-keyword">if</span> (((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;--&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref3</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;++&#39;</span>) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">unwrapAll</span>().<span class="ruby-identifier">value</span>, <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">STRICT_PROSCRIBED</span>, <span class="ruby-identifier">ref4</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>)) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&quot;cannot increment/decrement \&quot;&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">unwrapAll</span>().<span class="ruby-identifier">value</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\&quot;&quot;</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">isYield</span>()) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileYield</span>(<span class="ruby-identifier">o</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">isUnary</span>()) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileUnary</span>(<span class="ruby-identifier">o</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">isChain</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileChain</span>(<span class="ruby-identifier">o</span>);
    }
    <span class="ruby-identifier">switch</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span>) {
      <span class="ruby-keyword">case</span> <span class="ruby-string">&#39;?&#39;</span><span class="ruby-operator">:</span>
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileExistence</span>(<span class="ruby-identifier">o</span>);
      <span class="ruby-keyword">case</span> <span class="ruby-string">&#39;**&#39;</span><span class="ruby-operator">:</span>
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compilePower</span>(<span class="ruby-identifier">o</span>);
      <span class="ruby-keyword">case</span> <span class="ruby-string">&#39;//&#39;</span><span class="ruby-operator">:</span>
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileFloorDivision</span>(<span class="ruby-identifier">o</span>);
      <span class="ruby-keyword">case</span> <span class="ruby-string">&#39;%%&#39;</span><span class="ruby-operator">:</span>
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileModulo</span>(<span class="ruby-identifier">o</span>);
      <span class="ruby-identifier">default</span><span class="ruby-operator">:</span>
        <span class="ruby-identifier">lhs</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_OP</span>);
        <span class="ruby-identifier">rhs</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">second</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_OP</span>);
        <span class="ruby-identifier">answer</span> = [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">lhs</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span>), <span class="ruby-identifier">rhs</span>);
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-constant">LEVEL_OP</span>) {
          <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span>;
        } <span class="ruby-keyword">else</span> {
          <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">wrapInBraces</span>(<span class="ruby-identifier">answer</span>);
        }
    }
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileChain</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">fst</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">shared</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">second</span>.<span class="ruby-identifier">cache</span>(<span class="ruby-identifier">o</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">second</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">shared</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">1</span>];
    <span class="ruby-identifier">fst</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_OP</span>);
    <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">fst</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">invert</span> <span class="ruby-operator">?</span> <span class="ruby-string">&#39;&amp;&amp;&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&#39;||&#39;</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span>), <span class="ruby-identifier">shared</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">second</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_OP</span>));
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">wrapInBraces</span>(<span class="ruby-identifier">fragments</span>);
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileExistence</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">fst</span>, <span class="ruby-identifier">ref</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">isComplex</span>()) {
      <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;ref&#39;</span>));
      <span class="ruby-identifier">fst</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Parens</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">ref</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>));
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">fst</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>;
      <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">fst</span>;
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">If</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Existence</span>(<span class="ruby-identifier">fst</span>), <span class="ruby-identifier">ref</span>, {
      <span class="ruby-identifier">type</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;if&#39;</span>
    }).<span class="ruby-identifier">addElse</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">second</span>).<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileUnary</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">op</span>, <span class="ruby-identifier">parts</span>, <span class="ruby-identifier">plusMinus</span>;
    <span class="ruby-identifier">parts</span> = [];
    <span class="ruby-identifier">op</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span>;
    <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">push</span>([<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">op</span>)]);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">op</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;!&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Existence</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">negated</span> = <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">negated</span>;
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">LEVEL_ACCESS</span>) {
      <span class="ruby-keyword">return</span> (<span class="ruby-identifier">new</span> <span class="ruby-constant">Parens</span>(<span class="ruby-identifier">this</span>)).<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
    }
    <span class="ruby-identifier">plusMinus</span> = <span class="ruby-identifier">op</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;+&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">op</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;-&#39;</span>;
    <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">op</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;new&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">op</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;typeof&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">op</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;delete&#39;</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">plusMinus</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Op</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">operator</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">op</span>) {
      <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">push</span>([<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39; &#39;</span>)]);
    }
    <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">plusMinus</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Op</span>) <span class="ruby-operator">||</span> (<span class="ruby-identifier">op</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;new&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">isStatement</span>(<span class="ruby-identifier">o</span>))) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Parens</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>);
    }
    <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_OP</span>));
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">flip</span>) {
      <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">reverse</span>();
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">joinFragmentArrays</span>(<span class="ruby-identifier">parts</span>, <span class="ruby-string">&#39;&#39;</span>);
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileYield</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">op</span>, <span class="ruby-identifier">parts</span>;
    <span class="ruby-identifier">parts</span> = [];
    <span class="ruby-identifier">op</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">parent</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&#39;yield statements must occur within a function generator.&#39;</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-constant">Object</span>.<span class="ruby-identifier">keys</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>), <span class="ruby-string">&#39;expression&#39;</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Throw</span>)) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">isYieldReturn</span>()) {
        <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_TOP</span>));
      } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">expression</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span>) {
        <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">expression</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_OP</span>));
      }
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">push</span>([<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;(&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">op</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span>)]);
      <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_OP</span>));
      <span class="ruby-identifier">parts</span>.<span class="ruby-identifier">push</span>([<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;)&quot;</span>)]);
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">joinFragmentArrays</span>(<span class="ruby-identifier">parts</span>, <span class="ruby-string">&#39;&#39;</span>);
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compilePower</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">pow</span>;
    <span class="ruby-identifier">pow</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&#39;Math&#39;</span>), [<span class="ruby-identifier">new</span> <span class="ruby-constant">Access</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&#39;pow&#39;</span>))]);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Call</span>(<span class="ruby-identifier">pow</span>, [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">second</span>]).<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileFloorDivision</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">div</span>, <span class="ruby-identifier">floor</span>;
    <span class="ruby-identifier">floor</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&#39;Math&#39;</span>), [<span class="ruby-identifier">new</span> <span class="ruby-constant">Access</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&#39;floor&#39;</span>))]);
    <span class="ruby-identifier">div</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Op</span>(<span class="ruby-string">&#39;/&#39;</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">second</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Call</span>(<span class="ruby-identifier">floor</span>, [<span class="ruby-identifier">div</span>]).<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileModulo</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">mod</span>;
    <span class="ruby-identifier">mod</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">utility</span>(<span class="ruby-string">&#39;modulo&#39;</span>, <span class="ruby-identifier">o</span>)));
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Call</span>(<span class="ruby-identifier">mod</span>, [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">first</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">second</span>]).<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
  };

  <span class="ruby-constant">Op</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">toString</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">idt</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-constant">Op</span>.<span class="ruby-identifier">__super__</span>.<span class="ruby-identifier">toString</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">idt</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">constructor</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39; &#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">operator</span>);
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Op</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">In</span> = <span class="ruby-constant">In</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">In</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">In</span>(<span class="ruby-identifier">object</span>, <span class="ruby-identifier">array</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">object</span> = <span class="ruby-identifier">object</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">array</span> = <span class="ruby-identifier">array</span>;
  }

  <span class="ruby-constant">In</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;object&#39;</span>, <span class="ruby-string">&#39;array&#39;</span>];

  <span class="ruby-constant">In</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">invert</span> = <span class="ruby-constant">NEGATE</span>;

  <span class="ruby-constant">In</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">hasSplat</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">obj</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">array</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">array</span>.<span class="ruby-identifier">isArray</span>() <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">array</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">objects</span>.<span class="ruby-identifier">length</span>) {
      <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">array</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">objects</span>;
      <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
        <span class="ruby-identifier">obj</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">j</span>];
        <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">obj</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Splat</span>)) {
          <span class="ruby-identifier">continue</span>;
        }
        <span class="ruby-identifier">hasSplat</span> = <span class="ruby-keyword">true</span>;
        <span class="ruby-keyword">break</span>;
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">hasSplat</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileOrTest</span>(<span class="ruby-identifier">o</span>);
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileLoopTest</span>(<span class="ruby-identifier">o</span>);
  };

  <span class="ruby-constant">In</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileOrTest</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">cmp</span>, <span class="ruby-identifier">cnj</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">item</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">ref5</span>, <span class="ruby-identifier">sub</span>, <span class="ruby-identifier">tests</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">object</span>.<span class="ruby-identifier">cache</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_OP</span>), <span class="ruby-identifier">sub</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">1</span>];
    <span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">negated</span> <span class="ruby-operator">?</span> [<span class="ruby-string">&#39; !== &#39;</span>, <span class="ruby-string">&#39; &amp;&amp; &#39;</span>] <span class="ruby-operator">:</span> [<span class="ruby-string">&#39; === &#39;</span>, <span class="ruby-string">&#39; || &#39;</span>], <span class="ruby-identifier">cmp</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">cnj</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">1</span>];
    <span class="ruby-identifier">tests</span> = [];
    <span class="ruby-identifier">ref5</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">array</span>.<span class="ruby-identifier">base</span>.<span class="ruby-identifier">objects</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref5</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">i</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">j</span>) {
      <span class="ruby-identifier">item</span> = <span class="ruby-identifier">ref5</span>[<span class="ruby-identifier">i</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i</span>) {
        <span class="ruby-identifier">tests</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">cnj</span>));
      }
      <span class="ruby-identifier">tests</span> = <span class="ruby-identifier">tests</span>.<span class="ruby-identifier">concat</span>((<span class="ruby-identifier">i</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">sub</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">cmp</span>), <span class="ruby-identifier">item</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_ACCESS</span>));
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">LEVEL_OP</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">tests</span>;
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">wrapInBraces</span>(<span class="ruby-identifier">tests</span>);
    }
  };

  <span class="ruby-constant">In</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileLoopTest</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">sub</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">object</span>.<span class="ruby-identifier">cache</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>), <span class="ruby-identifier">sub</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">1</span>];
    <span class="ruby-identifier">fragments</span> = [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">utility</span>(<span class="ruby-string">&#39;indexOf&#39;</span>, <span class="ruby-identifier">o</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.call(&quot;</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">array</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;, &quot;</span>), <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;) &quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">negated</span> <span class="ruby-operator">?</span> <span class="ruby-string">&#39;&lt; 0&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&#39;&gt;= 0&#39;</span>)));
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">sub</span>) <span class="ruby-operator">===</span> <span class="ruby-identifier">fragmentsToText</span>(<span class="ruby-identifier">ref</span>)) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">fragments</span>;
    }
    <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">sub</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39;, &#39;</span>), <span class="ruby-identifier">fragments</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">LEVEL_LIST</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">fragments</span>;
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">wrapInBraces</span>(<span class="ruby-identifier">fragments</span>);
    }
  };

  <span class="ruby-constant">In</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">toString</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">idt</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-constant">In</span>.<span class="ruby-identifier">__super__</span>.<span class="ruby-identifier">toString</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">idt</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">constructor</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">negated</span> <span class="ruby-operator">?</span> <span class="ruby-string">&#39;!&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&#39;&#39;</span>));
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">In</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Try</span> = <span class="ruby-constant">Try</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Try</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Try</span>(<span class="ruby-identifier">attempt</span>, <span class="ruby-identifier">errorVariable</span>, <span class="ruby-identifier">recovery</span>, <span class="ruby-keyword">ensure</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">attempt</span> = <span class="ruby-identifier">attempt</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">errorVariable</span> = <span class="ruby-identifier">errorVariable</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">recovery</span> = <span class="ruby-identifier">recovery</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ensure</span> = <span class="ruby-keyword">ensure</span>;
  }

  <span class="ruby-constant">Try</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;attempt&#39;</span>, <span class="ruby-string">&#39;recovery&#39;</span>, <span class="ruby-string">&#39;ensure&#39;</span>];

  <span class="ruby-constant">Try</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isStatement</span> = <span class="ruby-constant">YES</span>;

  <span class="ruby-constant">Try</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">jumps</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref3</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">attempt</span>.<span class="ruby-identifier">jumps</span>(<span class="ruby-identifier">o</span>) <span class="ruby-operator">||</span> ((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">recovery</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">jumps</span>(<span class="ruby-identifier">o</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>);
  };

  <span class="ruby-constant">Try</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">makeReturn</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">res</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">attempt</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">attempt</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">attempt</span>.<span class="ruby-identifier">makeReturn</span>(<span class="ruby-identifier">res</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">recovery</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">recovery</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">recovery</span>.<span class="ruby-identifier">makeReturn</span>(<span class="ruby-identifier">res</span>);
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  };

  <span class="ruby-constant">Try</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">catchPart</span>, <span class="ruby-identifier">ensurePart</span>, <span class="ruby-identifier">placeholder</span>, <span class="ruby-identifier">tryPart</span>;
    <span class="ruby-identifier">o</span>.<span class="ruby-identifier">indent</span> <span class="ruby-operator">+=</span> <span class="ruby-constant">TAB</span>;
    <span class="ruby-identifier">tryPart</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">attempt</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_TOP</span>);
    <span class="ruby-identifier">catchPart</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">recovery</span> <span class="ruby-operator">?</span> (<span class="ruby-identifier">placeholder</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&#39;_error&#39;</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">errorVariable</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">recovery</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">errorVariable</span>, <span class="ruby-identifier">placeholder</span>)) <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>, [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot; catch (&quot;</span>), <span class="ruby-identifier">placeholder</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;) {\n&quot;</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">recovery</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_TOP</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;}&quot;</span>))) <span class="ruby-operator">:</span> <span class="ruby-operator">!</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">ensure</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">recovery</span>) <span class="ruby-operator">?</span> [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39; catch (_error) {}&#39;</span>)] <span class="ruby-operator">:</span> [];
    <span class="ruby-identifier">ensurePart</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ensure</span> <span class="ruby-operator">?</span> [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot; finally {\n&quot;</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ensure</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_TOP</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;}&quot;</span>)) <span class="ruby-operator">:</span> [];
    <span class="ruby-keyword">return</span> [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;try {\n&quot;</span>), <span class="ruby-identifier">tryPart</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;}&quot;</span>), <span class="ruby-identifier">catchPart</span>, <span class="ruby-identifier">ensurePart</span>);
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Try</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Throw</span> = <span class="ruby-constant">Throw</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Throw</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Throw</span>(<span class="ruby-identifier">expression</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expression</span> = <span class="ruby-identifier">expression</span>;
  }

  <span class="ruby-constant">Throw</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;expression&#39;</span>];

  <span class="ruby-constant">Throw</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isStatement</span> = <span class="ruby-constant">YES</span>;

  <span class="ruby-constant">Throw</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">jumps</span> = <span class="ruby-constant">NO</span>;

  <span class="ruby-constant">Throw</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">makeReturn</span> = <span class="ruby-constant">THIS</span>;

  <span class="ruby-constant">Throw</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">return</span> [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;throw &quot;</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expression</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;;&quot;</span>));
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Throw</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Existence</span> = <span class="ruby-constant">Existence</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Existence</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Existence</span>(<span class="ruby-identifier">expression</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expression</span> = <span class="ruby-identifier">expression</span>;
  }

  <span class="ruby-constant">Existence</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;expression&#39;</span>];

  <span class="ruby-constant">Existence</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">invert</span> = <span class="ruby-constant">NEGATE</span>;

  <span class="ruby-constant">Existence</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">cmp</span>, <span class="ruby-identifier">cnj</span>, <span class="ruby-identifier">code</span>, <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expression</span>.<span class="ruby-identifier">front</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">front</span>;
    <span class="ruby-identifier">code</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">expression</span>.<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_OP</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-constant">IDENTIFIER</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">code</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">check</span>(<span class="ruby-identifier">code</span>)) {
      <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">negated</span> <span class="ruby-operator">?</span> [<span class="ruby-string">&#39;===&#39;</span>, <span class="ruby-string">&#39;||&#39;</span>] <span class="ruby-operator">:</span> [<span class="ruby-string">&#39;!==&#39;</span>, <span class="ruby-string">&#39;&amp;&amp;&#39;</span>], <span class="ruby-identifier">cmp</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">cnj</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">1</span>];
      <span class="ruby-identifier">code</span> = <span class="ruby-string">&quot;typeof &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">code</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">cmp</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; \&quot;undefined\&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">cnj</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">code</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">cmp</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; null&quot;</span>;
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">code</span> = <span class="ruby-identifier">code</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">negated</span> <span class="ruby-operator">?</span> <span class="ruby-string">&#39;==&#39;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&#39;!=&#39;</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&quot; null&quot;</span>;
    }
    <span class="ruby-keyword">return</span> [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">&lt;=</span> <span class="ruby-constant">LEVEL_COND</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">code</span> <span class="ruby-operator">:</span> <span class="ruby-string">&quot;(&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">code</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;)&quot;</span>)];
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Existence</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Parens</span> = <span class="ruby-constant">Parens</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Parens</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Parens</span>(<span class="ruby-identifier">body1</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span> = <span class="ruby-identifier">body1</span>;
  }

  <span class="ruby-constant">Parens</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;body&#39;</span>];

  <span class="ruby-constant">Parens</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">unwrap</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>;
  };

  <span class="ruby-constant">Parens</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isComplex</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">isComplex</span>();
  };

  <span class="ruby-constant">Parens</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">bare</span>, <span class="ruby-identifier">expr</span>, <span class="ruby-identifier">fragments</span>;
    <span class="ruby-identifier">expr</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">unwrap</span>();
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">expr</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">isAtomic</span>()) {
      <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">front</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">front</span>;
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
    }
    <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_PAREN</span>);
    <span class="ruby-identifier">bare</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">&lt;</span> <span class="ruby-constant">LEVEL_OP</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">expr</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Op</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">expr</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Call</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">expr</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">For</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">returns</span>));
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">bare</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">fragments</span>;
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">wrapInBraces</span>(<span class="ruby-identifier">fragments</span>);
    }
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Parens</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">For</span> = <span class="ruby-constant">For</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">For</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">For</span>(<span class="ruby-identifier">body</span>, <span class="ruby-identifier">source</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref3</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">source</span> = <span class="ruby-identifier">source</span>.<span class="ruby-identifier">source</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">guard</span> = <span class="ruby-identifier">source</span>.<span class="ruby-identifier">guard</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">step</span> = <span class="ruby-identifier">source</span>.<span class="ruby-identifier">step</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span> = <span class="ruby-identifier">source</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">index</span> = <span class="ruby-identifier">source</span>.<span class="ruby-identifier">index</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">wrap</span>([<span class="ruby-identifier">body</span>]);
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">own</span> = <span class="ruby-operator">!</span><span class="ruby-operator">!</span><span class="ruby-identifier">source</span>.<span class="ruby-identifier">own</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">object</span> = <span class="ruby-operator">!</span><span class="ruby-operator">!</span><span class="ruby-identifier">source</span>.<span class="ruby-identifier">object</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">object</span>) {
      <span class="ruby-identifier">ref3</span> = [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">index</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>], <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">this</span>.<span class="ruby-identifier">index</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-value">1</span>];
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">index</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">index</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&#39;index cannot be a pattern matching expression&#39;</span>);
    }
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">range</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">source</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">source</span>.<span class="ruby-identifier">base</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Range</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">source</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">length</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">pattern</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">range</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">index</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">index</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&#39;indexes do not apply to range loops&#39;</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">range</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">pattern</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&#39;cannot pattern match over range loops&#39;</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">own</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">object</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">error</span>(<span class="ruby-string">&#39;cannot use own with for-in&#39;</span>);
    }
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">returns</span> = <span class="ruby-keyword">false</span>;
  }

  <span class="ruby-constant">For</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;body&#39;</span>, <span class="ruby-string">&#39;source&#39;</span>, <span class="ruby-string">&#39;guard&#39;</span>, <span class="ruby-string">&#39;step&#39;</span>];

  <span class="ruby-constant">For</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">body</span>, <span class="ruby-identifier">bodyFragments</span>, <span class="ruby-identifier">compare</span>, <span class="ruby-identifier">compareDown</span>, <span class="ruby-identifier">declare</span>, <span class="ruby-identifier">declareDown</span>, <span class="ruby-identifier">defPart</span>, <span class="ruby-identifier">defPartFragments</span>, <span class="ruby-identifier">down</span>, <span class="ruby-identifier">forPartFragments</span>, <span class="ruby-identifier">guardPart</span>, <span class="ruby-identifier">idt1</span>, <span class="ruby-identifier">increment</span>, <span class="ruby-identifier">index</span>, <span class="ruby-identifier">ivar</span>, <span class="ruby-identifier">kvar</span>, <span class="ruby-identifier">kvarAssign</span>, <span class="ruby-identifier">last</span>, <span class="ruby-identifier">lvar</span>, <span class="ruby-identifier">name</span>, <span class="ruby-identifier">namePart</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">resultPart</span>, <span class="ruby-identifier">returnResult</span>, <span class="ruby-identifier">rvar</span>, <span class="ruby-identifier">scope</span>, <span class="ruby-identifier">source</span>, <span class="ruby-identifier">step</span>, <span class="ruby-identifier">stepNum</span>, <span class="ruby-identifier">stepVar</span>, <span class="ruby-identifier">svar</span>, <span class="ruby-identifier">varPart</span>;
    <span class="ruby-identifier">body</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">wrap</span>([<span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>]);
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">body</span>.<span class="ruby-identifier">expressions</span>, <span class="ruby-identifier">last</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>];
    <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">last</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">last</span>.<span class="ruby-identifier">jumps</span>() <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Return</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">returns</span> = <span class="ruby-keyword">false</span>;
    }
    <span class="ruby-identifier">source</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">range</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">source</span>.<span class="ruby-identifier">base</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">source</span>;
    <span class="ruby-identifier">scope</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">pattern</span>) {
      <span class="ruby-identifier">name</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>.<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>));
    }
    <span class="ruby-identifier">index</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">index</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">index</span>.<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>));
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">name</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">pattern</span>) {
      <span class="ruby-identifier">scope</span>.<span class="ruby-identifier">find</span>(<span class="ruby-identifier">name</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">index</span>) {
      <span class="ruby-identifier">scope</span>.<span class="ruby-identifier">find</span>(<span class="ruby-identifier">index</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">returns</span>) {
      <span class="ruby-identifier">rvar</span> = <span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;results&#39;</span>);
    }
    <span class="ruby-identifier">ivar</span> = (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">object</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">index</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;i&#39;</span>, {
      <span class="ruby-identifier">single</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
    });
    <span class="ruby-identifier">kvar</span> = (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">range</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">name</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">index</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ivar</span>;
    <span class="ruby-identifier">kvarAssign</span> = <span class="ruby-identifier">kvar</span> <span class="ruby-operator">!=</span>= <span class="ruby-identifier">ivar</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">kvar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span> <span class="ruby-operator">:</span> <span class="ruby-string">&quot;&quot;</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">step</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">range</span>) {
      <span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">cacheToCodeFragments</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">step</span>.<span class="ruby-identifier">cache</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>, <span class="ruby-identifier">isComplexOrAssignable</span>)), <span class="ruby-identifier">step</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">stepVar</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">1</span>];
      <span class="ruby-identifier">stepNum</span> = <span class="ruby-identifier">stepVar</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">NUMBER</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">pattern</span>) {
      <span class="ruby-identifier">name</span> = <span class="ruby-identifier">ivar</span>;
    }
    <span class="ruby-identifier">varPart</span> = <span class="ruby-string">&#39;&#39;</span>;
    <span class="ruby-identifier">guardPart</span> = <span class="ruby-string">&#39;&#39;</span>;
    <span class="ruby-identifier">defPart</span> = <span class="ruby-string">&#39;&#39;</span>;
    <span class="ruby-identifier">idt1</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-constant">TAB</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">range</span>) {
      <span class="ruby-identifier">forPartFragments</span> = <span class="ruby-identifier">source</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">o</span>, {
        <span class="ruby-identifier">index</span><span class="ruby-operator">:</span> <span class="ruby-identifier">ivar</span>,
        <span class="ruby-identifier">name</span><span class="ruby-operator">:</span> <span class="ruby-identifier">name</span>,
        <span class="ruby-identifier">step</span><span class="ruby-operator">:</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">step</span>,
        <span class="ruby-identifier">isComplex</span><span class="ruby-operator">:</span> <span class="ruby-identifier">isComplexOrAssignable</span>
      }));
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">svar</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">source</span>.<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>);
      <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">name</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">own</span>) <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-constant">IDENTIFIER</span>.<span class="ruby-identifier">test</span>(<span class="ruby-identifier">svar</span>)) {
        <span class="ruby-identifier">defPart</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;ref&#39;</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">svar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;;\n&quot;</span>;
        <span class="ruby-identifier">svar</span> = <span class="ruby-identifier">ref</span>;
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">name</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">pattern</span>) {
        <span class="ruby-identifier">namePart</span> = <span class="ruby-identifier">name</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">svar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;[&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">kvar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;]&quot;</span>;
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">object</span>) {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">step</span> <span class="ruby-operator">!=</span>= <span class="ruby-identifier">stepVar</span>) {
          <span class="ruby-identifier">defPart</span> <span class="ruby-operator">+=</span> <span class="ruby-string">&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">step</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;;\n&quot;</span>;
        }
        <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">step</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">stepNum</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">down</span> = <span class="ruby-identifier">parseNum</span>(<span class="ruby-identifier">stepNum</span>[<span class="ruby-value">0</span>]) <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>))) {
          <span class="ruby-identifier">lvar</span> = <span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;len&#39;</span>);
        }
        <span class="ruby-identifier">declare</span> = <span class="ruby-string">&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">kvarAssign</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ivar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = 0, &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">lvar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">svar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.length&quot;</span>;
        <span class="ruby-identifier">declareDown</span> = <span class="ruby-string">&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">kvarAssign</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ivar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">svar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.length - 1&quot;</span>;
        <span class="ruby-identifier">compare</span> = <span class="ruby-identifier">ivar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &lt; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">lvar</span>;
        <span class="ruby-identifier">compareDown</span> = <span class="ruby-identifier">ivar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &gt;= 0&quot;</span>;
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">step</span>) {
          <span class="ruby-keyword">if</span> (<span class="ruby-identifier">stepNum</span>) {
            <span class="ruby-keyword">if</span> (<span class="ruby-identifier">down</span>) {
              <span class="ruby-identifier">compare</span> = <span class="ruby-identifier">compareDown</span>;
              <span class="ruby-identifier">declare</span> = <span class="ruby-identifier">declareDown</span>;
            }
          } <span class="ruby-keyword">else</span> {
            <span class="ruby-identifier">compare</span> = <span class="ruby-identifier">stepVar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &gt; 0 ? &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">compare</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; : &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">compareDown</span>;
            <span class="ruby-identifier">declare</span> = <span class="ruby-string">&quot;(&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">stepVar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; &gt; 0 ? (&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">declare</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;) : &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">declareDown</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;)&quot;</span>;
          }
          <span class="ruby-identifier">increment</span> = <span class="ruby-identifier">ivar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; += &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">stepVar</span>;
        } <span class="ruby-keyword">else</span> {
          <span class="ruby-identifier">increment</span> = <span class="ruby-string">&quot;&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">kvar</span> <span class="ruby-operator">!=</span>= <span class="ruby-identifier">ivar</span> <span class="ruby-operator">?</span> <span class="ruby-string">&quot;++&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ivar</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">ivar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;++&quot;</span>);
        }
        <span class="ruby-identifier">forPartFragments</span> = [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">declare</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">compare</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;; &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">kvarAssign</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">increment</span>)];
      }
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">returns</span>) {
      <span class="ruby-identifier">resultPart</span> = <span class="ruby-string">&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">rvar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; = [];\n&quot;</span>;
      <span class="ruby-identifier">returnResult</span> = <span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;return &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">rvar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;;&quot;</span>;
      <span class="ruby-identifier">body</span>.<span class="ruby-identifier">makeReturn</span>(<span class="ruby-identifier">rvar</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">guard</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">body</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">1</span>) {
        <span class="ruby-identifier">body</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">If</span>((<span class="ruby-identifier">new</span> <span class="ruby-constant">Parens</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">guard</span>)).<span class="ruby-identifier">invert</span>(), <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&quot;continue&quot;</span>)));
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">guard</span>) {
          <span class="ruby-identifier">body</span> = <span class="ruby-constant">Block</span>.<span class="ruby-identifier">wrap</span>([<span class="ruby-identifier">new</span> <span class="ruby-constant">If</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">guard</span>, <span class="ruby-identifier">body</span>)]);
        }
      }
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">pattern</span>) {
      <span class="ruby-identifier">body</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">name</span>, <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">svar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;[&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">kvar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;]&quot;</span>)));
    }
    <span class="ruby-identifier">defPartFragments</span> = [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">defPart</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">pluckDirectCall</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">body</span>));
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">namePart</span>) {
      <span class="ruby-identifier">varPart</span> = <span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idt1</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">namePart</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;;&quot;</span>;
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">object</span>) {
      <span class="ruby-identifier">forPartFragments</span> = [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">kvar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; in &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">svar</span>)];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">own</span>) {
        <span class="ruby-identifier">guardPart</span> = <span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">idt1</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;if (!&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">utility</span>(<span class="ruby-string">&#39;hasProp&#39;</span>, <span class="ruby-identifier">o</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.call(&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">svar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;, &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">kvar</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;)) continue;&quot;</span>;
      }
    }
    <span class="ruby-identifier">bodyFragments</span> = <span class="ruby-identifier">body</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">o</span>, {
      <span class="ruby-identifier">indent</span><span class="ruby-operator">:</span> <span class="ruby-identifier">idt1</span>
    }), <span class="ruby-constant">LEVEL_TOP</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">bodyFragments</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">bodyFragments</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>)) {
      <span class="ruby-identifier">bodyFragments</span> = [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span>), <span class="ruby-identifier">bodyFragments</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span>));
    }
    <span class="ruby-keyword">return</span> [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">defPartFragments</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">resultPart</span> <span class="ruby-operator">||</span> <span class="ruby-string">&#39;&#39;</span>) <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;for (&quot;</span>), <span class="ruby-identifier">forPartFragments</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;) {&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">guardPart</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">varPart</span>), <span class="ruby-identifier">bodyFragments</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;}&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">returnResult</span> <span class="ruby-operator">||</span> <span class="ruby-string">&#39;&#39;</span>)));
  };

  <span class="ruby-constant">For</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">pluckDirectCall</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">body</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">base</span>, <span class="ruby-identifier">defs</span>, <span class="ruby-identifier">expr</span>, <span class="ruby-identifier">fn</span>, <span class="ruby-identifier">idx</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">ref5</span>, <span class="ruby-identifier">ref6</span>, <span class="ruby-identifier">ref7</span>, <span class="ruby-identifier">ref8</span>, <span class="ruby-identifier">ref9</span>, <span class="ruby-identifier">val</span>;
    <span class="ruby-identifier">defs</span> = [];
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">body</span>.<span class="ruby-identifier">expressions</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">idx</span> = <span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">idx</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">j</span>) {
      <span class="ruby-identifier">expr</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">idx</span>];
      <span class="ruby-identifier">expr</span> = <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">unwrapAll</span>();
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">expr</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Call</span>)) {
        <span class="ruby-identifier">continue</span>;
      }
      <span class="ruby-identifier">val</span> = (<span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">variable</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref4</span>.<span class="ruby-identifier">unwrapAll</span>() <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>((<span class="ruby-identifier">val</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Code</span>) <span class="ruby-operator">||</span> (<span class="ruby-identifier">val</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Value</span> <span class="ruby-operator">&amp;&amp;</span> ((<span class="ruby-identifier">ref5</span> = <span class="ruby-identifier">val</span>.<span class="ruby-identifier">base</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref5</span>.<span class="ruby-identifier">unwrapAll</span>() <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Code</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">val</span>.<span class="ruby-identifier">properties</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">===</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> ((<span class="ruby-identifier">ref6</span> = (<span class="ruby-identifier">ref7</span> = <span class="ruby-identifier">val</span>.<span class="ruby-identifier">properties</span>[<span class="ruby-value">0</span>].<span class="ruby-identifier">name</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref7</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">===</span> <span class="ruby-string">&#39;call&#39;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref6</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;apply&#39;</span>)))) {
        <span class="ruby-identifier">continue</span>;
      }
      <span class="ruby-identifier">fn</span> = ((<span class="ruby-identifier">ref8</span> = <span class="ruby-identifier">val</span>.<span class="ruby-identifier">base</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref8</span>.<span class="ruby-identifier">unwrapAll</span>() <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">val</span>;
      <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-string">&#39;fn&#39;</span>));
      <span class="ruby-identifier">base</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">ref</span>);
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">val</span>.<span class="ruby-identifier">base</span>) {
        <span class="ruby-identifier">ref9</span> = [<span class="ruby-identifier">base</span>, <span class="ruby-identifier">val</span>], <span class="ruby-identifier">val</span>.<span class="ruby-identifier">base</span> = <span class="ruby-identifier">ref9</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">base</span> = <span class="ruby-identifier">ref9</span>[<span class="ruby-value">1</span>];
      }
      <span class="ruby-identifier">body</span>.<span class="ruby-identifier">expressions</span>[<span class="ruby-identifier">idx</span>] = <span class="ruby-identifier">new</span> <span class="ruby-constant">Call</span>(<span class="ruby-identifier">base</span>, <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">args</span>);
      <span class="ruby-identifier">defs</span> = <span class="ruby-identifier">defs</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span>), <span class="ruby-identifier">new</span> <span class="ruby-constant">Assign</span>(<span class="ruby-identifier">ref</span>, <span class="ruby-identifier">fn</span>).<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_TOP</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39;;\n&#39;</span>));
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">defs</span>;
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">For</span>;

})(<span class="ruby-constant">While</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">Switch</span> = <span class="ruby-constant">Switch</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">Switch</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">Switch</span>(<span class="ruby-identifier">subject</span>, <span class="ruby-identifier">cases</span>, <span class="ruby-identifier">otherwise</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">subject</span> = <span class="ruby-identifier">subject</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">cases</span> = <span class="ruby-identifier">cases</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">otherwise</span> = <span class="ruby-identifier">otherwise</span>;
  }

  <span class="ruby-constant">Switch</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;subject&#39;</span>, <span class="ruby-string">&#39;cases&#39;</span>, <span class="ruby-string">&#39;otherwise&#39;</span>];

  <span class="ruby-constant">Switch</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isStatement</span> = <span class="ruby-constant">YES</span>;

  <span class="ruby-constant">Switch</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">jumps</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">block</span>, <span class="ruby-identifier">conds</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">jumpNode</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">ref5</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
      <span class="ruby-identifier">o</span> = {
        <span class="ruby-identifier">block</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
      };
    }
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">cases</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">j</span>], <span class="ruby-identifier">conds</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">block</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">1</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">jumpNode</span> = <span class="ruby-identifier">block</span>.<span class="ruby-identifier">jumps</span>(<span class="ruby-identifier">o</span>)) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">jumpNode</span>;
      }
    }
    <span class="ruby-keyword">return</span> (<span class="ruby-identifier">ref5</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">otherwise</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref5</span>.<span class="ruby-identifier">jumps</span>(<span class="ruby-identifier">o</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>;
  };

  <span class="ruby-constant">Switch</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">makeReturn</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">res</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">pair</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>;
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">cases</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">pair</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-identifier">pair</span>[<span class="ruby-value">1</span>].<span class="ruby-identifier">makeReturn</span>(<span class="ruby-identifier">res</span>);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">res</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">otherwise</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">otherwise</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Block</span>([<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&#39;void 0&#39;</span>)]));
    }
    <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">otherwise</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span>) {
      <span class="ruby-identifier">ref4</span>.<span class="ruby-identifier">makeReturn</span>(<span class="ruby-identifier">res</span>);
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  };

  <span class="ruby-constant">Switch</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">block</span>, <span class="ruby-identifier">body</span>, <span class="ruby-identifier">cond</span>, <span class="ruby-identifier">conditions</span>, <span class="ruby-identifier">expr</span>, <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">idt1</span>, <span class="ruby-identifier">idt2</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">k</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">len2</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">ref4</span>, <span class="ruby-identifier">ref5</span>;
    <span class="ruby-identifier">idt1</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">indent</span> <span class="ruby-operator">+</span> <span class="ruby-constant">TAB</span>;
    <span class="ruby-identifier">idt2</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">indent</span> = <span class="ruby-identifier">idt1</span> <span class="ruby-operator">+</span> <span class="ruby-constant">TAB</span>;
    <span class="ruby-identifier">fragments</span> = [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;switch (&quot;</span>), (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">subject</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">subject</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_PAREN</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;false&quot;</span>)), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;) {\n&quot;</span>));
    <span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">cases</span>;
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">i</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">j</span>) {
      <span class="ruby-identifier">ref4</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">i</span>], <span class="ruby-identifier">conditions</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">block</span> = <span class="ruby-identifier">ref4</span>[<span class="ruby-value">1</span>];
      <span class="ruby-identifier">ref5</span> = <span class="ruby-identifier">flatten</span>([<span class="ruby-identifier">conditions</span>]);
      <span class="ruby-keyword">for</span> (<span class="ruby-identifier">k</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len2</span> = <span class="ruby-identifier">ref5</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">k</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len2</span>; <span class="ruby-identifier">k</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
        <span class="ruby-identifier">cond</span> = <span class="ruby-identifier">ref5</span>[<span class="ruby-identifier">k</span>];
        <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">subject</span>) {
          <span class="ruby-identifier">cond</span> = <span class="ruby-identifier">cond</span>.<span class="ruby-identifier">invert</span>();
        }
        <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">idt1</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;case &quot;</span>), <span class="ruby-identifier">cond</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_PAREN</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;:\n&quot;</span>));
      }
      <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">body</span> = <span class="ruby-identifier">block</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_TOP</span>)).<span class="ruby-identifier">length</span> <span class="ruby-operator">&gt;</span> <span class="ruby-value">0</span>) {
        <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">body</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39;\n&#39;</span>));
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">cases</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">otherwise</span>) {
        <span class="ruby-keyword">break</span>;
      }
      <span class="ruby-identifier">expr</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">lastNonComment</span>(<span class="ruby-identifier">block</span>.<span class="ruby-identifier">expressions</span>);
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">expr</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Return</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">expr</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Literal</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">jumps</span>() <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">expr</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;debugger&#39;</span>)) {
        <span class="ruby-identifier">continue</span>;
      }
      <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">cond</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">idt2</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;break;\n&#39;</span>));
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">otherwise</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">otherwise</span>.<span class="ruby-identifier">expressions</span>.<span class="ruby-identifier">length</span>) {
      <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-identifier">fragments</span>, [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">idt1</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;default:\n&quot;</span>)].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">slice</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">otherwise</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_TOP</span>)), [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span>)]));
    }
    <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&#39;}&#39;</span>));
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">fragments</span>;
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">Switch</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">If</span> = <span class="ruby-constant">If</span> = (<span class="ruby-identifier">function</span>(<span class="ruby-identifier">superClass1</span>) {
  <span class="ruby-identifier">extend1</span>(<span class="ruby-constant">If</span>, <span class="ruby-identifier">superClass1</span>);

  <span class="ruby-identifier">function</span> <span class="ruby-constant">If</span>(<span class="ruby-identifier">condition</span>, <span class="ruby-identifier">body1</span>, <span class="ruby-identifier">options</span>) {
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span> = <span class="ruby-identifier">body1</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
      <span class="ruby-identifier">options</span> = {};
    }
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">condition</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;unless&#39;</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">condition</span>.<span class="ruby-identifier">invert</span>() <span class="ruby-operator">:</span> <span class="ruby-identifier">condition</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBody</span> = <span class="ruby-identifier">null</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isChain</span> = <span class="ruby-keyword">false</span>;
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">soak</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">soak</span>;
  }

  <span class="ruby-constant">If</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">children</span> = [<span class="ruby-string">&#39;condition&#39;</span>, <span class="ruby-string">&#39;body&#39;</span>, <span class="ruby-string">&#39;elseBody&#39;</span>];

  <span class="ruby-constant">If</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">bodyNode</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref3</span>;
    <span class="ruby-keyword">return</span> (<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">unwrap</span>() <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>;
  };

  <span class="ruby-constant">If</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">elseBodyNode</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref3</span>;
    <span class="ruby-keyword">return</span> (<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBody</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">unwrap</span>() <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>;
  };

  <span class="ruby-constant">If</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">addElse</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">elseBody</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">isChain</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBodyNode</span>().<span class="ruby-identifier">addElse</span>(<span class="ruby-identifier">elseBody</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">isChain</span> = <span class="ruby-identifier">elseBody</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">If</span>;
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBody</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ensureBlock</span>(<span class="ruby-identifier">elseBody</span>);
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBody</span>.<span class="ruby-identifier">updateLocationDataIfMissing</span>(<span class="ruby-identifier">elseBody</span>.<span class="ruby-identifier">locationData</span>);
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  };

  <span class="ruby-constant">If</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">isStatement</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref3</span>;
    <span class="ruby-keyword">return</span> (<span class="ruby-identifier">o</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>) <span class="ruby-operator">===</span> <span class="ruby-constant">LEVEL_TOP</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">bodyNode</span>().<span class="ruby-identifier">isStatement</span>(<span class="ruby-identifier">o</span>) <span class="ruby-operator">||</span> ((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBodyNode</span>()) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">isStatement</span>(<span class="ruby-identifier">o</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>);
  };

  <span class="ruby-constant">If</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">jumps</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref3</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">jumps</span>(<span class="ruby-identifier">o</span>) <span class="ruby-operator">||</span> ((<span class="ruby-identifier">ref3</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBody</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">jumps</span>(<span class="ruby-identifier">o</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>);
  };

  <span class="ruby-constant">If</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileNode</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">isStatement</span>(<span class="ruby-identifier">o</span>)) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileStatement</span>(<span class="ruby-identifier">o</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">compileExpression</span>(<span class="ruby-identifier">o</span>);
    }
  };

  <span class="ruby-constant">If</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">makeReturn</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">res</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">res</span>) {
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBody</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBody</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Block</span>([<span class="ruby-identifier">new</span> <span class="ruby-constant">Literal</span>(<span class="ruby-string">&#39;void 0&#39;</span>)]));
    }
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Block</span>([<span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>.<span class="ruby-identifier">makeReturn</span>(<span class="ruby-identifier">res</span>)]));
    <span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBody</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBody</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Block</span>([<span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBody</span>.<span class="ruby-identifier">makeReturn</span>(<span class="ruby-identifier">res</span>)]));
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>;
  };

  <span class="ruby-constant">If</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">ensureBlock</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">node</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Block</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>;
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Block</span>([<span class="ruby-identifier">node</span>]);
    }
  };

  <span class="ruby-constant">If</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileStatement</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">body</span>, <span class="ruby-identifier">child</span>, <span class="ruby-identifier">cond</span>, <span class="ruby-identifier">exeq</span>, <span class="ruby-identifier">ifPart</span>, <span class="ruby-identifier">indent</span>;
    <span class="ruby-identifier">child</span> = <span class="ruby-identifier">del</span>(<span class="ruby-identifier">o</span>, <span class="ruby-string">&#39;chainChild&#39;</span>);
    <span class="ruby-identifier">exeq</span> = <span class="ruby-identifier">del</span>(<span class="ruby-identifier">o</span>, <span class="ruby-string">&#39;isExistentialEquals&#39;</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">exeq</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">If</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">condition</span>.<span class="ruby-identifier">invert</span>(), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBodyNode</span>(), {
        <span class="ruby-identifier">type</span><span class="ruby-operator">:</span> <span class="ruby-string">&#39;if&#39;</span>
      }).<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>);
    }
    <span class="ruby-identifier">indent</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">indent</span> <span class="ruby-operator">+</span> <span class="ruby-constant">TAB</span>;
    <span class="ruby-identifier">cond</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">condition</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_PAREN</span>);
    <span class="ruby-identifier">body</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">ensureBlock</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">body</span>).<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">o</span>, {
      <span class="ruby-identifier">indent</span><span class="ruby-operator">:</span> <span class="ruby-identifier">indent</span>
    }));
    <span class="ruby-identifier">ifPart</span> = [].<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;if (&quot;</span>), <span class="ruby-identifier">cond</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;) {\n&quot;</span>), <span class="ruby-identifier">body</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;}&quot;</span>));
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">child</span>) {
      <span class="ruby-identifier">ifPart</span>.<span class="ruby-identifier">unshift</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span>));
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBody</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">ifPart</span>;
    }
    <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">ifPart</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39; else &#39;</span>));
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">this</span>.<span class="ruby-identifier">isChain</span>) {
      <span class="ruby-identifier">o</span>.<span class="ruby-identifier">chainChild</span> = <span class="ruby-keyword">true</span>;
      <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBody</span>.<span class="ruby-identifier">unwrap</span>().<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_TOP</span>));
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;{\n&quot;</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBody</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">merge</span>(<span class="ruby-identifier">o</span>, {
        <span class="ruby-identifier">indent</span><span class="ruby-operator">:</span> <span class="ruby-identifier">indent</span>
      }), <span class="ruby-constant">LEVEL_TOP</span>), <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">tab</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;}&quot;</span>));
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span>;
  };

  <span class="ruby-constant">If</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">compileExpression</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">alt</span>, <span class="ruby-identifier">body</span>, <span class="ruby-identifier">cond</span>, <span class="ruby-identifier">fragments</span>;
    <span class="ruby-identifier">cond</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">condition</span>.<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_COND</span>);
    <span class="ruby-identifier">body</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">bodyNode</span>().<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>);
    <span class="ruby-identifier">alt</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBodyNode</span>() <span class="ruby-operator">?</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">elseBodyNode</span>().<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">o</span>, <span class="ruby-constant">LEVEL_LIST</span>) <span class="ruby-operator">:</span> [<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&#39;void 0&#39;</span>)];
    <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">cond</span>.<span class="ruby-identifier">concat</span>(<span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot; ? &quot;</span>), <span class="ruby-identifier">body</span>, <span class="ruby-identifier">this</span>.<span class="ruby-identifier">makeCode</span>(<span class="ruby-string">&quot; : &quot;</span>), <span class="ruby-identifier">alt</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">o</span>.<span class="ruby-identifier">level</span> <span class="ruby-operator">&gt;=</span> <span class="ruby-constant">LEVEL_COND</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">wrapInBraces</span>(<span class="ruby-identifier">fragments</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">fragments</span>;
    }
  };

  <span class="ruby-constant">If</span>.<span class="ruby-identifier">prototype</span>.<span class="ruby-identifier">unfoldSoak</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">soak</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>;
  };

  <span class="ruby-keyword">return</span> <span class="ruby-constant">If</span>;

})(<span class="ruby-constant">Base</span>);

<span class="ruby-constant">UTILITIES</span> = {
  <span class="ruby-identifier">extend</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;function(child, parent) { for (var key in parent) { if (&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">utility</span>(<span class="ruby-string">&#39;hasProp&#39;</span>, <span class="ruby-identifier">o</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }&quot;</span>;
  },
  <span class="ruby-identifier">bind</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-string">&#39;function(fn, me){ return function(){ return fn.apply(me, arguments); }; }&#39;</span>;
  },
  <span class="ruby-identifier">indexOf</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;[].indexOf || function(item) { for (var i = 0, l = this.length; i &lt; l; i++) { if (i in this &amp;&amp; this[i] === item) return i; } return -1; }&quot;</span>;
  },
  <span class="ruby-identifier">modulo</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;function(a, b) { return (+a % (b = +b) + b) % b; }&quot;</span>;
  },
  <span class="ruby-identifier">hasProp</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-string">&#39;{}.hasOwnProperty&#39;</span>;
  },
  <span class="ruby-identifier">slice</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-string">&#39;[].slice&#39;</span>;
  }
};

<span class="ruby-constant">LEVEL_TOP</span> = <span class="ruby-value">1</span>;

<span class="ruby-constant">LEVEL_PAREN</span> = <span class="ruby-value">2</span>;

<span class="ruby-constant">LEVEL_LIST</span> = <span class="ruby-value">3</span>;

<span class="ruby-constant">LEVEL_COND</span> = <span class="ruby-value">4</span>;

<span class="ruby-constant">LEVEL_OP</span> = <span class="ruby-value">5</span>;

<span class="ruby-constant">LEVEL_ACCESS</span> = <span class="ruby-value">6</span>;

<span class="ruby-constant">TAB</span> = <span class="ruby-string">&#39;  &#39;</span>;

<span class="ruby-constant">IDENTIFIER</span> = <span class="ruby-regexp">/^(?!\d)[$\w\x7f-\uffff]+$/</span>;

<span class="ruby-constant">SIMPLENUM</span> = <span class="ruby-regexp">/^[+-]?\d+$/</span>;

<span class="ruby-constant">HEXNUM</span> = <span class="ruby-regexp">/^[+-]?0x[\da-f]+/</span>;

<span class="ruby-constant">NUMBER</span> = <span class="ruby-regexp">/^[+-]?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)$/</span>;

<span class="ruby-constant">IS_STRING</span> = <span class="ruby-regexp">/^[&#39;&quot;]/</span>;

<span class="ruby-constant">IS_REGEX</span> = <span class="ruby-regexp">/^\//</span>;

<span class="ruby-identifier">utility</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">name</span>, <span class="ruby-identifier">o</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">root</span>;
  <span class="ruby-identifier">root</span> = <span class="ruby-identifier">o</span>.<span class="ruby-identifier">scope</span>.<span class="ruby-identifier">root</span>;
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">name</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">root</span>.<span class="ruby-identifier">utilities</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">root</span>.<span class="ruby-identifier">utilities</span>[<span class="ruby-identifier">name</span>];
  } <span class="ruby-keyword">else</span> {
    <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">root</span>.<span class="ruby-identifier">freeVariable</span>(<span class="ruby-identifier">name</span>);
    <span class="ruby-identifier">root</span>.<span class="ruby-identifier">assign</span>(<span class="ruby-identifier">ref</span>, <span class="ruby-constant">UTILITIES</span>[<span class="ruby-identifier">name</span>](<span class="ruby-identifier">o</span>));
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">root</span>.<span class="ruby-identifier">utilities</span>[<span class="ruby-identifier">name</span>] = <span class="ruby-identifier">ref</span>;
  }
};

<span class="ruby-identifier">multident</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">tab</span>) {
  <span class="ruby-identifier">code</span> = <span class="ruby-identifier">code</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-regexp">/\n/</span><span class="ruby-identifier">g</span>, <span class="ruby-string">&#39;$&amp;&#39;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">tab</span>);
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">code</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-regexp">/\s+$/</span>, <span class="ruby-string">&#39;&#39;</span>);
};

<span class="ruby-identifier">parseNum</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">x</span>) {
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">x</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-value">0</span>;
  } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">x</span>.<span class="ruby-identifier">match</span>(<span class="ruby-constant">HEXNUM</span>)) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">parseInt</span>(<span class="ruby-identifier">x</span>, <span class="ruby-value">16</span>);
  } <span class="ruby-keyword">else</span> {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">parseFloat</span>(<span class="ruby-identifier">x</span>);
  }
};

<span class="ruby-identifier">isLiteralArguments</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">node</span>) {
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Literal</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;arguments&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">node</span>.<span class="ruby-identifier">asKey</span>;
};

<span class="ruby-identifier">isLiteralThis</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">node</span>) {
  <span class="ruby-keyword">return</span> (<span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Literal</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">value</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;this&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-operator">!</span><span class="ruby-identifier">node</span>.<span class="ruby-identifier">asKey</span>) <span class="ruby-operator">||</span> (<span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Code</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">bound</span>) <span class="ruby-operator">||</span> (<span class="ruby-identifier">node</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Call</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">isSuper</span>);
};

<span class="ruby-identifier">isComplexOrAssignable</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">node</span>) {
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">isComplex</span>() <span class="ruby-operator">||</span> (<span class="ruby-identifier">typeof</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">isAssignable</span> <span class="ruby-operator">===</span> <span class="ruby-string">&quot;function&quot;</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">node</span>.<span class="ruby-identifier">isAssignable</span>() <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>);
};

<span class="ruby-identifier">unfoldSoak</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">o</span>, <span class="ruby-identifier">parent</span>, <span class="ruby-identifier">name</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">ifn</span>;
  <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">ifn</span> = <span class="ruby-identifier">parent</span>[<span class="ruby-identifier">name</span>].<span class="ruby-identifier">unfoldSoak</span>(<span class="ruby-identifier">o</span>))) {
    <span class="ruby-keyword">return</span>;
  }
  <span class="ruby-identifier">parent</span>[<span class="ruby-identifier">name</span>] = <span class="ruby-identifier">ifn</span>.<span class="ruby-identifier">body</span>;
  <span class="ruby-identifier">ifn</span>.<span class="ruby-identifier">body</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Value</span>(<span class="ruby-identifier">parent</span>);
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">ifn</span>;
};
</pre>

<p>}).call(this);</p>

<pre>return module.exports;</pre>

<p>})();<a href="http://'./sourcemap'">require</a> = (function() {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">exports</span> = {}, <span class="ruby-identifier">module</span> = {<span class="ruby-identifier">exports</span><span class="ruby-operator">:</span> <span class="ruby-identifier">exports</span>};
<span class="ruby-regexp">//</span> <span class="ruby-constant">Generated</span> <span class="ruby-identifier">by</span> <span class="ruby-constant">CoffeeScript</span> <span class="ruby-value">1.9</span><span class="ruby-value">.1</span>
</pre>

<p>(function() {</p>

<pre>var LineMap, SourceMap;

LineMap = (function() {
  function LineMap(line1) {
    this.line = line1;
    this.columns = [];
  }

  LineMap.prototype.add = function(column, arg, options) {
    var sourceColumn, sourceLine;
    sourceLine = arg[0], sourceColumn = arg[1];
    if (options == null) {
      options = {};
    }
    if (this.columns[column] &amp;&amp; options.noReplace) {
      return;
    }
    return this.columns[column] = {
      line: this.line,
      column: column,
      sourceLine: sourceLine,
      sourceColumn: sourceColumn
    };
  };

  LineMap.prototype.sourceLocation = function(column) {
    var mapping;
    while (!((mapping = this.columns[column]) || (column &lt;= 0))) {
      column--;
    }
    return mapping &amp;&amp; [mapping.sourceLine, mapping.sourceColumn];
  };

  return LineMap;

})();

SourceMap = (function() {
  var BASE64_CHARS, VLQ_CONTINUATION_BIT, VLQ_SHIFT, VLQ_VALUE_MASK;

  function SourceMap() {
    this.lines = [];
  }

  SourceMap.prototype.add = function(sourceLocation, generatedLocation, options) {
    var base, column, line, lineMap;
    if (options == null) {
      options = {};
    }
    line = generatedLocation[0], column = generatedLocation[1];
    lineMap = ((base = this.lines)[line] || (base[line] = new LineMap(line)));
    return lineMap.add(column, sourceLocation, options);
  };

  SourceMap.prototype.sourceLocation = function(arg) {
    var column, line, lineMap;
    line = arg[0], column = arg[1];
    while (!((lineMap = this.lines[line]) || (line &lt;= 0))) {
      line--;
    }
    return lineMap &amp;&amp; lineMap.sourceLocation(column);
  };

  SourceMap.prototype.generate = function(options, code) {
    var buffer, i, j, lastColumn, lastSourceColumn, lastSourceLine, len, len1, lineMap, lineNumber, mapping, needComma, ref, ref1, v3, writingline;
    if (options == null) {
      options = {};
    }
    if (code == null) {
      code = null;
    }
    writingline = 0;
    lastColumn = 0;
    lastSourceLine = 0;
    lastSourceColumn = 0;
    needComma = false;
    buffer = &quot;&quot;;
    ref = this.lines;
    for (lineNumber = i = 0, len = ref.length; i &lt; len; lineNumber = ++i) {
      lineMap = ref[lineNumber];
      if (lineMap) {
        ref1 = lineMap.columns;
        for (j = 0, len1 = ref1.length; j &lt; len1; j++) {
          mapping = ref1[j];
          if (!(mapping)) {
            continue;
          }
          while (writingline &lt; mapping.line) {
            lastColumn = 0;
            needComma = false;
            buffer += &quot;;&quot;;
            writingline++;
          }
          if (needComma) {
            buffer += &quot;,&quot;;
            needComma = false;
          }
          buffer += this.encodeVlq(mapping.column - lastColumn);
          lastColumn = mapping.column;
          buffer += this.encodeVlq(0);
          buffer += this.encodeVlq(mapping.sourceLine - lastSourceLine);
          lastSourceLine = mapping.sourceLine;
          buffer += this.encodeVlq(mapping.sourceColumn - lastSourceColumn);
          lastSourceColumn = mapping.sourceColumn;
          needComma = true;
        }
      }
    }
    v3 = {
      version: 3,
      file: options.generatedFile || &#39;&#39;,
      sourceRoot: options.sourceRoot || &#39;&#39;,
      sources: options.sourceFiles || [&#39;&#39;],
      names: [],
      mappings: buffer
    };
    if (options.inline) {
      v3.sourcesContent = [code];
    }
    return JSON.stringify(v3, null, 2);
  };

  VLQ_SHIFT = 5;

  VLQ_CONTINUATION_BIT = 1 &lt;&lt; VLQ_SHIFT;

  VLQ_VALUE_MASK = VLQ_CONTINUATION_BIT - 1;

  SourceMap.prototype.encodeVlq = function(value) {
    var answer, nextChunk, signBit, valueToEncode;
    answer = &#39;&#39;;
    signBit = value &lt; 0 ? 1 : 0;
    valueToEncode = (Math.abs(value) &lt;&lt; 1) + signBit;
    while (valueToEncode || !answer) {
      nextChunk = valueToEncode &amp; VLQ_VALUE_MASK;
      valueToEncode = valueToEncode &gt;&gt; VLQ_SHIFT;
      if (valueToEncode) {
        nextChunk |= VLQ_CONTINUATION_BIT;
      }
      answer += this.encodeBase64(nextChunk);
    }
    return answer;
  };

  BASE64_CHARS = &#39;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#39;;

  SourceMap.prototype.encodeBase64 = function(value) {
    return BASE64_CHARS[value] || (function() {
      throw new Error(&quot;Cannot Base64 encode value: &quot; + value);
    })();
  };

  return SourceMap;

})();

module.exports = SourceMap;</pre>

<p>}).call(this);</p>

<pre>return module.exports;</pre>

<p>})();<a href="http://'./coffee-script'">require</a> = (function() {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">exports</span> = {}, <span class="ruby-identifier">module</span> = {<span class="ruby-identifier">exports</span><span class="ruby-operator">:</span> <span class="ruby-identifier">exports</span>};
<span class="ruby-regexp">//</span> <span class="ruby-constant">Generated</span> <span class="ruby-identifier">by</span> <span class="ruby-constant">CoffeeScript</span> <span class="ruby-value">1.9</span><span class="ruby-value">.1</span>
</pre>

<p>(function() {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-constant">Lexer</span>, <span class="ruby-constant">SourceMap</span>, <span class="ruby-identifier">base</span>, <span class="ruby-identifier">compile</span>, <span class="ruby-identifier">ext</span>, <span class="ruby-identifier">formatSourcePosition</span>, <span class="ruby-identifier">fs</span>, <span class="ruby-identifier">getSourceMap</span>, <span class="ruby-identifier">helpers</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">len</span>, <span class="ruby-identifier">lexer</span>, <span class="ruby-identifier">parser</span>, <span class="ruby-identifier">path</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">sourceMaps</span>, <span class="ruby-identifier">vm</span>, <span class="ruby-identifier">withPrettyErrors</span>,
  <span class="ruby-identifier">hasProp</span> = {}.<span class="ruby-identifier">hasOwnProperty</span>,
  <span class="ruby-identifier">indexOf</span> = [].<span class="ruby-identifier">indexOf</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">item</span>) { <span class="ruby-keyword">for</span> (<span class="ruby-identifier">var</span> <span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">l</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">l</span>; <span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) { <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">this</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>[<span class="ruby-identifier">i</span>] <span class="ruby-operator">===</span> <span class="ruby-identifier">item</span>) <span class="ruby-keyword">return</span> <span class="ruby-identifier">i</span>; } <span class="ruby-keyword">return</span> <span class="ruby-value">-1</span>; };

<span class="ruby-identifier">fs</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&#39;fs&#39;</span>);

<span class="ruby-identifier">vm</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&#39;vm&#39;</span>);

<span class="ruby-identifier">path</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&#39;path&#39;</span>);

<span class="ruby-constant">Lexer</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&#39;./lexer&#39;</span>).<span class="ruby-constant">Lexer</span>;

<span class="ruby-identifier">parser</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&#39;./parser&#39;</span>).<span class="ruby-identifier">parser</span>;

<span class="ruby-identifier">helpers</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&#39;./helpers&#39;</span>);

<span class="ruby-constant">SourceMap</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&#39;./sourcemap&#39;</span>);

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">VERSION</span> = <span class="ruby-string">&#39;1.9.1&#39;</span>;

<span class="ruby-identifier">exports</span>.<span class="ruby-constant">FILE_EXTENSIONS</span> = [<span class="ruby-string">&#39;.coffee&#39;</span>, <span class="ruby-string">&#39;.litcoffee&#39;</span>, <span class="ruby-string">&#39;.coffee.md&#39;</span>];

<span class="ruby-identifier">exports</span>.<span class="ruby-identifier">helpers</span> = <span class="ruby-identifier">helpers</span>;

<span class="ruby-identifier">withPrettyErrors</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">fn</span>) {
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">err</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
      <span class="ruby-identifier">options</span> = {};
    }
    <span class="ruby-identifier">try</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">fn</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">this</span>, <span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>);
    } <span class="ruby-identifier">catch</span> (<span class="ruby-identifier">_error</span>) {
      <span class="ruby-identifier">err</span> = <span class="ruby-identifier">_error</span>;
      <span class="ruby-identifier">throw</span> <span class="ruby-identifier">helpers</span>.<span class="ruby-identifier">updateSyntaxError</span>(<span class="ruby-identifier">err</span>, <span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>.<span class="ruby-identifier">filename</span>);
    }
  };
};

<span class="ruby-identifier">exports</span>.<span class="ruby-identifier">compile</span> = <span class="ruby-identifier">compile</span> = <span class="ruby-identifier">withPrettyErrors</span>(<span class="ruby-identifier">function</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">currentColumn</span>, <span class="ruby-identifier">currentLine</span>, <span class="ruby-identifier">extend</span>, <span class="ruby-identifier">fragment</span>, <span class="ruby-identifier">fragments</span>, <span class="ruby-identifier">header</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">js</span>, <span class="ruby-identifier">len</span>, <span class="ruby-identifier">map</span>, <span class="ruby-identifier">merge</span>, <span class="ruby-identifier">newLines</span>, <span class="ruby-identifier">token</span>, <span class="ruby-identifier">tokens</span>;
  <span class="ruby-identifier">merge</span> = <span class="ruby-identifier">helpers</span>.<span class="ruby-identifier">merge</span>, <span class="ruby-identifier">extend</span> = <span class="ruby-identifier">helpers</span>.<span class="ruby-identifier">extend</span>;
  <span class="ruby-identifier">options</span> = <span class="ruby-identifier">extend</span>({}, <span class="ruby-identifier">options</span>);
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">sourceMap</span>) {
    <span class="ruby-identifier">map</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">SourceMap</span>;
  }
  <span class="ruby-identifier">tokens</span> = <span class="ruby-identifier">lexer</span>.<span class="ruby-identifier">tokenize</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>);
  <span class="ruby-identifier">options</span>.<span class="ruby-identifier">referencedVars</span> = (<span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">i</span>, <span class="ruby-identifier">len</span>, <span class="ruby-identifier">results</span>;
    <span class="ruby-identifier">results</span> = [];
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len</span> = <span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len</span>; <span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">token</span> = <span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">i</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">token</span>.<span class="ruby-identifier">variable</span>) {
        <span class="ruby-identifier">results</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">token</span>[<span class="ruby-value">1</span>]);
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">results</span>;
  })();
  <span class="ruby-identifier">fragments</span> = <span class="ruby-identifier">parser</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">tokens</span>).<span class="ruby-identifier">compileToFragments</span>(<span class="ruby-identifier">options</span>);
  <span class="ruby-identifier">currentLine</span> = <span class="ruby-value">0</span>;
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">header</span>) {
    <span class="ruby-identifier">currentLine</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>;
  }
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">shiftLine</span>) {
    <span class="ruby-identifier">currentLine</span> <span class="ruby-operator">+=</span> <span class="ruby-value">1</span>;
  }
  <span class="ruby-identifier">currentColumn</span> = <span class="ruby-value">0</span>;
  <span class="ruby-identifier">js</span> = <span class="ruby-string">&quot;&quot;</span>;
  <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len</span> = <span class="ruby-identifier">fragments</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len</span>; <span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
    <span class="ruby-identifier">fragment</span> = <span class="ruby-identifier">fragments</span>[<span class="ruby-identifier">i</span>];
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">sourceMap</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">fragment</span>.<span class="ruby-identifier">locationData</span>) {
        <span class="ruby-identifier">map</span>.<span class="ruby-identifier">add</span>([<span class="ruby-identifier">fragment</span>.<span class="ruby-identifier">locationData</span>.<span class="ruby-identifier">first_line</span>, <span class="ruby-identifier">fragment</span>.<span class="ruby-identifier">locationData</span>.<span class="ruby-identifier">first_column</span>], [<span class="ruby-identifier">currentLine</span>, <span class="ruby-identifier">currentColumn</span>], {
          <span class="ruby-identifier">noReplace</span><span class="ruby-operator">:</span> <span class="ruby-keyword">true</span>
        });
      }
      <span class="ruby-identifier">newLines</span> = <span class="ruby-identifier">helpers</span>.<span class="ruby-identifier">count</span>(<span class="ruby-identifier">fragment</span>.<span class="ruby-identifier">code</span>, <span class="ruby-string">&quot;\n&quot;</span>);
      <span class="ruby-identifier">currentLine</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">newLines</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">newLines</span>) {
        <span class="ruby-identifier">currentColumn</span> = <span class="ruby-identifier">fragment</span>.<span class="ruby-identifier">code</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> (<span class="ruby-identifier">fragment</span>.<span class="ruby-identifier">code</span>.<span class="ruby-identifier">lastIndexOf</span>(<span class="ruby-string">&quot;\n&quot;</span>) <span class="ruby-operator">+</span> <span class="ruby-value">1</span>);
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">currentColumn</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">fragment</span>.<span class="ruby-identifier">code</span>.<span class="ruby-identifier">length</span>;
      }
    }
    <span class="ruby-identifier">js</span> <span class="ruby-operator">+=</span> <span class="ruby-identifier">fragment</span>.<span class="ruby-identifier">code</span>;
  }
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">header</span>) {
    <span class="ruby-identifier">header</span> = <span class="ruby-string">&quot;Generated by CoffeeScript &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">this</span>.<span class="ruby-constant">VERSION</span>;
    <span class="ruby-identifier">js</span> = <span class="ruby-string">&quot;// &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">header</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">js</span>;
  }
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">sourceMap</span>) {
    <span class="ruby-identifier">answer</span> = {
      <span class="ruby-identifier">js</span><span class="ruby-operator">:</span> <span class="ruby-identifier">js</span>
    };
    <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">sourceMap</span> = <span class="ruby-identifier">map</span>;
    <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">v3SourceMap</span> = <span class="ruby-identifier">map</span>.<span class="ruby-identifier">generate</span>(<span class="ruby-identifier">options</span>, <span class="ruby-identifier">code</span>);
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span>;
  } <span class="ruby-keyword">else</span> {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">js</span>;
  }
});

<span class="ruby-identifier">exports</span>.<span class="ruby-identifier">tokens</span> = <span class="ruby-identifier">withPrettyErrors</span>(<span class="ruby-identifier">function</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>) {
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">lexer</span>.<span class="ruby-identifier">tokenize</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>);
});

<span class="ruby-identifier">exports</span>.<span class="ruby-identifier">nodes</span> = <span class="ruby-identifier">withPrettyErrors</span>(<span class="ruby-identifier">function</span>(<span class="ruby-identifier">source</span>, <span class="ruby-identifier">options</span>) {
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">typeof</span> <span class="ruby-identifier">source</span> <span class="ruby-operator">===</span> <span class="ruby-string">&#39;string&#39;</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">parser</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">lexer</span>.<span class="ruby-identifier">tokenize</span>(<span class="ruby-identifier">source</span>, <span class="ruby-identifier">options</span>));
  } <span class="ruby-keyword">else</span> {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">parser</span>.<span class="ruby-identifier">parse</span>(<span class="ruby-identifier">source</span>);
  }
});

<span class="ruby-identifier">exports</span>.<span class="ruby-identifier">run</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">dir</span>, <span class="ruby-identifier">mainModule</span>, <span class="ruby-identifier">ref</span>;
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
    <span class="ruby-identifier">options</span> = {};
  }
  <span class="ruby-identifier">mainModule</span> = <span class="ruby-identifier">require</span>.<span class="ruby-identifier">main</span>;
  <span class="ruby-identifier">mainModule</span>.<span class="ruby-identifier">filename</span> = <span class="ruby-identifier">process</span>.<span class="ruby-identifier">argv</span>[<span class="ruby-value">1</span>] = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">filename</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">fs</span>.<span class="ruby-identifier">realpathSync</span>(<span class="ruby-identifier">options</span>.<span class="ruby-identifier">filename</span>) <span class="ruby-operator">:</span> <span class="ruby-string">&#39;.&#39;</span>;
  <span class="ruby-identifier">mainModule</span>.<span class="ruby-identifier">moduleCache</span> <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">mainModule</span>.<span class="ruby-identifier">moduleCache</span> = {});
  <span class="ruby-identifier">dir</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">filename</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">path</span>.<span class="ruby-identifier">dirname</span>(<span class="ruby-identifier">fs</span>.<span class="ruby-identifier">realpathSync</span>(<span class="ruby-identifier">options</span>.<span class="ruby-identifier">filename</span>)) <span class="ruby-operator">:</span> <span class="ruby-identifier">fs</span>.<span class="ruby-identifier">realpathSync</span>(<span class="ruby-string">&#39;.&#39;</span>);
  <span class="ruby-identifier">mainModule</span>.<span class="ruby-identifier">paths</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&#39;module&#39;</span>).<span class="ruby-identifier">_nodeModulePaths</span>(<span class="ruby-identifier">dir</span>);
  <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">helpers</span>.<span class="ruby-identifier">isCoffee</span>(<span class="ruby-identifier">mainModule</span>.<span class="ruby-identifier">filename</span>) <span class="ruby-operator">||</span> <span class="ruby-identifier">require</span>.<span class="ruby-identifier">extensions</span>) {
    <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">compile</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>);
    <span class="ruby-identifier">code</span> = (<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">js</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">answer</span>;
  }
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">mainModule</span>.<span class="ruby-identifier">_compile</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">mainModule</span>.<span class="ruby-identifier">filename</span>);
};

<span class="ruby-identifier">exports</span>[<span class="ruby-string">&quot;eval&quot;</span>] = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-constant">Module</span>, <span class="ruby-identifier">_module</span>, <span class="ruby-identifier">_require</span>, <span class="ruby-identifier">createContext</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">isContext</span>, <span class="ruby-identifier">js</span>, <span class="ruby-identifier">k</span>, <span class="ruby-identifier">len</span>, <span class="ruby-identifier">o</span>, <span class="ruby-identifier">r</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">ref1</span>, <span class="ruby-identifier">ref2</span>, <span class="ruby-identifier">ref3</span>, <span class="ruby-identifier">sandbox</span>, <span class="ruby-identifier">v</span>;
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
    <span class="ruby-identifier">options</span> = {};
  }
  <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">code</span> = <span class="ruby-identifier">code</span>.<span class="ruby-identifier">trim</span>())) {
    <span class="ruby-keyword">return</span>;
  }
  <span class="ruby-identifier">createContext</span> = (<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">vm</span>.<span class="ruby-constant">Script</span>.<span class="ruby-identifier">createContext</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">vm</span>.<span class="ruby-identifier">createContext</span>;
  <span class="ruby-identifier">isContext</span> = (<span class="ruby-identifier">ref1</span> = <span class="ruby-identifier">vm</span>.<span class="ruby-identifier">isContext</span>) <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">ref1</span> <span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">ctx</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">options</span>.<span class="ruby-identifier">sandbox</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-identifier">createContext</span>().<span class="ruby-identifier">constructor</span>;
  };
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">createContext</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">sandbox</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span>) {
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">isContext</span>(<span class="ruby-identifier">options</span>.<span class="ruby-identifier">sandbox</span>)) {
        <span class="ruby-identifier">sandbox</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">sandbox</span>;
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">sandbox</span> = <span class="ruby-identifier">createContext</span>();
        <span class="ruby-identifier">ref2</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">sandbox</span>;
        <span class="ruby-keyword">for</span> (<span class="ruby-identifier">k</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">ref2</span>) {
          <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">hasProp</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">ref2</span>, <span class="ruby-identifier">k</span>)) <span class="ruby-identifier">continue</span>;
          <span class="ruby-identifier">v</span> = <span class="ruby-identifier">ref2</span>[<span class="ruby-identifier">k</span>];
          <span class="ruby-identifier">sandbox</span>[<span class="ruby-identifier">k</span>] = <span class="ruby-identifier">v</span>;
        }
      }
      <span class="ruby-identifier">sandbox</span>.<span class="ruby-identifier">global</span> = <span class="ruby-identifier">sandbox</span>.<span class="ruby-identifier">root</span> = <span class="ruby-identifier">sandbox</span>.<span class="ruby-constant">GLOBAL</span> = <span class="ruby-identifier">sandbox</span>;
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">sandbox</span> = <span class="ruby-identifier">global</span>;
    }
    <span class="ruby-identifier">sandbox</span>.<span class="ruby-identifier">__filename</span> = <span class="ruby-identifier">options</span>.<span class="ruby-identifier">filename</span> <span class="ruby-operator">||</span> <span class="ruby-string">&#39;eval&#39;</span>;
    <span class="ruby-identifier">sandbox</span>.<span class="ruby-identifier">__dirname</span> = <span class="ruby-identifier">path</span>.<span class="ruby-identifier">dirname</span>(<span class="ruby-identifier">sandbox</span>.<span class="ruby-identifier">__filename</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span>(<span class="ruby-identifier">sandbox</span> <span class="ruby-operator">!=</span>= <span class="ruby-identifier">global</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">sandbox</span>.<span class="ruby-identifier">module</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">sandbox</span>.<span class="ruby-identifier">require</span>)) {
      <span class="ruby-constant">Module</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&#39;module&#39;</span>);
      <span class="ruby-identifier">sandbox</span>.<span class="ruby-identifier">module</span> = <span class="ruby-identifier">_module</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Module</span>(<span class="ruby-identifier">options</span>.<span class="ruby-identifier">modulename</span> <span class="ruby-operator">||</span> <span class="ruby-string">&#39;eval&#39;</span>);
      <span class="ruby-identifier">sandbox</span>.<span class="ruby-identifier">require</span> = <span class="ruby-identifier">_require</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">path</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-constant">Module</span>.<span class="ruby-identifier">_load</span>(<span class="ruby-identifier">path</span>, <span class="ruby-identifier">_module</span>, <span class="ruby-keyword">true</span>);
      };
      <span class="ruby-identifier">_module</span>.<span class="ruby-identifier">filename</span> = <span class="ruby-identifier">sandbox</span>.<span class="ruby-identifier">__filename</span>;
      <span class="ruby-identifier">ref3</span> = <span class="ruby-constant">Object</span>.<span class="ruby-identifier">getOwnPropertyNames</span>(<span class="ruby-identifier">require</span>);
      <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len</span> = <span class="ruby-identifier">ref3</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len</span>; <span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
        <span class="ruby-identifier">r</span> = <span class="ruby-identifier">ref3</span>[<span class="ruby-identifier">i</span>];
        <span class="ruby-keyword">if</span> (<span class="ruby-identifier">r</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;paths&#39;</span>) {
          <span class="ruby-identifier">_require</span>[<span class="ruby-identifier">r</span>] = <span class="ruby-identifier">require</span>[<span class="ruby-identifier">r</span>];
        }
      }
      <span class="ruby-identifier">_require</span>.<span class="ruby-identifier">paths</span> = <span class="ruby-identifier">_module</span>.<span class="ruby-identifier">paths</span> = <span class="ruby-constant">Module</span>.<span class="ruby-identifier">_nodeModulePaths</span>(<span class="ruby-identifier">process</span>.<span class="ruby-identifier">cwd</span>());
      <span class="ruby-identifier">_require</span>.<span class="ruby-identifier">resolve</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">request</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-constant">Module</span>.<span class="ruby-identifier">_resolveFilename</span>(<span class="ruby-identifier">request</span>, <span class="ruby-identifier">_module</span>);
      };
    }
  }
  <span class="ruby-identifier">o</span> = {};
  <span class="ruby-keyword">for</span> (<span class="ruby-identifier">k</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">options</span>) {
    <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">hasProp</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">options</span>, <span class="ruby-identifier">k</span>)) <span class="ruby-identifier">continue</span>;
    <span class="ruby-identifier">v</span> = <span class="ruby-identifier">options</span>[<span class="ruby-identifier">k</span>];
    <span class="ruby-identifier">o</span>[<span class="ruby-identifier">k</span>] = <span class="ruby-identifier">v</span>;
  }
  <span class="ruby-identifier">o</span>.<span class="ruby-identifier">bare</span> = <span class="ruby-keyword">true</span>;
  <span class="ruby-identifier">js</span> = <span class="ruby-identifier">compile</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">o</span>);
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">sandbox</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">global</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">vm</span>.<span class="ruby-identifier">runInThisContext</span>(<span class="ruby-identifier">js</span>);
  } <span class="ruby-keyword">else</span> {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">vm</span>.<span class="ruby-identifier">runInContext</span>(<span class="ruby-identifier">js</span>, <span class="ruby-identifier">sandbox</span>);
  }
};

<span class="ruby-identifier">exports</span>.<span class="ruby-identifier">register</span> = <span class="ruby-identifier">function</span>() {
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">require</span>(<span class="ruby-string">&#39;./register&#39;</span>);
};

<span class="ruby-keyword">if</span> (<span class="ruby-identifier">require</span>.<span class="ruby-identifier">extensions</span>) {
  <span class="ruby-identifier">ref</span> = <span class="ruby-identifier">this</span>.<span class="ruby-constant">FILE_EXTENSIONS</span>;
  <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len</span> = <span class="ruby-identifier">ref</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len</span>; <span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
    <span class="ruby-identifier">ext</span> = <span class="ruby-identifier">ref</span>[<span class="ruby-identifier">i</span>];
    <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">base</span> = <span class="ruby-identifier">require</span>.<span class="ruby-identifier">extensions</span>)[<span class="ruby-identifier">ext</span>] <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
      <span class="ruby-identifier">base</span>[<span class="ruby-identifier">ext</span>] = <span class="ruby-identifier">function</span>() {
        <span class="ruby-identifier">throw</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Error</span>(<span class="ruby-string">&quot;Use CoffeeScript.register() or require the coffee-script/register module to require &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">ext</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; files.&quot;</span>);
      };
    }
  }
}

<span class="ruby-identifier">exports</span>.<span class="ruby-identifier">_compileFile</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">filename</span>, <span class="ruby-identifier">sourceMap</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">err</span>, <span class="ruby-identifier">raw</span>, <span class="ruby-identifier">stripped</span>;
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">sourceMap</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
    <span class="ruby-identifier">sourceMap</span> = <span class="ruby-keyword">false</span>;
  }
  <span class="ruby-identifier">raw</span> = <span class="ruby-identifier">fs</span>.<span class="ruby-identifier">readFileSync</span>(<span class="ruby-identifier">filename</span>, <span class="ruby-string">&#39;utf8&#39;</span>);
  <span class="ruby-identifier">stripped</span> = <span class="ruby-identifier">raw</span>.<span class="ruby-identifier">charCodeAt</span>(<span class="ruby-value">0</span>) <span class="ruby-operator">===</span> <span class="ruby-value">0xFEFF</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">raw</span>.<span class="ruby-identifier">substring</span>(<span class="ruby-value">1</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">raw</span>;
  <span class="ruby-identifier">try</span> {
    <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">compile</span>(<span class="ruby-identifier">stripped</span>, {
      <span class="ruby-identifier">filename</span><span class="ruby-operator">:</span> <span class="ruby-identifier">filename</span>,
      <span class="ruby-identifier">sourceMap</span><span class="ruby-operator">:</span> <span class="ruby-identifier">sourceMap</span>,
      <span class="ruby-identifier">literate</span><span class="ruby-operator">:</span> <span class="ruby-identifier">helpers</span>.<span class="ruby-identifier">isLiterate</span>(<span class="ruby-identifier">filename</span>)
    });
  } <span class="ruby-identifier">catch</span> (<span class="ruby-identifier">_error</span>) {
    <span class="ruby-identifier">err</span> = <span class="ruby-identifier">_error</span>;
    <span class="ruby-identifier">throw</span> <span class="ruby-identifier">helpers</span>.<span class="ruby-identifier">updateSyntaxError</span>(<span class="ruby-identifier">err</span>, <span class="ruby-identifier">stripped</span>, <span class="ruby-identifier">filename</span>);
  }
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">answer</span>;
};

<span class="ruby-identifier">lexer</span> = <span class="ruby-identifier">new</span> <span class="ruby-constant">Lexer</span>;

<span class="ruby-identifier">parser</span>.<span class="ruby-identifier">lexer</span> = {
  <span class="ruby-identifier">lex</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">tag</span>, <span class="ruby-identifier">token</span>;
    <span class="ruby-identifier">token</span> = <span class="ruby-identifier">parser</span>.<span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">this</span>.<span class="ruby-identifier">pos</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>];
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">token</span>) {
      <span class="ruby-identifier">tag</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">this</span>.<span class="ruby-identifier">yytext</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">this</span>.<span class="ruby-identifier">yylloc</span> = <span class="ruby-identifier">token</span>[<span class="ruby-value">2</span>];
      <span class="ruby-identifier">parser</span>.<span class="ruby-identifier">errorToken</span> = <span class="ruby-identifier">token</span>.<span class="ruby-identifier">origin</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">token</span>;
      <span class="ruby-identifier">this</span>.<span class="ruby-identifier">yylineno</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">yylloc</span>.<span class="ruby-identifier">first_line</span>;
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">tag</span> = <span class="ruby-string">&#39;&#39;</span>;
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">tag</span>;
  },
  <span class="ruby-identifier">setInput</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">tokens</span>) {
    <span class="ruby-identifier">parser</span>.<span class="ruby-identifier">tokens</span> = <span class="ruby-identifier">tokens</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">this</span>.<span class="ruby-identifier">pos</span> = <span class="ruby-value">0</span>;
  },
  <span class="ruby-identifier">upcomingInput</span><span class="ruby-operator">:</span> <span class="ruby-identifier">function</span>() {
    <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;&quot;</span>;
  }
};

<span class="ruby-identifier">parser</span>.<span class="ruby-identifier">yy</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&#39;./nodes&#39;</span>);

<span class="ruby-identifier">parser</span>.<span class="ruby-identifier">yy</span>.<span class="ruby-identifier">parseError</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">message</span>, <span class="ruby-identifier">arg</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">errorLoc</span>, <span class="ruby-identifier">errorTag</span>, <span class="ruby-identifier">errorText</span>, <span class="ruby-identifier">errorToken</span>, <span class="ruby-identifier">token</span>, <span class="ruby-identifier">tokens</span>;
  <span class="ruby-identifier">token</span> = <span class="ruby-identifier">arg</span>.<span class="ruby-identifier">token</span>;
  <span class="ruby-identifier">errorToken</span> = <span class="ruby-identifier">parser</span>.<span class="ruby-identifier">errorToken</span>, <span class="ruby-identifier">tokens</span> = <span class="ruby-identifier">parser</span>.<span class="ruby-identifier">tokens</span>;
  <span class="ruby-identifier">errorTag</span> = <span class="ruby-identifier">errorToken</span>[<span class="ruby-value">0</span>], <span class="ruby-identifier">errorText</span> = <span class="ruby-identifier">errorToken</span>[<span class="ruby-value">1</span>], <span class="ruby-identifier">errorLoc</span> = <span class="ruby-identifier">errorToken</span>[<span class="ruby-value">2</span>];
  <span class="ruby-identifier">errorText</span> = (<span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">switch</span> (<span class="ruby-keyword">false</span>) {
      <span class="ruby-keyword">case</span> <span class="ruby-identifier">errorToken</span> <span class="ruby-operator">!=</span>= <span class="ruby-identifier">tokens</span>[<span class="ruby-identifier">tokens</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>]<span class="ruby-operator">:</span>
        <span class="ruby-keyword">return</span> <span class="ruby-string">&#39;end of input&#39;</span>;
      <span class="ruby-keyword">case</span> <span class="ruby-identifier">errorTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;INDENT&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">errorTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;OUTDENT&#39;</span><span class="ruby-operator">:</span>
        <span class="ruby-keyword">return</span> <span class="ruby-string">&#39;indentation&#39;</span>;
      <span class="ruby-keyword">case</span> <span class="ruby-identifier">errorTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;IDENTIFIER&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">errorTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;NUMBER&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">errorTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;STRING&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">errorTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;STRING_START&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">errorTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;REGEX&#39;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">errorTag</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&#39;REGEX_START&#39;</span><span class="ruby-operator">:</span>
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">errorTag</span>.<span class="ruby-identifier">replace</span>(<span class="ruby-regexp">/_START$/</span>, <span class="ruby-string">&#39;&#39;</span>).<span class="ruby-identifier">toLowerCase</span>();
      <span class="ruby-identifier">default</span><span class="ruby-operator">:</span>
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">helpers</span>.<span class="ruby-identifier">nameWhitespaceCharacter</span>(<span class="ruby-identifier">errorText</span>);
    }
  })();
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">helpers</span>.<span class="ruby-identifier">throwSyntaxError</span>(<span class="ruby-string">&quot;unexpected &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">errorText</span>, <span class="ruby-identifier">errorLoc</span>);
};

<span class="ruby-identifier">formatSourcePosition</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">frame</span>, <span class="ruby-identifier">getSourceMapping</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">as</span>, <span class="ruby-identifier">column</span>, <span class="ruby-identifier">fileLocation</span>, <span class="ruby-identifier">fileName</span>, <span class="ruby-identifier">functionName</span>, <span class="ruby-identifier">isConstructor</span>, <span class="ruby-identifier">isMethodCall</span>, <span class="ruby-identifier">line</span>, <span class="ruby-identifier">methodName</span>, <span class="ruby-identifier">source</span>, <span class="ruby-identifier">tp</span>, <span class="ruby-identifier">typeName</span>;
  <span class="ruby-identifier">fileName</span> = <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>;
  <span class="ruby-identifier">fileLocation</span> = <span class="ruby-string">&#39;&#39;</span>;
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">frame</span>.<span class="ruby-identifier">isNative</span>()) {
    <span class="ruby-identifier">fileLocation</span> = <span class="ruby-string">&quot;native&quot;</span>;
  } <span class="ruby-keyword">else</span> {
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">frame</span>.<span class="ruby-identifier">isEval</span>()) {
      <span class="ruby-identifier">fileName</span> = <span class="ruby-identifier">frame</span>.<span class="ruby-identifier">getScriptNameOrSourceURL</span>();
      <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">fileName</span>) {
        <span class="ruby-identifier">fileLocation</span> = (<span class="ruby-identifier">frame</span>.<span class="ruby-identifier">getEvalOrigin</span>()) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;, &quot;</span>;
      }
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">fileName</span> = <span class="ruby-identifier">frame</span>.<span class="ruby-identifier">getFileName</span>();
    }
    <span class="ruby-identifier">fileName</span> <span class="ruby-operator">||</span> (<span class="ruby-identifier">fileName</span> = <span class="ruby-string">&quot;&lt;anonymous&gt;&quot;</span>);
    <span class="ruby-identifier">line</span> = <span class="ruby-identifier">frame</span>.<span class="ruby-identifier">getLineNumber</span>();
    <span class="ruby-identifier">column</span> = <span class="ruby-identifier">frame</span>.<span class="ruby-identifier">getColumnNumber</span>();
    <span class="ruby-identifier">source</span> = <span class="ruby-identifier">getSourceMapping</span>(<span class="ruby-identifier">fileName</span>, <span class="ruby-identifier">line</span>, <span class="ruby-identifier">column</span>);
    <span class="ruby-identifier">fileLocation</span> = <span class="ruby-identifier">source</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">fileName</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;:&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">source</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">+</span> <span class="ruby-string">&quot;:&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">source</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">:</span> <span class="ruby-identifier">fileName</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;:&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">line</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;:&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">column</span>;
  }
  <span class="ruby-identifier">functionName</span> = <span class="ruby-identifier">frame</span>.<span class="ruby-identifier">getFunctionName</span>();
  <span class="ruby-identifier">isConstructor</span> = <span class="ruby-identifier">frame</span>.<span class="ruby-identifier">isConstructor</span>();
  <span class="ruby-identifier">isMethodCall</span> = <span class="ruby-operator">!</span>(<span class="ruby-identifier">frame</span>.<span class="ruby-identifier">isToplevel</span>() <span class="ruby-operator">||</span> <span class="ruby-identifier">isConstructor</span>);
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">isMethodCall</span>) {
    <span class="ruby-identifier">methodName</span> = <span class="ruby-identifier">frame</span>.<span class="ruby-identifier">getMethodName</span>();
    <span class="ruby-identifier">typeName</span> = <span class="ruby-identifier">frame</span>.<span class="ruby-identifier">getTypeName</span>();
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">functionName</span>) {
      <span class="ruby-identifier">tp</span> = <span class="ruby-identifier">as</span> = <span class="ruby-string">&#39;&#39;</span>;
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">typeName</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">functionName</span>.<span class="ruby-identifier">indexOf</span>(<span class="ruby-identifier">typeName</span>)) {
        <span class="ruby-identifier">tp</span> = <span class="ruby-identifier">typeName</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.&quot;</span>;
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">methodName</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">functionName</span>.<span class="ruby-identifier">indexOf</span>(<span class="ruby-string">&quot;.&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">methodName</span>) <span class="ruby-operator">!=</span>= <span class="ruby-identifier">functionName</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-identifier">methodName</span>.<span class="ruby-identifier">length</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>) {
        <span class="ruby-identifier">as</span> = <span class="ruby-string">&quot; [as &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">methodName</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;]&quot;</span>;
      }
      <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">tp</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">functionName</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">as</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; (&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">fileLocation</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;)&quot;</span>;
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">typeName</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;.&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">methodName</span> <span class="ruby-operator">||</span> <span class="ruby-string">&#39;&lt;anonymous&gt;&#39;</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&quot; (&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">fileLocation</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;)&quot;</span>;
    }
  } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">isConstructor</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-string">&quot;new &quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">functionName</span> <span class="ruby-operator">||</span> <span class="ruby-string">&#39;&lt;anonymous&gt;&#39;</span>) <span class="ruby-operator">+</span> <span class="ruby-string">&quot; (&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">fileLocation</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;)&quot;</span>;
  } <span class="ruby-keyword">else</span> <span class="ruby-keyword">if</span> (<span class="ruby-identifier">functionName</span>) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">functionName</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot; (&quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">fileLocation</span> <span class="ruby-operator">+</span> <span class="ruby-string">&quot;)&quot;</span>;
  } <span class="ruby-keyword">else</span> {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">fileLocation</span>;
  }
};

<span class="ruby-identifier">sourceMaps</span> = {};

<span class="ruby-identifier">getSourceMap</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">filename</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">ref1</span>;
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">sourceMaps</span>[<span class="ruby-identifier">filename</span>]) {
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">sourceMaps</span>[<span class="ruby-identifier">filename</span>];
  }
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">ref1</span> = <span class="ruby-identifier">path</span> <span class="ruby-operator">!=</span> <span class="ruby-identifier">null</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">path</span>.<span class="ruby-identifier">extname</span>(<span class="ruby-identifier">filename</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">void</span> <span class="ruby-value">0</span>, <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">exports</span>.<span class="ruby-constant">FILE_EXTENSIONS</span>, <span class="ruby-identifier">ref1</span>) <span class="ruby-operator">&lt;</span> <span class="ruby-value">0</span>) {
    <span class="ruby-keyword">return</span>;
  }
  <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">exports</span>.<span class="ruby-identifier">_compileFile</span>(<span class="ruby-identifier">filename</span>, <span class="ruby-keyword">true</span>);
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">sourceMaps</span>[<span class="ruby-identifier">filename</span>] = <span class="ruby-identifier">answer</span>.<span class="ruby-identifier">sourceMap</span>;
};

<span class="ruby-constant">Error</span>.<span class="ruby-identifier">prepareStackTrace</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">err</span>, <span class="ruby-identifier">stack</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">frame</span>, <span class="ruby-identifier">frames</span>, <span class="ruby-identifier">getSourceMapping</span>;
  <span class="ruby-identifier">getSourceMapping</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">filename</span>, <span class="ruby-identifier">line</span>, <span class="ruby-identifier">column</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">answer</span>, <span class="ruby-identifier">sourceMap</span>;
    <span class="ruby-identifier">sourceMap</span> = <span class="ruby-identifier">getSourceMap</span>(<span class="ruby-identifier">filename</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">sourceMap</span>) {
      <span class="ruby-identifier">answer</span> = <span class="ruby-identifier">sourceMap</span>.<span class="ruby-identifier">sourceLocation</span>([<span class="ruby-identifier">line</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>, <span class="ruby-identifier">column</span> <span class="ruby-operator">-</span> <span class="ruby-value">1</span>]);
    }
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">answer</span>) {
      <span class="ruby-keyword">return</span> [<span class="ruby-identifier">answer</span>[<span class="ruby-value">0</span>] <span class="ruby-operator">+</span> <span class="ruby-value">1</span>, <span class="ruby-identifier">answer</span>[<span class="ruby-value">1</span>] <span class="ruby-operator">+</span> <span class="ruby-value">1</span>];
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">null</span>;
    }
  };
  <span class="ruby-identifier">frames</span> = (<span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len1</span>, <span class="ruby-identifier">results</span>;
    <span class="ruby-identifier">results</span> = [];
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len1</span> = <span class="ruby-identifier">stack</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len1</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">frame</span> = <span class="ruby-identifier">stack</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">frame</span>.<span class="ruby-identifier">getFunction</span>() <span class="ruby-operator">===</span> <span class="ruby-identifier">exports</span>.<span class="ruby-identifier">run</span>) {
        <span class="ruby-keyword">break</span>;
      }
      <span class="ruby-identifier">results</span>.<span class="ruby-identifier">push</span>(<span class="ruby-string">&quot;  at &quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">formatSourcePosition</span>(<span class="ruby-identifier">frame</span>, <span class="ruby-identifier">getSourceMapping</span>)));
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">results</span>;
  })();
  <span class="ruby-keyword">return</span> (<span class="ruby-identifier">err</span>.<span class="ruby-identifier">toString</span>()) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\n&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">frames</span>.<span class="ruby-identifier">join</span>(<span class="ruby-string">&#39;\n&#39;</span>)) <span class="ruby-operator">+</span> <span class="ruby-string">&quot;\n&quot;</span>;
};
</pre>

<p>}).call(this);</p>

<pre>return module.exports;</pre>

<p>})();<a href="http://'./browser'">require</a> = (function() {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-identifier">exports</span> = {}, <span class="ruby-identifier">module</span> = {<span class="ruby-identifier">exports</span><span class="ruby-operator">:</span> <span class="ruby-identifier">exports</span>};
<span class="ruby-regexp">//</span> <span class="ruby-constant">Generated</span> <span class="ruby-identifier">by</span> <span class="ruby-constant">CoffeeScript</span> <span class="ruby-value">1.9</span><span class="ruby-value">.1</span>
</pre>

<p>(function() {</p>

<pre class="ruby"><span class="ruby-identifier">var</span> <span class="ruby-constant">CoffeeScript</span>, <span class="ruby-identifier">compile</span>, <span class="ruby-identifier">runScripts</span>,
  <span class="ruby-identifier">indexOf</span> = [].<span class="ruby-identifier">indexOf</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">function</span>(<span class="ruby-identifier">item</span>) { <span class="ruby-keyword">for</span> (<span class="ruby-identifier">var</span> <span class="ruby-identifier">i</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">l</span> = <span class="ruby-identifier">this</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">i</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">l</span>; <span class="ruby-identifier">i</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) { <span class="ruby-keyword">if</span> (<span class="ruby-identifier">i</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">this</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">this</span>[<span class="ruby-identifier">i</span>] <span class="ruby-operator">===</span> <span class="ruby-identifier">item</span>) <span class="ruby-keyword">return</span> <span class="ruby-identifier">i</span>; } <span class="ruby-keyword">return</span> <span class="ruby-value">-1</span>; };

<span class="ruby-constant">CoffeeScript</span> = <span class="ruby-identifier">require</span>(<span class="ruby-string">&#39;./coffee-script&#39;</span>);

<span class="ruby-constant">CoffeeScript</span>.<span class="ruby-identifier">require</span> = <span class="ruby-identifier">require</span>;

<span class="ruby-identifier">compile</span> = <span class="ruby-constant">CoffeeScript</span>.<span class="ruby-identifier">compile</span>;

<span class="ruby-constant">CoffeeScript</span>[<span class="ruby-string">&quot;eval&quot;</span>] = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>) {
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
    <span class="ruby-identifier">options</span> = {};
  }
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span>.<span class="ruby-identifier">bare</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
    <span class="ruby-identifier">options</span>.<span class="ruby-identifier">bare</span> = <span class="ruby-keyword">true</span>;
  }
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">eval</span>(<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>));
};

<span class="ruby-constant">CoffeeScript</span>.<span class="ruby-identifier">run</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>) {
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
    <span class="ruby-identifier">options</span> = {};
  }
  <span class="ruby-identifier">options</span>.<span class="ruby-identifier">bare</span> = <span class="ruby-keyword">true</span>;
  <span class="ruby-identifier">options</span>.<span class="ruby-identifier">shiftLine</span> = <span class="ruby-keyword">true</span>;
  <span class="ruby-keyword">return</span> <span class="ruby-constant">Function</span>(<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>))();
};

<span class="ruby-keyword">if</span> (<span class="ruby-identifier">typeof</span> <span class="ruby-identifier">window</span> <span class="ruby-operator">===</span> <span class="ruby-string">&quot;undefined&quot;</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">window</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">null</span>) {
  <span class="ruby-keyword">return</span>;
}

<span class="ruby-keyword">if</span> ((<span class="ruby-identifier">typeof</span> <span class="ruby-identifier">btoa</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&quot;undefined&quot;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">btoa</span> <span class="ruby-operator">!=</span>= <span class="ruby-identifier">null</span>) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">typeof</span> <span class="ruby-constant">JSON</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&quot;undefined&quot;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-constant">JSON</span> <span class="ruby-operator">!=</span>= <span class="ruby-identifier">null</span>) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">typeof</span> <span class="ruby-identifier">unescape</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&quot;undefined&quot;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">unescape</span> <span class="ruby-operator">!=</span>= <span class="ruby-identifier">null</span>) <span class="ruby-operator">&amp;&amp;</span> (<span class="ruby-identifier">typeof</span> <span class="ruby-identifier">encodeURIComponent</span> <span class="ruby-operator">!=</span>= <span class="ruby-string">&quot;undefined&quot;</span> <span class="ruby-operator">&amp;&amp;</span> <span class="ruby-identifier">encodeURIComponent</span> <span class="ruby-operator">!=</span>= <span class="ruby-identifier">null</span>)) {
  <span class="ruby-identifier">compile</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">js</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">v3SourceMap</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
      <span class="ruby-identifier">options</span> = {};
    }
    <span class="ruby-identifier">options</span>.<span class="ruby-identifier">sourceMap</span> = <span class="ruby-keyword">true</span>;
    <span class="ruby-identifier">options</span>.<span class="ruby-identifier">inline</span> = <span class="ruby-keyword">true</span>;
    <span class="ruby-identifier">ref</span> = <span class="ruby-constant">CoffeeScript</span>.<span class="ruby-identifier">compile</span>(<span class="ruby-identifier">code</span>, <span class="ruby-identifier">options</span>), <span class="ruby-identifier">js</span> = <span class="ruby-identifier">ref</span>.<span class="ruby-identifier">js</span>, <span class="ruby-identifier">v3SourceMap</span> = <span class="ruby-identifier">ref</span>.<span class="ruby-identifier">v3SourceMap</span>;
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">js</span> <span class="ruby-operator">+</span> <span class="ruby-node">&quot;\n//# sourceMappingURL=data:application/json;base64,&quot;</span> <span class="ruby-operator">+</span> (<span class="ruby-identifier">btoa</span>(<span class="ruby-identifier">unescape</span>(<span class="ruby-identifier">encodeURIComponent</span>(<span class="ruby-identifier">v3SourceMap</span>)))) <span class="ruby-operator">+</span> <span class="ruby-node">&quot;\n//# sourceURL=coffeescript&quot;</span>;
  };
}

<span class="ruby-constant">CoffeeScript</span>.<span class="ruby-identifier">load</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">url</span>, <span class="ruby-identifier">callback</span>, <span class="ruby-identifier">options</span>, <span class="ruby-identifier">hold</span>) {
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">xhr</span>;
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">options</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
    <span class="ruby-identifier">options</span> = {};
  }
  <span class="ruby-keyword">if</span> (<span class="ruby-identifier">hold</span> <span class="ruby-operator">==</span> <span class="ruby-identifier">null</span>) {
    <span class="ruby-identifier">hold</span> = <span class="ruby-keyword">false</span>;
  }
  <span class="ruby-identifier">options</span>.<span class="ruby-identifier">sourceFiles</span> = [<span class="ruby-identifier">url</span>];
  <span class="ruby-identifier">xhr</span> = <span class="ruby-identifier">window</span>.<span class="ruby-constant">ActiveXObject</span> <span class="ruby-operator">?</span> <span class="ruby-identifier">new</span> <span class="ruby-identifier">window</span>.<span class="ruby-constant">ActiveXObject</span>(<span class="ruby-string">&#39;Microsoft.XMLHTTP&#39;</span>) <span class="ruby-operator">:</span> <span class="ruby-identifier">new</span> <span class="ruby-identifier">window</span>.<span class="ruby-constant">XMLHttpRequest</span>();
  <span class="ruby-identifier">xhr</span>.<span class="ruby-identifier">open</span>(<span class="ruby-string">&#39;GET&#39;</span>, <span class="ruby-identifier">url</span>, <span class="ruby-keyword">true</span>);
  <span class="ruby-keyword">if</span> (<span class="ruby-string">&#39;overrideMimeType&#39;</span> <span class="ruby-keyword">in</span> <span class="ruby-identifier">xhr</span>) {
    <span class="ruby-identifier">xhr</span>.<span class="ruby-identifier">overrideMimeType</span>(<span class="ruby-string">&#39;text/plain&#39;</span>);
  }
  <span class="ruby-identifier">xhr</span>.<span class="ruby-identifier">onreadystatechange</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">param</span>, <span class="ruby-identifier">ref</span>;
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">xhr</span>.<span class="ruby-identifier">readyState</span> <span class="ruby-operator">===</span> <span class="ruby-value">4</span>) {
      <span class="ruby-keyword">if</span> ((<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">xhr</span>.<span class="ruby-identifier">status</span>) <span class="ruby-operator">===</span> <span class="ruby-value">0</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">ref</span> <span class="ruby-operator">===</span> <span class="ruby-value">200</span>) {
        <span class="ruby-identifier">param</span> = [<span class="ruby-identifier">xhr</span>.<span class="ruby-identifier">responseText</span>, <span class="ruby-identifier">options</span>];
        <span class="ruby-keyword">if</span> (<span class="ruby-operator">!</span><span class="ruby-identifier">hold</span>) {
          <span class="ruby-constant">CoffeeScript</span>.<span class="ruby-identifier">run</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-constant">CoffeeScript</span>, <span class="ruby-identifier">param</span>);
        }
      } <span class="ruby-keyword">else</span> {
        <span class="ruby-identifier">throw</span> <span class="ruby-identifier">new</span> <span class="ruby-constant">Error</span>(<span class="ruby-string">&quot;Could not load &quot;</span> <span class="ruby-operator">+</span> <span class="ruby-identifier">url</span>);
      }
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">callback</span>) {
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">callback</span>(<span class="ruby-identifier">param</span>);
      }
    }
  };
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">xhr</span>.<span class="ruby-identifier">send</span>(<span class="ruby-identifier">null</span>);
};

<span class="ruby-identifier">runScripts</span> = <span class="ruby-identifier">function</span>() {
  <span class="ruby-identifier">var</span> <span class="ruby-identifier">coffees</span>, <span class="ruby-identifier">coffeetypes</span>, <span class="ruby-identifier">execute</span>, <span class="ruby-identifier">fn</span>, <span class="ruby-identifier">i</span>, <span class="ruby-identifier">index</span>, <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len</span>, <span class="ruby-identifier">s</span>, <span class="ruby-identifier">script</span>, <span class="ruby-identifier">scripts</span>;
  <span class="ruby-identifier">scripts</span> = <span class="ruby-identifier">window</span>.<span class="ruby-identifier">document</span>.<span class="ruby-identifier">getElementsByTagName</span>(<span class="ruby-string">&#39;script&#39;</span>);
  <span class="ruby-identifier">coffeetypes</span> = [<span class="ruby-string">&#39;text/coffeescript&#39;</span>, <span class="ruby-string">&#39;text/literate-coffeescript&#39;</span>];
  <span class="ruby-identifier">coffees</span> = (<span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">j</span>, <span class="ruby-identifier">len</span>, <span class="ruby-identifier">ref</span>, <span class="ruby-identifier">results</span>;
    <span class="ruby-identifier">results</span> = [];
    <span class="ruby-keyword">for</span> (<span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len</span> = <span class="ruby-identifier">scripts</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len</span>; <span class="ruby-identifier">j</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>) {
      <span class="ruby-identifier">s</span> = <span class="ruby-identifier">scripts</span>[<span class="ruby-identifier">j</span>];
      <span class="ruby-keyword">if</span> (<span class="ruby-identifier">ref</span> = <span class="ruby-identifier">s</span>.<span class="ruby-identifier">type</span>, <span class="ruby-identifier">indexOf</span>.<span class="ruby-identifier">call</span>(<span class="ruby-identifier">coffeetypes</span>, <span class="ruby-identifier">ref</span>) <span class="ruby-operator">&gt;=</span> <span class="ruby-value">0</span>) {
        <span class="ruby-identifier">results</span>.<span class="ruby-identifier">push</span>(<span class="ruby-identifier">s</span>);
      }
    }
    <span class="ruby-keyword">return</span> <span class="ruby-identifier">results</span>;
  })();
  <span class="ruby-identifier">index</span> = <span class="ruby-value">0</span>;
  <span class="ruby-identifier">execute</span> = <span class="ruby-identifier">function</span>() {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">param</span>;
    <span class="ruby-identifier">param</span> = <span class="ruby-identifier">coffees</span>[<span class="ruby-identifier">index</span>];
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">param</span> <span class="ruby-identifier">instanceof</span> <span class="ruby-constant">Array</span>) {
      <span class="ruby-constant">CoffeeScript</span>.<span class="ruby-identifier">run</span>.<span class="ruby-identifier">apply</span>(<span class="ruby-constant">CoffeeScript</span>, <span class="ruby-identifier">param</span>);
      <span class="ruby-identifier">index</span><span class="ruby-operator">+</span><span class="ruby-operator">+</span>;
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">execute</span>();
    }
  };
  <span class="ruby-identifier">fn</span> = <span class="ruby-identifier">function</span>(<span class="ruby-identifier">script</span>, <span class="ruby-identifier">i</span>) {
    <span class="ruby-identifier">var</span> <span class="ruby-identifier">options</span>, <span class="ruby-identifier">source</span>;
    <span class="ruby-identifier">options</span> = {
      <span class="ruby-identifier">literate</span><span class="ruby-operator">:</span> <span class="ruby-identifier">script</span>.<span class="ruby-identifier">type</span> <span class="ruby-operator">===</span> <span class="ruby-identifier">coffeetypes</span>[<span class="ruby-value">1</span>]
    };
    <span class="ruby-identifier">source</span> = <span class="ruby-identifier">script</span>.<span class="ruby-identifier">src</span> <span class="ruby-operator">||</span> <span class="ruby-identifier">script</span>.<span class="ruby-identifier">getAttribute</span>(<span class="ruby-string">&#39;data-src&#39;</span>);
    <span class="ruby-keyword">if</span> (<span class="ruby-identifier">source</span>) {
      <span class="ruby-keyword">return</span> <span class="ruby-constant">CoffeeScript</span>.<span class="ruby-identifier">load</span>(<span class="ruby-identifier">source</span>, <span class="ruby-identifier">function</span>(<span class="ruby-identifier">param</span>) {
        <span class="ruby-identifier">coffees</span>[<span class="ruby-identifier">i</span>] = <span class="ruby-identifier">param</span>;
        <span class="ruby-keyword">return</span> <span class="ruby-identifier">execute</span>();
      }, <span class="ruby-identifier">options</span>, <span class="ruby-keyword">true</span>);
    } <span class="ruby-keyword">else</span> {
      <span class="ruby-identifier">options</span>.<span class="ruby-identifier">sourceFiles</span> = [<span class="ruby-string">&#39;embedded&#39;</span>];
      <span class="ruby-keyword">return</span> <span class="ruby-identifier">coffees</span>[<span class="ruby-identifier">i</span>] = [<span class="ruby-identifier">script</span>.<span class="ruby-identifier">innerHTML</span>, <span class="ruby-identifier">options</span>];
    }
  };
  <span class="ruby-keyword">for</span> (<span class="ruby-identifier">i</span> = <span class="ruby-identifier">j</span> = <span class="ruby-value">0</span>, <span class="ruby-identifier">len</span> = <span class="ruby-identifier">coffees</span>.<span class="ruby-identifier">length</span>; <span class="ruby-identifier">j</span> <span class="ruby-operator">&lt;</span> <span class="ruby-identifier">len</span>; <span class="ruby-identifier">i</span> = <span class="ruby-operator">+</span><span class="ruby-operator">+</span><span class="ruby-identifier">j</span>) {
    <span class="ruby-identifier">script</span> = <span class="ruby-identifier">coffees</span>[<span class="ruby-identifier">i</span>];
    <span class="ruby-identifier">fn</span>(<span class="ruby-identifier">script</span>, <span class="ruby-identifier">i</span>);
  }
  <span class="ruby-keyword">return</span> <span class="ruby-identifier">execute</span>();
};

<span class="ruby-keyword">if</span> (<span class="ruby-identifier">window</span>.<span class="ruby-identifier">addEventListener</span>) {
  <span class="ruby-identifier">window</span>.<span class="ruby-identifier">addEventListener</span>(<span class="ruby-string">&#39;DOMContentLoaded&#39;</span>, <span class="ruby-identifier">runScripts</span>, <span class="ruby-keyword">false</span>);
} <span class="ruby-keyword">else</span> {
  <span class="ruby-identifier">window</span>.<span class="ruby-identifier">attachEvent</span>(<span class="ruby-string">&#39;onload&#39;</span>, <span class="ruby-identifier">runScripts</span>);
}
</pre>

<p>}).call(this);</p>

<pre>return module.exports;</pre>

<p>})();</p>

<pre>  return require[&#39;./coffee-script&#39;];
}();

if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {
  define(function() { return CoffeeScript; });
} else {
  root.CoffeeScript = CoffeeScript;
}</pre>

<p>}(this));</p>

</div>



<footer id="validator-badges">
  <p><a href="http://validator.w3.org/check/referer">[Validate]</a>
  <p>Generated by <a href="https://github.com/rdoc/rdoc">RDoc</a> 4.0.0.
  <p>Generated with the <a href="http://deveiate.org/projects/Darkfish-Rdoc/">Darkfish Rdoc Generator</a> 3.
</footer>

