var search_data = {"index":{"searchIndex":["syntax","ansic","css21","convertors","abstract","html","default","fortran","javascript","ruby","sqlite","token","tokenizer","version","xml","yaml","add_function()","add_type()","all()","all()","append()","convert()","delegate()","end_region()","finish()","flush_chunk()","for_syntax()","html_escape()","load()","load()","m()","macro()","new()","new()","option()","scan_delimited_region()","scan_heredoc()","scan_string()","scan_string()","set()","setup()","setup()","setup()","setup()","start()","start_group()","start_region()","step()","step()","step()","step()","step()","step()","step()","step()","step()","subgroup()","subtokenize()","teardown()","token()","tokenize()","tokenize()"],"longSearchIndex":["syntax","syntax::ansic","syntax::css21","syntax::convertors","syntax::convertors::abstract","syntax::convertors::html","syntax::default","syntax::fortran","syntax::javascript","syntax::ruby","syntax::sqlite","syntax::token","syntax::tokenizer","syntax::version","syntax::xml","syntax::yaml","syntax::sqlite::add_function()","syntax::ansic::add_type()","syntax::all()","syntax#all()","syntax::tokenizer#append()","syntax::convertors::html#convert()","syntax::tokenizer::delegate()","syntax::tokenizer#end_region()","syntax::tokenizer#finish()","syntax::tokenizer#flush_chunk()","syntax::convertors::abstract::for_syntax()","syntax::convertors::html#html_escape()","syntax#load()","syntax::load()","syntax::css21#m()","syntax::css21#macro()","syntax::convertors::abstract::new()","syntax::token::new()","syntax::tokenizer#option()","syntax::ruby#scan_delimited_region()","syntax::ruby#scan_heredoc()","syntax::xml#scan_string()","syntax::yaml#scan_string()","syntax::tokenizer#set()","syntax::css21#setup()","syntax::ruby#setup()","syntax::tokenizer#setup()","syntax::xml#setup()","syntax::tokenizer#start()","syntax::tokenizer#start_group()","syntax::tokenizer#start_region()","syntax::ansic#step()","syntax::css21#step()","syntax::fortran#step()","syntax::javascript#step()","syntax::ruby#step()","syntax::sqlite#step()","syntax::tokenizer#step()","syntax::xml#step()","syntax::yaml#step()","syntax::tokenizer#subgroup()","syntax::tokenizer#subtokenize()","syntax::tokenizer#teardown()","syntax::css21#token()","syntax::default#tokenize()","syntax::tokenizer#tokenize()"],"info":[["Syntax","","Syntax.html","",""],["Syntax::AnsiC","","Syntax/AnsiC.html","",""],["Syntax::CSS21","","Syntax/CSS21.html","",""],["Syntax::Convertors","","Syntax/Convertors.html","",""],["Syntax::Convertors::Abstract","","Syntax/Convertors/Abstract.html","","<p>The abstract ancestor class for all convertors. It implements a few\nconvenience methods to provide a …\n"],["Syntax::Convertors::HTML","","Syntax/Convertors/HTML.html","","<p>A simple class for converting a text into HTML.\n"],["Syntax::Default","","Syntax/Default.html","","<p>A default tokenizer for handling syntaxes that are not explicitly handled\nelsewhere. It simply yields …\n"],["Syntax::Fortran","","Syntax/Fortran.html","","<p>A tokenizer for free-form Fortran source code.\n"],["Syntax::Javascript","","Syntax/Javascript.html","",""],["Syntax::Ruby","","Syntax/Ruby.html","","<p>A tokenizer for the Ruby language. It recognizes all common syntax (and\nsome less common syntax) but …\n"],["Syntax::SQLite","","Syntax/SQLite.html","",""],["Syntax::Token","","Syntax/Token.html","","<p>A single token extracted by a tokenizer. It is simply the lexeme itself,\ndecorated with a &#39;group&#39; …\n"],["Syntax::Tokenizer","","Syntax/Tokenizer.html","","<p>The base class of all tokenizers. It sets up the scanner and manages the\nlooping until all tokens have …\n"],["Syntax::Version","","Syntax/Version.html","",""],["Syntax::XML","","Syntax/XML.html","","<p>A simple implementation of an XML lexer. It handles most cases. It is not a\nvalidating lexer, meaning …\n"],["Syntax::YAML","","Syntax/YAML.html","","<p>A simple implementation of an YAML lexer. It handles most cases. It is not\na validating lexer.\n"],["add_function","Syntax::SQLite","Syntax/SQLite.html#method-c-add_function","(name)",""],["add_type","Syntax::AnsiC","Syntax/AnsiC.html#method-c-add_type","(name)",""],["all","Syntax","Syntax.html#method-c-all","()","<p>Return an array of the names of supported syntaxes.\n"],["all","Syntax","Syntax.html#method-i-all","()","<p>Return an array of the names of supported syntaxes.\n"],["append","Syntax::Tokenizer","Syntax/Tokenizer.html#method-i-append","( data )","<p>Append the given data to the currently active chunk.\n"],["convert","Syntax::Convertors::HTML","Syntax/Convertors/HTML.html#method-i-convert","( text, pre=true )","<p>Converts the given text to HTML, using spans to represent token groups of\nany type but <code>:normal</code> (which …\n"],["delegate","Syntax::Tokenizer","Syntax/Tokenizer.html#method-c-delegate","( sym )","<p>A convenience for delegating method calls to the scanner.\n"],["end_region","Syntax::Tokenizer","Syntax/Tokenizer.html#method-i-end_region","( gr, data=nil )",""],["finish","Syntax::Tokenizer","Syntax/Tokenizer.html#method-i-finish","()","<p>Finish tokenizing. This flushes the buffer, yielding any remaining text to\nthe client.\n"],["flush_chunk","Syntax::Tokenizer","Syntax/Tokenizer.html#method-i-flush_chunk","()",""],["for_syntax","Syntax::Convertors::Abstract","Syntax/Convertors/Abstract.html#method-c-for_syntax","( syntax )","<p>A convenience method for instantiating a new convertor for a specific\nsyntax.\n"],["html_escape","Syntax::Convertors::HTML","Syntax/Convertors/HTML.html#method-i-html_escape","( string )","<p>Replaces some characters with their corresponding HTML entities.\n"],["load","Syntax","Syntax.html#method-i-load","( syntax )","<p>Load the implementation of the requested syntax. If the syntax cannot be\nfound, or if it cannot be loaded …\n"],["load","Syntax","Syntax.html#method-c-load","( syntax )","<p>Load the implementation of the requested syntax. If the syntax cannot be\nfound, or if it cannot be loaded …\n"],["m","Syntax::CSS21","Syntax/CSS21.html#method-i-m","(name, regex=nil)",""],["macro","Syntax::CSS21","Syntax/CSS21.html#method-i-macro","(name, regex=nil)",""],["new","Syntax::Convertors::Abstract","Syntax/Convertors/Abstract.html#method-c-new","( tokenizer )","<p>Creates a new convertor that uses the given tokenizer.\n"],["new","Syntax::Token","Syntax/Token.html#method-c-new","( text, group, instruction = :none )","<p>Create a new Token representing the given text, and belonging to the given\ngroup.\n"],["option","Syntax::Tokenizer","Syntax/Tokenizer.html#method-i-option","(opt)","<p>Get the value of the specified option.\n"],["scan_delimited_region","Syntax::Ruby","Syntax/Ruby.html#method-i-scan_delimited_region","( delim_group, inner_group, starter, exprs, delim=nil, heredoc=false )","<p>Scan a delimited region of text. This handles the simple cases (strings\ndelimited with quotes) as well …\n"],["scan_heredoc","Syntax::Ruby","Syntax/Ruby.html#method-i-scan_heredoc","(float, type, delim)","<p>Scan a heredoc beginning at the current position.\n<p><code>float</code> indicates whether the delimiter may be floated …\n"],["scan_string","Syntax::XML","Syntax/XML.html#method-i-scan_string","( delim )","<p>Scan the string starting at the current position, with the given delimiter\ncharacter.\n"],["scan_string","Syntax::YAML","Syntax/YAML.html#method-i-scan_string","( delim )",""],["set","Syntax::Tokenizer","Syntax/Tokenizer.html#method-i-set","( opts={} )","<p>Specify a set of tokenizer-specific options. Each tokenizer may (or may\nnot) publish any options, but …\n"],["setup","Syntax::CSS21","Syntax/CSS21.html#method-i-setup","()",""],["setup","Syntax::Ruby","Syntax/Ruby.html#method-i-setup","()","<p>Perform ruby-specific setup\n"],["setup","Syntax::Tokenizer","Syntax/Tokenizer.html#method-i-setup","()","<p>Subclasses may override this method to provide implementation-specific\nsetup logic.\n"],["setup","Syntax::XML","Syntax/XML.html#method-i-setup","()","<p>Initialize the lexer.\n"],["start","Syntax::Tokenizer","Syntax/Tokenizer.html#method-i-start","( text, &block )","<p>Start tokenizing. This sets up the state in preparation for tokenization,\nsuch as creating a new scanner …\n"],["start_group","Syntax::Tokenizer","Syntax/Tokenizer.html#method-i-start_group","( gr, data=nil )","<p>Request that a new group be started. If the current group is the same as\nthe group being requested, a …\n"],["start_region","Syntax::Tokenizer","Syntax/Tokenizer.html#method-i-start_region","( gr, data=nil )",""],["step","Syntax::AnsiC","Syntax/AnsiC.html#method-i-step","()",""],["step","Syntax::CSS21","Syntax/CSS21.html#method-i-step","()",""],["step","Syntax::Fortran","Syntax/Fortran.html#method-i-step","()","<p>Step through a single iteration of the tokenization process.\n"],["step","Syntax::Javascript","Syntax/Javascript.html#method-i-step","()",""],["step","Syntax::Ruby","Syntax/Ruby.html#method-i-step","()","<p>Step through a single iteration of the tokenization process.\n"],["step","Syntax::SQLite","Syntax/SQLite.html#method-i-step","()",""],["step","Syntax::Tokenizer","Syntax/Tokenizer.html#method-i-step","()","<p>Subclasses must implement this method, which is called for each iteration\nof the tokenization process. …\n"],["step","Syntax::XML","Syntax/XML.html#method-i-step","()","<p>Step through a single iteration of the tokenization process. This will\nyield (potentially) many tokens, …\n"],["step","Syntax::YAML","Syntax/YAML.html#method-i-step","()","<p>Step through a single iteration of the tokenization process. This will\nyield (potentially) many tokens, …\n"],["subgroup","Syntax::Tokenizer","Syntax/Tokenizer.html#method-i-subgroup","(n)","<p>Access the n-th subgroup from the most recent match.\n"],["subtokenize","Syntax::Tokenizer","Syntax/Tokenizer.html#method-i-subtokenize","( syntax, text )",""],["teardown","Syntax::Tokenizer","Syntax/Tokenizer.html#method-i-teardown","()","<p>Subclasses may override this method to provide implementation-specific\nteardown logic.\n"],["token","Syntax::CSS21","Syntax/CSS21.html#method-i-token","(name, pattern=nil, &block)",""],["tokenize","Syntax::Default","Syntax/Default.html#method-i-tokenize","( text )","<p>Yield the given text as a single token.\n"],["tokenize","Syntax::Tokenizer","Syntax/Tokenizer.html#method-i-tokenize","( text, &block )","<p>Begins tokenizing the given text, calling #step until the text has been\nexhausted.\n"]]}}