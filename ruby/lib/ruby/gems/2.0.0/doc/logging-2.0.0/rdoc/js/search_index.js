var search_data = {"index":{"searchIndex":["file","fileutils","logging","appender","appenders","buffering","periodicflusher","file","io","rollingfile","roller","stderr","stdout","stringio","iotos","syslog","colorscheme","filter","filters","level","layout","layouts","basic","parseable","layout;","pattern","formatmethodbuilder","logger","logger","mappeddiagnosticcontext","nesteddiagnosticcontext","plugins","proxy","railscompat","repository","singleton","rootlogger","logger","module","object","rspec","core","configuration","logginghelper","logginghelper","reentrantmutex","spec","runner","configuration","string","thread","<<()","<<()","<<()","<<()","<=>()","<=>()","<=>()","[]()","[]()","[]()","[]()","[]()","[]()","[]()","[]=()","[]=()","[]=()","[]=()","[]=()","_parse_hours_minutes_seconds()","_parse_numeric()","_setup_periodic_flusher()","add()","add()","add_appenders()","add_appenders()","add_filters()","additive=()","additive=()","age_fn_mtime()","allow()","allow()","allow()","append()","appenders()","appenders()","appenders()","appenders=()","appenders=()","assert_valid_logfile()","auto_flushing=()","backtrace()","basic()","build_singleton_methods()","caller_tracing=()","caller_tracing=()","canonical_write()","canonical_write()","capture_log_messages()","capture_log_messages()","children()","clear()","clear()","clear()","clear!()","clear_appenders()","clear_appenders()","clear_context()","clear_diagnostic_contexts()","close()","close()","close()","close()","closed?()","closed?()","color()","color_scheme()","concat()","concat()","configure_buffering()","context()","context()","copy_file()","copy_file()","copy_truncate()","create_format_method()","date_method=()","date_pattern=()","define_log_methods()","define_log_methods()","define_log_methods()","define_log_methods()","delete()","delete()","each()","encoding()","encoding=()","fetch()","file()","filename()","filename()","filename()","filters=()","flatten()","flock?()","flock_sh()","flush()","flush()","flush_period=()","footer()","format()","format()","format()","format_as()","format_obj()","format_obj()","formatter()","glob()","globally()","has_logger?()","header()","immediate?()","immediate_at=()","include?()","inherit()","inherit()","init()","inspect()","inspect()","inspect()","instantiate()","instantiate()","io()","iso8601_format()","items=()","json()","json()","layout=()","layouts()","level()","level()","level=()","level=()","level=()","level=()","levels?()","libpath()","lines?()","load_from_hash()","log_event()","log_event()","logger()","logger_name()","map=()","mdc()","method_missing()","ndc()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","off?()","original_synchronize()","parent()","parent=()","parent=()","parent_name()","parseable()","path()","pattern()","pattern=()","peek()","peek()","pop()","pop()","push()","push()","remove()","remove_appenders()","remove_appenders()","reopen()","reopen()","reopen()","reopen()","reopen()","reopen()","reopen()","reset()","reset()","roll_by_date()","roll_by_number()","roll_files()","roll_required?()","rolling_file()","root()","root()","sanitize()","show_configuration()","shrink()","silence()","stack()","stderr()","stdout()","string_io()","sync()","synchronize()","syslog()","syslog_level_num()","to_constant()","to_key()","to_key()","try_json()","try_yaml()","update()","version()","write()","write()","write()","write()","write()","yaml()","yaml()","history"],"longSearchIndex":["file","fileutils","logging","logging::appender","logging::appenders","logging::appenders::buffering","logging::appenders::buffering::periodicflusher","logging::appenders::file","logging::appenders::io","logging::appenders::rollingfile","logging::appenders::rollingfile::roller","logging::appenders::stderr","logging::appenders::stdout","logging::appenders::stringio","logging::appenders::stringio::iotos","logging::appenders::syslog","logging::colorscheme","logging::filter","logging::filters","logging::filters::level","logging::layout","logging::layouts","logging::layouts::basic","logging::layouts::parseable","logging::layouts::parseable::layout;","logging::layouts::pattern","logging::layouts::pattern::formatmethodbuilder","logging::logger","logging::logger","logging::mappeddiagnosticcontext","logging::nesteddiagnosticcontext","logging::plugins","logging::proxy","logging::railscompat","logging::repository","logging::repository::singleton","logging::rootlogger","logging::logger","module","object","rspec","rspec::core","rspec::core::configuration","rspec::logginghelper","rspec::logginghelper","reentrantmutex","spec","spec::runner","spec::runner::configuration","string","thread","logging::appender#<<()","logging::logger#<<()","logging::logger#<<()","logging::nesteddiagnosticcontext#<<()","logging::logger#<=>()","logging::logger#<=>()","logging::rootlogger#<=>()","logging::appenders#[]()","logging::colorscheme::[]()","logging::colorscheme#[]()","logging::logger::[]()","logging::logger::[]()","logging::mappeddiagnosticcontext#[]()","logging::repository#[]()","logging::appenders#[]=()","logging::colorscheme::[]=()","logging::colorscheme#[]=()","logging::mappeddiagnosticcontext#[]=()","logging::repository#[]=()","logging::appenders::buffering#_parse_hours_minutes_seconds()","logging::appenders::buffering#_parse_numeric()","logging::appenders::buffering#_setup_periodic_flusher()","logging::logger#add()","logging::logger#add()","logging::logger#add_appenders()","logging::logger#add_appenders()","logging::appender#add_filters()","logging::logger#additive=()","logging::logger#additive=()","logging::appenders::rollingfile#age_fn_mtime()","logging::appender#allow()","logging::filter#allow()","logging::filters::level#allow()","logging::appender#append()","logging::appenders()","logging::logger#appenders()","logging::logger#appenders()","logging::logger#appenders=()","logging::logger#appenders=()","logging::appenders::file::assert_valid_logfile()","logging::appenders::buffering#auto_flushing=()","logging::backtrace()","logging::layouts::basic()","logging::appenders::rollingfile#build_singleton_methods()","logging::logger#caller_tracing=()","logging::logger#caller_tracing=()","logging::appenders::io#canonical_write()","logging::appenders::rollingfile#canonical_write()","rspec::logginghelper#capture_log_messages()","rspec::logginghelper#capture_log_messages()","logging::repository#children()","logging::appenders::stringio#clear()","logging::mappeddiagnosticcontext#clear()","logging::nesteddiagnosticcontext#clear()","logging::appenders::buffering#clear!()","logging::logger#clear_appenders()","logging::logger#clear_appenders()","logging::mappeddiagnosticcontext#clear_context()","logging::clear_diagnostic_contexts()","logging::appender#close()","logging::appenders::buffering#close()","logging::appenders::io#close()","logging::appenders::syslog#close()","logging::appender#closed?()","logging::appenders::syslog#closed?()","logging::colorscheme#color()","logging::color_scheme()","fileutils::concat()","fileutils#concat()","logging::appenders::buffering#configure_buffering()","logging::mappeddiagnosticcontext#context()","logging::nesteddiagnosticcontext#context()","logging::appenders::rollingfile#copy_file()","logging::appenders::rollingfile::roller#copy_file()","logging::appenders::rollingfile#copy_truncate()","logging::layouts::parseable#create_format_method()","logging::layouts::pattern#date_method=()","logging::layouts::pattern#date_pattern=()","logging::logger#define_log_methods()","logging::logger#define_log_methods()","logging::logger::define_log_methods()","logging::logger::define_log_methods()","logging::mappeddiagnosticcontext#delete()","logging::repository#delete()","logging::appenders#each()","logging::appender#encoding()","logging::appender#encoding=()","logging::repository#fetch()","logging::appenders::file()","logging::appenders::file#filename()","logging::appenders::rollingfile#filename()","logging::appenders::rollingfile::roller#filename()","logging::appender#filters=()","logging::mappeddiagnosticcontext#flatten()","file#flock?()","file#flock_sh()","logging::appender#flush()","logging::appenders::buffering#flush()","logging::appenders::buffering#flush_period=()","logging::layout#footer()","logging::appenders::rollingfile::roller#format()","logging::layout#format()","logging::layouts::basic#format()","logging::format_as()","logging::layout#format_obj()","logging::layouts::parseable#format_obj()","logging::railscompat#formatter()","logging::appenders::rollingfile::roller#glob()","logging::globally()","logging::repository#has_logger?()","logging::layout#header()","logging::appenders::buffering#immediate?()","logging::appenders::buffering#immediate_at=()","logging::colorscheme#include?()","logging::mappeddiagnosticcontext#inherit()","logging::nesteddiagnosticcontext#inherit()","logging::init()","logging::appender#inspect()","logging::logger#inspect()","logging::logger#inspect()","logging::logger::instantiate()","logging::logger::instantiate()","logging::appenders::io()","logging::layouts::parseable#iso8601_format()","logging::layouts::parseable#items=()","logging::layouts::json()","logging::layouts::parseable::json()","logging::appender#layout=()","logging::layouts()","logging::logger#level()","logging::logger#level()","logging::appender#level=()","logging::logger#level=()","logging::logger#level=()","logging::rootlogger#level=()","logging::colorscheme#levels?()","logging::libpath()","logging::colorscheme#lines?()","logging::colorscheme#load_from_hash()","logging::logger#log_event()","logging::logger#log_event()","logging::logger()","module#logger_name()","logging::appenders::syslog#map=()","logging::mdc()","logging::proxy#method_missing()","logging::ndc()","logging::appender::new()","logging::appenders::buffering::new()","logging::appenders::file::new()","logging::appenders::io::new()","logging::appenders::rollingfile::new()","logging::appenders::rollingfile::roller::new()","logging::appenders::stderr::new()","logging::appenders::stdout::new()","logging::appenders::stringio::new()","logging::appenders::syslog::new()","logging::colorscheme::new()","logging::filters::level::new()","logging::layout::new()","logging::layouts::parseable::new()","logging::layouts::pattern::new()","logging::logger::new()","logging::logger::new()","logging::logger::new()","logging::proxy::new()","logging::repository::new()","logging::rootlogger::new()","reentrantmutex::new()","logging::appender#off?()","reentrantmutex#original_synchronize()","logging::repository#parent()","logging::logger#parent=()","logging::logger#parent=()","logging::repository#parent_name()","logging::layouts::parseable()","logging::path()","logging::layouts::pattern()","logging::layouts::pattern#pattern=()","logging::mappeddiagnosticcontext#peek()","logging::nesteddiagnosticcontext#peek()","logging::mappeddiagnosticcontext#pop()","logging::nesteddiagnosticcontext#pop()","logging::mappeddiagnosticcontext#push()","logging::nesteddiagnosticcontext#push()","logging::appenders#remove()","logging::logger#remove_appenders()","logging::logger#remove_appenders()","logging::reopen()","logging::appender#reopen()","logging::appenders::buffering#reopen()","logging::appenders::file#reopen()","logging::appenders::rollingfile#reopen()","logging::appenders::stringio#reopen()","logging::appenders::syslog#reopen()","logging::appenders::stringio#reset()","logging::colorscheme::reset()","logging::appenders::rollingfile::roller#roll_by_date()","logging::appenders::rollingfile::roller#roll_by_number()","logging::appenders::rollingfile::roller#roll_files()","logging::appenders::rollingfile#roll_required?()","logging::appenders::rolling_file()","logging::logger::root()","logging::logger::root()","logging::mappeddiagnosticcontext#sanitize()","logging::show_configuration()","string#shrink()","logging::railscompat#silence()","logging::mappeddiagnosticcontext#stack()","logging::appenders::stderr()","logging::appenders::stdout()","logging::appenders::string_io()","logging::appender#sync()","reentrantmutex#synchronize()","logging::appenders::syslog()","logging::appenders::syslog#syslog_level_num()","logging::colorscheme#to_constant()","logging::colorscheme#to_key()","logging::repository#to_key()","logging::layout#try_json()","logging::layout#try_yaml()","logging::mappeddiagnosticcontext#update()","logging::version()","logging::appender#write()","logging::appenders::buffering#write()","logging::appenders::syslog#write()","logging::logger#write()","logging::logger#write()","logging::layouts::yaml()","logging::layouts::parseable::yaml()",""],"info":[["File","","File.html","",""],["FileUtils","","FileUtils.html","",""],["Logging","","Logging.html","","<p>color_scheme.rb\n<p>Created by Jeremy Hinegardner on 2007-01-24 Copyright 2007.  All rights\nreserved\n<p>This file …\n"],["Logging::Appender","","Logging/Appender.html","","<p>The <code>Appender</code> class is provides methods for appending log\nevents to a logging destination. The log events …\n"],["Logging::Appenders","","Logging/Appenders.html","",""],["Logging::Appenders::Buffering","","Logging/Appenders/Buffering.html","","<p>The Buffering module is used to implement buffering of the log messages in\na given appender. The size …\n"],["Logging::Appenders::Buffering::PeriodicFlusher","","Logging/Appenders/Buffering/PeriodicFlusher.html","",""],["Logging::Appenders::File","","Logging/Appenders/File.html","","<p>This class provides an Appender that can write to a File.\n"],["Logging::Appenders::IO","","Logging/Appenders/IO.html","","<p>This class provides an Appender that can write to any IO stream configured\nfor writing.\n"],["Logging::Appenders::RollingFile","","Logging/Appenders/RollingFile.html","","<p>An appender that writes to a file and ensures that the file size or age\nnever exceeds some user specified …\n"],["Logging::Appenders::RollingFile::Roller","","Logging/Appenders/RollingFile/Roller.html","","<p>Not intended for general consumption, but the Roller class is used\ninternally by the RollingFile appender …\n"],["Logging::Appenders::Stderr","","Logging/Appenders/Stderr.html","","<p>This class provides an Appender that can write to STDERR.\n"],["Logging::Appenders::Stdout","","Logging/Appenders/Stdout.html","","<p>This class provides an Appender that can write to STDOUT.\n"],["Logging::Appenders::StringIo","","Logging/Appenders/StringIo.html","","<p>This class provides an Appender that can write to a StringIO instance. This\nis very useful for testing …\n"],["Logging::Appenders::StringIo::IoToS","","Logging/Appenders/StringIo/IoToS.html","",""],["Logging::Appenders::Syslog","","Logging/Appenders/Syslog.html","","<p>This class provides an Appender that can write to the UNIX syslog daemon.\n"],["Logging::ColorScheme","","Logging/ColorScheme.html","","<p>ColorScheme objects encapsulate a named set of colors to be used in the\ncolors() method call. For example, …\n"],["Logging::Filter","","Logging/Filter.html","","<p>The `Filter` class allows for filtering messages based on event properties\nindependently of the standard …\n"],["Logging::Filters","","Logging/Filters.html","",""],["Logging::Filters::Level","","Logging/Filters/Level.html","","<p>The `Level` filter class provides a simple level-based filtering mechanism\nthat filters messages to only …\n"],["Logging::Layout","","Logging/Layout.html","","<p>The <code>Layout</code> class provides methods for formatting log events\ninto a string representation. Layouts are …\n"],["Logging::Layouts","","Logging/Layouts.html","",""],["Logging::Layouts::Basic","","Logging/Layouts/Basic.html","","<p>The <code>Basic</code> layout class provides methods for simple formatting\nof log events. The resulting string follows …\n"],["Logging::Layouts::Parseable","","Logging/Layouts/Parseable.html","","<p>This layout will produce parseable log output in either JSON or YAML\nformat. This makes it much easier …\n"],["Logging::Layouts::Parseable::layout;","","Logging/Layouts/Parseable/layout;.html","",""],["Logging::Layouts::Pattern","","Logging/Layouts/Pattern.html","","<p>A flexible layout configurable via a conversion pattern string.\n<p>The goal of this class is to format a …\n"],["Logging::Layouts::Pattern::FormatMethodBuilder","","Logging/Layouts/Pattern/FormatMethodBuilder.html","",""],["Logging::Logger","","Logging/Logger.html","","<p>The <code>Logger</code> class is the primary interface to the\n<code>Logging</code> framework. It provides the logging methods that …\n"],["Logging::Logger","","Logging/Logger.html","","<p>The <code>Logger</code> class is the primary interface to the\n<code>Logging</code> framework. It provides the logging methods that …\n"],["Logging::MappedDiagnosticContext","","Logging/MappedDiagnosticContext.html","","<p>A Mapped Diagnostic Context, or MDC in short, is an instrument used to\ndistinguish interleaved log output …\n"],["Logging::NestedDiagnosticContext","","Logging/NestedDiagnosticContext.html","","<p>A Nested Diagnostic Context, or NDC in short, is an instrument to\ndistinguish interleaved log output …\n"],["Logging::Plugins","","Logging/Plugins.html","",""],["Logging::Proxy","","Logging/Proxy.html","","<p>Defines a Proxy that will log all method calls on the proxied object. This\nclass uses <code>method_missing</code> …\n"],["Logging::RailsCompat","","Logging/RailsCompat.html","","<p>Rails compatibility module.\n<p>The ActiveSupport gem adds a few methods to the default Ruby logger, and\nsome …\n"],["Logging::Repository","","Logging/Repository.html","","<p>The Repository is a hash that stores references to all Loggers that have\nbeen created. It provides methods …\n"],["Logging::Repository::Singleton","","Logging/Repository/Singleton.html","",""],["Logging::RootLogger","","Logging/RootLogger.html","","<p>The root logger exists to ensure that all loggers have a parent and a\ndefined logging level. If a logger …\n"],["Logging::logger","","Logging/logger.html","",""],["Module","","Module.html","",""],["Object","","Object.html","",""],["RSpec","","RSpec.html","",""],["RSpec::Core","","RSpec/Core.html","",""],["RSpec::Core::Configuration","","RSpec/Core/Configuration.html","",""],["RSpec::LoggingHelper","","RSpec/LoggingHelper.html","",""],["RSpec::LoggingHelper","","RSpec/LoggingHelper.html","",""],["ReentrantMutex","","ReentrantMutex.html","",""],["Spec","","Spec.html","",""],["Spec::Runner","","Spec/Runner.html","",""],["Spec::Runner::Configuration","","Spec/Runner/Configuration.html","",""],["String","","String.html","",""],["Thread","","Thread.html","",""],["<<","Logging::Appender","Logging/Appender.html#method-i-3C-3C","( str )","<p>Write the given <em>string</em> to the logging destination “as is” – no\nlayout formatting will be performed. …\n"],["<<","Logging::Logger","Logging/Logger.html#method-i-3C-3C","( msg )","<p>Log the given message without any formatting and without performing any\nlevel checks. The message is …\n"],["<<","Logging::Logger","Logging/Logger.html#method-i-3C-3C",null,""],["<<","Logging::NestedDiagnosticContext","Logging/NestedDiagnosticContext.html#method-i-3C-3C","( message )",""],["<=>","Logging::Logger","Logging/Logger.html#method-i-3C-3D-3E","( other )","<p>Compares this logger by name to another logger. The normal return codes for\n<code>String</code> objects apply.\n"],["<=>","Logging::Logger","Logging/Logger.html#method-i-3C-3D-3E",null,""],["<=>","Logging::RootLogger","Logging/RootLogger.html#method-i-3C-3D-3E","( other )","<p>Compares this logger by name to another logger. The normal return codes for\n<code>String</code> objects apply.\n"],["[]","Logging::Appenders","Logging/Appenders.html#method-i-5B-5D","( name )","<p>Returns the appender instance stored in the appender hash under the key\n<em>name</em>, or <code>nil</code> if no appender has …\n"],["[]","Logging::ColorScheme","Logging/ColorScheme.html#method-c-5B-5D","( name )","<p>Retrieve a color scheme by name.\n"],["[]","Logging::ColorScheme","Logging/ColorScheme.html#method-i-5B-5D","( color_tag )","<p>Allow the scheme to be accessed like a Hash.\n"],["[]","Logging::Logger","Logging/Logger.html#method-c-5B-5D","( name )","<p>Returns a logger instance for the given name.\n"],["[]","Logging::Logger","Logging/Logger.html#method-c-5B-5D",null,""],["[]","Logging::MappedDiagnosticContext","Logging/MappedDiagnosticContext.html#method-i-5B-5D","( key )","<p>Public: Get the context value identified with the key parameter.\n<p>key - The String identifier for the context. …\n"],["[]","Logging::Repository","Logging/Repository.html#method-i-5B-5D","( key )","<p>Returns the <code>Logger</code> named <em>name</em>.\n<p>When <em>name</em> is a <code>String</code> or a <code>Symbol</code> it\nwill be used “as is” to …\n"],["[]=","Logging::Appenders","Logging/Appenders.html#method-i-5B-5D-3D","( name, value )","<p>Stores the given <em>appender</em> instance in the appender hash under the\nkey <em>name</em>.\n"],["[]=","Logging::ColorScheme","Logging/ColorScheme.html#method-c-5B-5D-3D","( name, value )","<p>Store a color scheme by name.\n"],["[]=","Logging::ColorScheme","Logging/ColorScheme.html#method-i-5B-5D-3D","( color_tag, constants )","<p>Allow the scheme to be set like a Hash.\n"],["[]=","Logging::MappedDiagnosticContext","Logging/MappedDiagnosticContext.html#method-i-5B-5D-3D","( key, value )","<p>Public: Put a context value as identified with the key parameter into the\ncurrent thread&#39;s context …\n"],["[]=","Logging::Repository","Logging/Repository.html#method-i-5B-5D-3D","( key, val )","<p>Stores the <em>logger</em> under the given <em>name</em>.\n<p>When <em>name</em> is a <code>String</code> or a <code>Symbol</code> it\nwill be used “as is” …\n"],["_parse_hours_minutes_seconds","Logging::Appenders::Buffering","Logging/Appenders/Buffering.html#method-i-_parse_hours_minutes_seconds","( str )","<p>Attempt to parse an hours/minutes/seconds value from the string and return\nan integer number of seconds. …\n"],["_parse_numeric","Logging::Appenders::Buffering","Logging/Appenders/Buffering.html#method-i-_parse_numeric","( str )","<p>Convert the string into a numeric value. If the string does not represent a\nvalid Integer or Float then …\n"],["_setup_periodic_flusher","Logging::Appenders::Buffering","Logging/Appenders/Buffering.html#method-i-_setup_periodic_flusher","()","<p>Using the flush_period, create a new PeriodicFlusher attached to this\nappender. If the flush_period is …\n"],["add","Logging::Logger","Logging/Logger.html#method-i-add","( lvl, data = nil, progname = nil )","<p>Log a message if the given severity is high enough.  This is the generic\nlogging method.  Users will …\n"],["add","Logging::Logger","Logging/Logger.html#method-i-add",null,""],["add_appenders","Logging::Logger","Logging/Logger.html#method-i-add_appenders",null,""],["add_appenders","Logging::Logger","Logging/Logger.html#method-i-add_appenders","( *args )","<p>Add the given <em>appenders</em> to the list of appenders, where\n<em>appenders</em> can be either a single appender or …\n"],["add_filters","Logging::Appender","Logging/Appender.html#method-i-add_filters","( *args )","<p>Sets the filter(s) to be used by this appender. The filters will be applied\nin the order that they are …\n"],["additive=","Logging::Logger","Logging/Logger.html#method-i-additive-3D",null,""],["additive=","Logging::Logger","Logging/Logger.html#method-i-additive-3D","( val )","<p>Sets the additivity of the logger. Acceptable values are <code>true</code>,\n&#39;true&#39;, <code>false</code>, &#39;false&#39;, …\n"],["age_fn_mtime","Logging::Appenders::RollingFile","Logging/Appenders/RollingFile.html#method-i-age_fn_mtime","()","<p>Returns the modification time of the age file.\n"],["allow","Logging::Appender","Logging/Appender.html#method-i-allow","( event )","<p>Check to see if the event should be processed by the appender. An event\nwill be rejected if the event …\n"],["allow","Logging::Filter","Logging/Filter.html#method-i-allow","( event )","<p>Returns the event if it should be allowed into the log. Returns `nil` if\nthe event should <em>not</em> be allowed …\n"],["allow","Logging::Filters::Level","Logging/Filters/Level.html#method-i-allow","( event )",""],["append","Logging::Appender","Logging/Appender.html#method-i-append","( event )","<p>Write the given <em>event</em> to the logging destination. The log event\nwill be processed through the Layout …\n"],["appenders","Logging","Logging.html#method-c-appenders","()","<p>Access to the appenders.\n"],["appenders","Logging::Logger","Logging/Logger.html#method-i-appenders",null,""],["appenders","Logging::Logger","Logging/Logger.html#method-i-appenders","()","<p>Returns the list of appenders.\n"],["appenders=","Logging::Logger","Logging/Logger.html#method-i-appenders-3D",null,""],["appenders=","Logging::Logger","Logging/Logger.html#method-i-appenders-3D","( args )","<p>Clears the current list of appenders and replaces them with <em>app</em>,\nwhere <em>app</em> can be either a single appender …\n"],["assert_valid_logfile","Logging::Appenders::File","Logging/Appenders/File.html#method-c-assert_valid_logfile","( fn )","<p>Asserts that the given <em>filename</em> can be used as a log file by\nensuring that if the file exists it is a …\n"],["auto_flushing=","Logging::Appenders::Buffering","Logging/Appenders/Buffering.html#method-i-auto_flushing-3D","( period )","<p>Configure the auto-flushing threshold. Auto-flushing is used to flush the\ncontents of the logging buffer …\n"],["backtrace","Logging","Logging.html#method-c-backtrace","( b = nil )","<p>Without any arguments, returns the global exception backtrace logging\nvalue. When set to <code>true</code> backtraces …\n"],["basic","Logging::Layouts","Logging/Layouts.html#method-c-basic","( *args )","<p>Accessor / Factory for the Basic layout.\n"],["build_singleton_methods","Logging::Appenders::RollingFile","Logging/Appenders/RollingFile.html#method-i-build_singleton_methods","()","<p>We use meta-programming here to define the `sufficiently_aged?` method for\nthe rolling appender. The …\n"],["caller_tracing=","Logging::Logger","Logging/Logger.html#method-i-caller_tracing-3D","( val )","<p>Sets the caller tracing of the logger. Acceptable values are\n<code>true</code>, &#39;true&#39;, <code>false</code>, &#39;false&#39;, …\n"],["caller_tracing=","Logging::Logger","Logging/Logger.html#method-i-caller_tracing-3D",null,""],["canonical_write","Logging::Appenders::IO","Logging/Appenders/IO.html#method-i-canonical_write","( str )","<p>This method is called by the buffering code when messages need to be\nwritten to the logging destination. …\n"],["canonical_write","Logging::Appenders::RollingFile","Logging/Appenders/RollingFile.html#method-i-canonical_write","( str )","<p>Write the given <em>event</em> to the log file. The log file will be rolled\nif the maximum file size is exceeded …\n"],["capture_log_messages","RSpec::LoggingHelper","RSpec/LoggingHelper.html#method-i-capture_log_messages","( opts = {} )","<p>Capture log messages from the Logging framework and make them available via\na @log_output instance variable. …\n"],["capture_log_messages","RSpec::LoggingHelper","RSpec/LoggingHelper.html#method-i-capture_log_messages","( opts = {} )","<p>Capture log messages from the Logging framework and make them available via\na @log_output instance variable. …\n"],["children","Logging::Repository","Logging/Repository.html#method-i-children","( parent )","<p>Returns an array of the children loggers for the logger identified by\n<em>key</em> where <em>key</em> follows the same …\n"],["clear","Logging::Appenders::StringIo","Logging/Appenders/StringIo.html#method-i-clear","()","<p>Clears the internal StringIO instance. All log messages are removed from\nthe buffer.\n"],["clear","Logging::MappedDiagnosticContext","Logging/MappedDiagnosticContext.html#method-i-clear","()","<p>Public: Clear all mapped diagnostic information if any. This method is\nuseful in cases where the same …\n"],["clear","Logging::NestedDiagnosticContext","Logging/NestedDiagnosticContext.html#method-i-clear","()","<p>Public: Clear all nested diagnostic information if any. This method is\nuseful in cases where the same …\n"],["clear!","Logging::Appenders::Buffering","Logging/Appenders/Buffering.html#method-i-clear-21","()","<p>Clear the underlying buffer of all log events. These events will not be\nappended to the logging destination; …\n"],["clear_appenders","Logging::Logger","Logging/Logger.html#method-i-clear_appenders","( )","<p>Remove all appenders from this logger.\n"],["clear_appenders","Logging::Logger","Logging/Logger.html#method-i-clear_appenders",null,""],["clear_context","Logging::MappedDiagnosticContext","Logging/MappedDiagnosticContext.html#method-i-clear_context","()","<p>Remove the flattened context.\n"],["clear_diagnostic_contexts","Logging","Logging.html#method-c-clear_diagnostic_contexts","( all = false )","<p>Public: Convenience method that will clear both the Mapped Diagnostic\nContext and the Nested Diagnostic …\n"],["close","Logging::Appender","Logging/Appender.html#method-i-close","( footer = true )","<p>Close the appender and writes the layout footer to the logging destination\nif the <em>footer</em> flag is set …\n"],["close","Logging::Appenders::Buffering","Logging/Appenders/Buffering.html#method-i-close","( *args )","<p>Close the message buffer by flushing all log events to the appender. If a\nperiodic flusher thread is …\n"],["close","Logging::Appenders::IO","Logging/Appenders/IO.html#method-i-close","( *args )","<p>Close the appender and writes the layout footer to the logging destination\nif the <em>footer</em> flag is set …\n"],["close","Logging::Appenders::Syslog","Logging/Appenders/Syslog.html#method-i-close","( footer = true )","<p>Closes the connection to the syslog facility.\n"],["closed?","Logging::Appender","Logging/Appender.html#method-i-closed-3F","()","<p>Returns <code>true</code> if the appender has been closed; returns\n<code>false</code> otherwise. When an appender is closed, no …\n"],["closed?","Logging::Appenders::Syslog","Logging/Appenders/Syslog.html#method-i-closed-3F","()","<p>Queries the connection to the syslog facility and returns <code>true</code>\nif the connection is closed.\n"],["color","Logging::ColorScheme","Logging/ColorScheme.html#method-i-color","( string, *colors )","<p>This method provides easy access to ANSI color sequences, without the user\nneeding to remember to CLEAR …\n"],["color_scheme","Logging","Logging.html#method-c-color_scheme","( name, opts = {} )","<p>Returns the color scheme identified by the given <em>name</em>. If there is\nno color scheme <code>nil</code> is returned.\n<p>If …\n"],["concat","FileUtils","FileUtils.html#method-c-concat","( src, dest )","<p>Concatenate the contents of the <em>src</em> file to the end of the\n<em>dest</em> file. If the <em>dest</em> file does not exist, …\n"],["concat","FileUtils","FileUtils.html#method-i-concat","( src, dest )","<p>Concatenate the contents of the <em>src</em> file to the end of the\n<em>dest</em> file. If the <em>dest</em> file does not exist, …\n"],["configure_buffering","Logging::Appenders::Buffering","Logging/Appenders/Buffering.html#method-i-configure_buffering","( opts )","<p>Configure the buffering using the arguments found in the give options hash.\nThis method must be called …\n"],["context","Logging::MappedDiagnosticContext","Logging/MappedDiagnosticContext.html#method-i-context","()","<p>Returns the Hash acting as the storage for this MappedDiagnosticContext. A\nnew storage Hash is created …\n"],["context","Logging::NestedDiagnosticContext","Logging/NestedDiagnosticContext.html#method-i-context","()","<p>Returns the Array acting as the storage stack for this\nNestedDiagnosticContext. A new storage Array is …\n"],["copy_file","Logging::Appenders::RollingFile","Logging/Appenders/RollingFile.html#method-i-copy_file","()","<p>Returns the file name to use as the temporary copy location. We are using\ncopy-and-truncate semantics …\n"],["copy_file","Logging::Appenders::RollingFile::Roller","Logging/Appenders/RollingFile/Roller.html#method-i-copy_file","()","<p>Returns the file name to use as the temporary copy location. We are using\ncopy-and-truncate semantics …\n"],["copy_truncate","Logging::Appenders::RollingFile","Logging/Appenders/RollingFile.html#method-i-copy_truncate","()","<p>Copy the contents of the logfile to another file. Truncate the logfile to\nzero length. This method will …\n"],["create_format_method","Logging::Layouts::Parseable","Logging/Layouts/Parseable.html#method-i-create_format_method","()","<p>Call the appropriate class level create format method based on the style of\nthis parseable layout.\n"],["date_method=","Logging::Layouts::Pattern","Logging/Layouts/Pattern.html#method-i-date_method-3D","( var )","<p>Set the date method to be used when outputting timestamps in the log\nmessages. If a date method is configured, …\n"],["date_pattern=","Logging::Layouts::Pattern","Logging/Layouts/Pattern.html#method-i-date_pattern-3D","( var )","<p>Set the date formatting pattern to be used when outputting timestamps in\nthe log messages.\n"],["define_log_methods","Logging::Logger","Logging/Logger.html#method-i-define_log_methods",null,""],["define_log_methods","Logging::Logger","Logging/Logger.html#method-i-define_log_methods","( force = false )","<p>Define the logging methods for this logger based on the configured log\nlevel. If the level is nil, then …\n"],["define_log_methods","Logging::Logger","Logging/Logger.html#method-c-define_log_methods","( logger )","<p>This is where the actual logging methods are defined. Two methods are\ncreated for each log level. The …\n"],["define_log_methods","Logging::Logger","Logging/Logger.html#method-c-define_log_methods",null,""],["delete","Logging::MappedDiagnosticContext","Logging/MappedDiagnosticContext.html#method-i-delete","( key )","<p>Public: Remove the context value identified with the key parameter.\n<p>key - The String identifier for the …\n"],["delete","Logging::Repository","Logging/Repository.html#method-i-delete","( key )","<p>Deletes the named logger from the repository. All direct children of the\nlogger will have their parent …\n"],["each","Logging::Appenders","Logging/Appenders.html#method-i-each","( &block )","<p>Yield each appender to the <em>block</em>.\n"],["encoding","Logging::Appender","Logging/Appender.html#method-i-encoding","()","<p>Returns the current Encoding for the appender or nil if an encoding has not\nbeen set.\n"],["encoding=","Logging::Appender","Logging/Appender.html#method-i-encoding-3D","( value )","<p>Set the appender encoding to the given value. The value can either be an\nEncoding instance or a String …\n"],["fetch","Logging::Repository","Logging/Repository.html#method-i-fetch","( key )","<p>Returns the <code>Logger</code> named <em>name</em>. An\n<code>KeyError</code> will be raised if the logger does not exist.\n<p>When <em>name</em> is a …\n"],["file","Logging::Appenders","Logging/Appenders.html#method-c-file","( *args )","<p>Accessor / Factory for the File appender.\n"],["filename","Logging::Appenders::File","Logging/Appenders/File.html#method-i-filename","()","<p>Returns the path to the logfile.\n"],["filename","Logging::Appenders::RollingFile","Logging/Appenders/RollingFile.html#method-i-filename","()","<p>Returns the path to the logfile.\n"],["filename","Logging::Appenders::RollingFile::Roller","Logging/Appenders/RollingFile/Roller.html#method-i-filename","()","<p>Returns the regular log file name without any roller text.\n"],["filters=","Logging::Appender","Logging/Appender.html#method-i-filters-3D","( args )","<p>Sets the filter(s) to be used by this appender. This method will clear the\ncurrent filter set and add …\n"],["flatten","Logging::MappedDiagnosticContext","Logging/MappedDiagnosticContext.html#method-i-flatten","( ary )","<p>Given an Array of Hash objects, flatten all the key/value pairs from the\nHash objects in the ary into …\n"],["flock?","File","File.html#method-i-flock-3F","()","<p>Returns <code>true</code> if another process holds an exclusive lock on the\nfile. Returns <code>false</code> if this is not the …\n"],["flock_sh","File","File.html#method-i-flock_sh","()","<p>Execute a <code>block</code> in the context of a shared lock on this file.\nA shared lock will be obtained on the file, …\n"],["flush","Logging::Appender","Logging/Appender.html#method-i-flush","()","<p>Call <code>flush</code> to force an appender to write out any buffered log\nevents. Similar to IO#flush, so use in …\n"],["flush","Logging::Appenders::Buffering","Logging/Appenders/Buffering.html#method-i-flush","()","<p>Call `flush` to force an appender to write out any buffered log events.\nSimilar to `IO#flush`, so use …\n"],["flush_period=","Logging::Appenders::Buffering","Logging/Appenders/Buffering.html#method-i-flush_period-3D","( period )","<p>Configure periodic flushing of the message buffer. Periodic flushing is\nused to flush the contents of …\n"],["footer","Logging::Layout","Logging/Layout.html#method-i-footer","( )","<p>Returns a footer string to be used at the end of a logging appender.\n"],["format","Logging::Appenders::RollingFile::Roller","Logging/Appenders/RollingFile/Roller.html#method-i-format","()","<p>Returns the format String used to generate rolled file names. Depending\nupon the `roll_by` type (:date …\n"],["format","Logging::Layout","Logging/Layout.html#method-i-format","( event )","<p>Returns a string representation of the given logging <em>event</em>. It is\nup to subclasses to implement this …\n"],["format","Logging::Layouts::Basic","Logging/Layouts/Basic.html#method-i-format","( event )","<p>Returns a string representation of the given logging <em>event</em>. See\nthe class documentation for details about …\n"],["format_as","Logging","Logging.html#method-c-format_as","( f )","<p>Defines the default <em>obj_format</em> method to use when converting\nobjects into string representations for …\n"],["format_obj","Logging::Layout","Logging/Layout.html#method-i-format_obj","( obj )","<p>Return a string representation of the given object. Depending upon the\nconfiguration of the logger system …\n"],["format_obj","Logging::Layouts::Parseable","Logging/Layouts/Parseable.html#method-i-format_obj","( obj )","<p>Public: Take a given object and convert it into a format suitable for\ninclusion as a log message. The …\n"],["formatter","Logging::RailsCompat","Logging/RailsCompat.html#method-i-formatter","()","<p>A no-op implementation of the <code>formatter</code> method.\n"],["glob","Logging::Appenders::RollingFile::Roller","Logging/Appenders/RollingFile/Roller.html#method-i-glob","()","<p>Returns the glob pattern used to find rolled log files. We use this list\nfor pruning older log files …\n"],["globally","Logging","Logging.html#method-c-globally","( name = :logger )","<p>Add a “logger” method to the including context. If included from Object or\nKernel, the logger …\n"],["has_logger?","Logging::Repository","Logging/Repository.html#method-i-has_logger-3F","( key )","<p>Returns <code>true</code> if the given logger exists in the repository.\nReturns <code>false</code> if this is not the case.\n<p>When …\n"],["header","Logging::Layout","Logging/Layout.html#method-i-header","( )","<p>Returns a header string to be used at the beginning of a logging appender.\n"],["immediate?","Logging::Appenders::Buffering","Logging/Appenders/Buffering.html#method-i-immediate-3F","( event )","<p>Returns true if the <em>event</em> level matches one of the configured\nimmediate logging levels. Otherwise returns …\n"],["immediate_at=","Logging::Appenders::Buffering","Logging/Appenders/Buffering.html#method-i-immediate_at-3D","( level )","<p>Configure the levels that will trigger an immediate flush of the logging\nbuffer. When a log event of …\n"],["include?","Logging::ColorScheme","Logging/ColorScheme.html#method-i-include-3F","( color_tag )","<p>Does this color scheme include the given tag name?\n"],["inherit","Logging::MappedDiagnosticContext","Logging/MappedDiagnosticContext.html#method-i-inherit","( obj )","<p>Public: Inherit the diagnostic context of another thread. In the vast\nmajority of cases the other thread …\n"],["inherit","Logging::NestedDiagnosticContext","Logging/NestedDiagnosticContext.html#method-i-inherit","( obj )","<p>Public: Inherit the diagnostic context of another thread. In the vast\nmajority of cases the other thread …\n"],["init","Logging","Logging.html#method-c-init","( *args )","<p>Defines the levels available to the loggers. The <em>levels</em> is an\narray of strings and symbols. Each element …\n"],["inspect","Logging::Appender","Logging/Appender.html#method-i-inspect","()","<p>Returns a string representation of the appender.\n"],["inspect","Logging::Logger","Logging/Logger.html#method-i-inspect","()","<p>Returns a string representation of the logger.\n"],["inspect","Logging::Logger","Logging/Logger.html#method-i-inspect",null,""],["instantiate","Logging::Logger","Logging/Logger.html#method-c-instantiate","( *args )",""],["instantiate","Logging::Logger","Logging/Logger.html#method-c-instantiate",null,""],["io","Logging::Appenders","Logging/Appenders.html#method-c-io","( *args )","<p>Accessor / Factory for the IO appender.\n"],["iso8601_format","Logging::Layouts::Parseable","Logging/Layouts/Parseable.html#method-i-iso8601_format","( value )","<p>Convert the given time <em>value</em> into an ISO8601 formatted time\nstring.\n"],["items=","Logging::Layouts::Parseable","Logging/Layouts/Parseable.html#method-i-items-3D","( ary )","<p>Set the log event items that will be formatted by this layout. These items,\nand only these items, will …\n"],["json","Logging::Layouts","Logging/Layouts.html#method-c-json","( *args )","<p>Factory for the Parseable layout using JSON formatting.\n"],["json","Logging::Layouts::Parseable","Logging/Layouts/Parseable.html#method-c-json","( opts = {} )","<p>Create a new Parseable layout that outputs log events using JSON style\nformatting. See the initializer …\n"],["layout=","Logging::Appender","Logging/Appender.html#method-i-layout-3D","( layout )","<p>call-seq\n\n<pre>appender.layout = Logging::Layouts::Basic.new</pre>\n<p>Sets the layout to be used by this appender.\n"],["layouts","Logging","Logging.html#method-c-layouts","()","<p>Access to the layouts.\n"],["level","Logging::Logger","Logging/Logger.html#method-i-level",null,""],["level","Logging::Logger","Logging/Logger.html#method-i-level","()","<p>Returns an integer which is the defined log level for this logger.\n"],["level=","Logging::Appender","Logging/Appender.html#method-i-level-3D","( level )","<p>Set the level for this appender; log events below this level will be\nignored by this appender. The level …\n"],["level=","Logging::Logger","Logging/Logger.html#method-i-level-3D","( level )","<p>Set the level for this logger. The level can be either a\n<code>String</code>, a <code>Symbol</code>, or a <code>Fixnum</code>. An\n<code>ArgumentError</code> …\n"],["level=","Logging::Logger","Logging/Logger.html#method-i-level-3D",null,""],["level=","Logging::RootLogger","Logging/RootLogger.html#method-i-level-3D","( level )","<p>Set the level for the root logger. The functionality of this method is the\nsame as +Logger#level=+, but …\n"],["levels?","Logging::ColorScheme","Logging/ColorScheme.html#method-i-levels-3F","()","<p>Returns <code>true</code> if the :levels option was passed to the\nconstructor.\n"],["libpath","Logging","Logging.html#method-c-libpath","( *args, &block )","<p>Returns the library path for the module. If any arguments are given, they\nwill be joined to the end of …\n"],["lines?","Logging::ColorScheme","Logging/ColorScheme.html#method-i-lines-3F","()","<p>Returns <code>true</code> if the :lines option was passed to the\nconstructor.\n"],["load_from_hash","Logging::ColorScheme","Logging/ColorScheme.html#method-i-load_from_hash","( h )","<p>Load multiple colors from key/value pairs.\n"],["log_event","Logging::Logger","Logging/Logger.html#method-i-log_event",null,""],["log_event","Logging::Logger","Logging/Logger.html#method-i-log_event","( event )","<p>Send the given <em>event</em> to the appenders for logging, and pass the\n<em>event</em> up to the parent if additive mode …\n"],["logger","Logging","Logging.html#method-c-logger","( *args )","<p>This convenience method returns a Logger instance configured to behave\nsimilarly to a core Ruby Logger …\n"],["logger_name","Module","Module.html#method-i-logger_name","()","<p>Returns a predictable logger name for the current module or class. If used\nwithin an anonymous class, …\n"],["map=","Logging::Appenders::Syslog","Logging/Appenders/Syslog.html#method-i-map-3D","( levels )","<p>Configure the mapping from the Logging levels to the syslog levels. This is\nneeded in order to log events …\n"],["mdc","Logging","Logging.html#method-c-mdc","()","<p>Public: Accessor method for getting the current Thread&#39;s\nMappedDiagnosticContext.\n<p>Returns MappedDiagnosticContext …\n"],["method_missing","Logging::Proxy","Logging/Proxy.html#method-i-method_missing","( name, *args, &block )","<p>All hail the magic of method missing. Here is where we are going to log the\nmethod call and then forward …\n"],["ndc","Logging","Logging.html#method-c-ndc","()","<p>Public: Accessor method for getting the current Thread&#39;s\nNestedDiagnosticContext.\n<p>Returns NestedDiagnosticContext …\n"],["new","Logging::Appender","Logging/Appender.html#method-c-new","( name, opts = {} )","<p>Creates a new appender using the given name. If no Layout is specified,\nthen a Basic layout will be used. …\n"],["new","Logging::Appenders::Buffering","Logging/Appenders/Buffering.html#method-c-new","( *args, &block )","<p>Setup the message buffer and other variables for automatically and\nperiodically flushing the buffer. …\n"],["new","Logging::Appenders::File","Logging/Appenders/File.html#method-c-new","( name, opts = {} )","<p>Creates a new File Appender that will use the given filename as the logging\ndestination. If the file …\n"],["new","Logging::Appenders::IO","Logging/Appenders/IO.html#method-c-new","( name, io, opts = {} )","<p>Creates a new IO Appender using the given name that will use the\n<em>io</em> stream as the logging destination. …\n"],["new","Logging::Appenders::RollingFile","Logging/Appenders/RollingFile.html#method-c-new","( name, opts = {} )","<p>Creates a new Rolling File Appender. The <em>name</em> is the unique\nAppender name used to retrieve this appender …\n"],["new","Logging::Appenders::RollingFile::Roller","Logging/Appenders/RollingFile/Roller.html#method-c-new","( name, opts )","<p>Create a new roller. See the RollingFile#initialize documentation for the\nlist of options.\n<p>name - The …\n"],["new","Logging::Appenders::Stderr","Logging/Appenders/Stderr.html#method-c-new","( *args )","<p>Creates a new Stderr Appender. The name &#39;stderr&#39; will be used\nunless another is given. Optionally …\n"],["new","Logging::Appenders::Stdout","Logging/Appenders/Stdout.html#method-c-new","( *args )","<p>Creates a new Stdout Appender. The name &#39;stdout&#39; will be used\nunless another is given. Optionally …\n"],["new","Logging::Appenders::StringIo","Logging/Appenders/StringIo.html#method-c-new","( name, opts = {} )","<p>Creates a new StringIo appender that will append log messages to a StringIO\ninstance.\n"],["new","Logging::Appenders::Syslog","Logging/Appenders/Syslog.html#method-c-new","( name, opts = {} )","<p>Create an appender that will log messages to the system message logger. The\nmessage is then written to …\n"],["new","Logging::ColorScheme","Logging/ColorScheme.html#method-c-new","( name, opts = {} )","<p>Create a ColorScheme instance that can be accessed using the given\n<em>name</em>. If a color scheme already exists …\n"],["new","Logging::Filters::Level","Logging/Filters/Level.html#method-c-new","( *levels )","<p>Creates a new level filter that will only allow the given <em>levels</em>\nto propagate through to the logging …\n"],["new","Logging::Layout","Logging/Layout.html#method-c-new","( opts = {} )","<p>Creates a new layout that will format objects as strings using the given\n<code>:format_as</code> style. This can be …\n"],["new","Logging::Layouts::Parseable","Logging/Layouts/Parseable.html#method-c-new","( opts = {} )","<p>Creates a new Parseable layout using the following options:\n\n<pre class=\"ruby\">:<span class=\"ruby-identifier\">style</span>  =<span class=\"ruby-operator\">&gt;</span> :<span class=\"ruby-identifier\">json</span> <span class=\"ruby-keyword\">or</span> :<span class=\"ruby-identifier\">yaml</span>\n:<span class=\"ruby-identifier\">items</span>  =<span class=\"ruby-operator\">&gt;</span> <span class=\"ruby-node\">%w[timestamp ...\n</span></pre>\n"],["new","Logging::Layouts::Pattern","Logging/Layouts/Pattern.html#method-c-new","( opts = {} )","<p>Creates a new Pattern layout using the following options.\n\n<pre class=\"ruby\">:<span class=\"ruby-identifier\">pattern</span>       =<span class=\"ruby-operator\">&gt;</span>  <span class=\"ruby-string\">&quot;[%d] %-5l -- %c : %m\\n&quot;</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["new","Logging::Logger","Logging/Logger.html#method-c-new",null,""],["new","Logging::Logger","Logging/Logger.html#method-c-new","( name )","<p>Returns the logger identified by <em>name</em>.\n<p>When <em>name</em> is a <code>String</code> or a <code>Symbol</code> it\nwill be used “as is” …\n"],["new","Logging::Logger","Logging/Logger.html#method-c-new","( *args )","<p>Overrides the new method such that only one Logger will be created for any\ngiven logger name.\n"],["new","Logging::Proxy","Logging/Proxy.html#method-c-new","( object, &block )","<p>Create a new proxy for the given <em>object</em>. If an optional\n<em>block</em> is given it will be called before the proxied …\n"],["new","Logging::Repository","Logging/Repository.html#method-c-new","()","<p>nodoc:\n<p>This is a singleton class – use the <code>instance</code> method to obtain\nthe <code>Repository</code> instance.\n"],["new","Logging::RootLogger","Logging/RootLogger.html#method-c-new","( )","<p>Returns a new root logger instance. This method will be called only once\nwhen the <code>Repository</code> singleton …\n"],["new","ReentrantMutex","ReentrantMutex.html#method-c-new","()",""],["off?","Logging::Appender","Logging/Appender.html#method-i-off-3F","()","<p>Returns `true` if the appender has been turned off. This is useful for\nappenders that write data to a …\n"],["original_synchronize","ReentrantMutex","ReentrantMutex.html#method-i-original_synchronize","()",""],["parent","Logging::Repository","Logging/Repository.html#method-i-parent","( key )","<p>Returns the parent logger for the logger identified by <em>key</em> where\n<em>key</em> follows the same identification …\n"],["parent=","Logging::Logger","Logging/Logger.html#method-i-parent-3D","( parent )","<p>Set the parent logger for this logger. This method will be invoked by the\n<code>Repository</code> class when a parent …\n"],["parent=","Logging::Logger","Logging/Logger.html#method-i-parent-3D",null,""],["parent_name","Logging::Repository","Logging/Repository.html#method-i-parent_name","( key )","<p>Returns the name of the parent for the logger identified by the given\n<em>key</em>. If the <em>key</em> is for the root …\n"],["parseable","Logging::Layouts","Logging/Layouts.html#method-c-parseable","()","<p>Accessor for the Parseable layout.\n"],["path","Logging","Logging.html#method-c-path","( *args, &block )","<p>Returns the lpath for the module. If any arguments are given, they will be\njoined to the end of the path …\n"],["pattern","Logging::Layouts","Logging/Layouts.html#method-c-pattern","( *args )","<p>Accessor / Factory for the Pattern layout.\n<p>Returns a new Pattern layout instance\n"],["pattern=","Logging::Layouts::Pattern","Logging/Layouts/Pattern.html#method-i-pattern-3D","( var )","<p>Set the message formatting pattern to be used by the layout.\n"],["peek","Logging::MappedDiagnosticContext","Logging/MappedDiagnosticContext.html#method-i-peek","()","<p>Returns the most current Hash from the stack of contexts.\n"],["peek","Logging::NestedDiagnosticContext","Logging/NestedDiagnosticContext.html#method-i-peek","()","<p>Public: Looks at the last diagnostic context at the top of this NDC without\nremoving it. The returned …\n"],["pop","Logging::MappedDiagnosticContext","Logging/MappedDiagnosticContext.html#method-i-pop","()","<p>Public: Remove the most recently pushed Hash from the stack of contexts. If\nno contexts have been pushed …\n"],["pop","Logging::NestedDiagnosticContext","Logging/NestedDiagnosticContext.html#method-i-pop","()","<p>Public: Clients should call this method before leaving a diagnostic\ncontext. The returned value is the …\n"],["push","Logging::MappedDiagnosticContext","Logging/MappedDiagnosticContext.html#method-i-push","( hash )","<p>Public: Push a new Hash of key/value pairs onto the stack of contexts.\n<p>hash - The Hash of values to push …\n"],["push","Logging::NestedDiagnosticContext","Logging/NestedDiagnosticContext.html#method-i-push","( message )","<p>Public: Push new diagnostic context information for the current thread. The\ncontents of the message parameter …\n"],["remove","Logging::Appenders","Logging/Appenders.html#method-i-remove","( name )","<p>Removes the appender instance stored in the appender hash under the key\n<em>name</em>.\n"],["remove_appenders","Logging::Logger","Logging/Logger.html#method-i-remove_appenders",null,""],["remove_appenders","Logging::Logger","Logging/Logger.html#method-i-remove_appenders","( *args )","<p>Remove the given <em>appenders</em> from the list of appenders. The\nappenders to remove can be identified either …\n"],["reopen","Logging","Logging.html#method-c-reopen","()","<p>Reopen all appenders. This method should be called immediately after a fork\nto ensure no conflict with …\n"],["reopen","Logging::Appender","Logging/Appender.html#method-i-reopen","()","<p>Reopen the connection to the underlying logging destination. If the\nconnection is currently closed then …\n"],["reopen","Logging::Appenders::Buffering","Logging/Appenders/Buffering.html#method-i-reopen","()","<p>Reopen the connection to the underlying logging destination. In addition if\nthe appender is configured …\n"],["reopen","Logging::Appenders::File","Logging/Appenders/File.html#method-i-reopen","()","<p>Reopen the connection to the underlying logging destination. If the\nconnection is currently closed then …\n"],["reopen","Logging::Appenders::RollingFile","Logging/Appenders/RollingFile.html#method-i-reopen","()","<p>Reopen the connection to the underlying logging destination. If the\nconnection is currently closed then …\n"],["reopen","Logging::Appenders::StringIo","Logging/Appenders/StringIo.html#method-i-reopen","()","<p>Reopen the underlying StringIO instance. If the instance is currently\nclosed then it will be opened. …\n"],["reopen","Logging::Appenders::Syslog","Logging/Appenders/Syslog.html#method-i-reopen","()","<p>Reopen the connection to the underlying logging destination. If the\nconnection is currently closed then …\n"],["reset","Logging::Appenders::StringIo","Logging/Appenders/StringIo.html#method-i-reset","()",""],["reset","Logging::ColorScheme","Logging/ColorScheme.html#method-c-reset","()","<p>Clear all color schemes and setup a default color scheme.\n"],["roll_by_date","Logging::Appenders::RollingFile::Roller","Logging/Appenders/RollingFile/Roller.html#method-i-roll_by_date","( files )","<p>Roll the list of log files optionally removing older files. The “older\nfiles” are determined …\n"],["roll_by_number","Logging::Appenders::RollingFile::Roller","Logging/Appenders/RollingFile/Roller.html#method-i-roll_by_number","( files )","<p>Roll the list of log files optionally removing older files. The “older\nfiles” are determined …\n"],["roll_files","Logging::Appenders::RollingFile::Roller","Logging/Appenders/RollingFile/Roller.html#method-i-roll_files","()","<p>Roll the log files. This method will collect the list of rolled files and\nthen pass that list to either …\n"],["roll_required?","Logging::Appenders::RollingFile","Logging/Appenders/RollingFile.html#method-i-roll_required-3F","()","<p>Returns <code>true</code> if the log file needs to be rolled.\n"],["rolling_file","Logging::Appenders","Logging/Appenders.html#method-c-rolling_file","( *args )","<p>Accessor / Factory for the RollingFile appender.\n"],["root","Logging::Logger","Logging/Logger.html#method-c-root","()","<p>Returns the root logger.\n"],["root","Logging::Logger","Logging/Logger.html#method-c-root",null,""],["sanitize","Logging::MappedDiagnosticContext","Logging/MappedDiagnosticContext.html#method-i-sanitize","( hash, target = {} )","<p>Given a Hash convert all keys into Strings. The values are not altered in\nany way. The converted keys …\n"],["show_configuration","Logging","Logging.html#method-c-show_configuration","( io = STDOUT, logger = 'root', indent = 0 )","<p>This method is used to show the configuration of the logging framework. The\ninformation is written to …\n"],["shrink","String","String.html#method-i-shrink","( width, ellipses = '...')","<p>Shrink the size of the current string to the given <em>width</em> by\nremoving characters from the middle of the …\n"],["silence","Logging::RailsCompat","Logging/RailsCompat.html#method-i-silence","( *args )","<p>A no-op implementation of the <code>silence</code> method. Setting of log\nlevels should be done during the Logging …\n"],["stack","Logging::MappedDiagnosticContext","Logging/MappedDiagnosticContext.html#method-i-stack","()","<p>Returns the stack of Hash objects that are storing the diagnostic context\ninformation. This stack is …\n"],["stderr","Logging::Appenders","Logging/Appenders.html#method-c-stderr","( *args )","<p>Accessor / Factory for the Stderr appender.\n"],["stdout","Logging::Appenders","Logging/Appenders.html#method-c-stdout","( *args )","<p>Accessor / Factory for the Stdout appender.\n"],["string_io","Logging::Appenders","Logging/Appenders.html#method-c-string_io","( *args )","<p>Accessor / Factory for the StringIo appender.\n"],["sync","Logging::Appender","Logging/Appender.html#method-i-sync","( &block )","<p>Obtains an exclusive lock, runs the block, and releases the lock when the\nblock completes. This method …\n"],["synchronize","ReentrantMutex","ReentrantMutex.html#method-i-synchronize","()",""],["syslog","Logging::Appenders","Logging/Appenders.html#method-c-syslog","( *args )","<p>Accessor / Factory for the Syslog appender.\n"],["syslog_level_num","Logging::Appenders::Syslog","Logging/Appenders/Syslog.html#method-i-syslog_level_num","( level )","<p>Takes the given <em>level</em> as a string, symbol, or integer and returns\nthe corresponding syslog level number. …\n"],["to_constant","Logging::ColorScheme","Logging/ColorScheme.html#method-i-to_constant","( v )","<p>Return a normalized representation of a color setting.\n"],["to_key","Logging::ColorScheme","Logging/ColorScheme.html#method-i-to_key","( t )","<p>Return a normalized representation of a color name.\n"],["to_key","Logging::Repository","Logging/Repository.html#method-i-to_key","( key )","<p>Takes the given <em>key</em> and converts it into a form that can be used\nto retrieve a logger from the <code>Repository</code> …\n"],["try_json","Logging::Layout","Logging/Layout.html#method-i-try_json","( obj )","<p>Attempt to format the given object as a JSON string, but fall back to\ninspect formatting if JSON encoding …\n"],["try_yaml","Logging::Layout","Logging/Layout.html#method-i-try_yaml","( obj )","<p>Attempt to format the <em>obj</em> using yaml, but fall back to inspect\nstyle formatting if yaml fails.\n<p>obj -  …\n"],["update","Logging::MappedDiagnosticContext","Logging/MappedDiagnosticContext.html#method-i-update","( hash )","<p>Public: Add all the key/value pairs from the given hash to the current\nmapped diagnostic context. The …\n"],["version","Logging","Logging.html#method-c-version","()","<p>Returns the version string for the library.\n"],["write","Logging::Appender","Logging/Appender.html#method-i-write","( event )","<p>Writes the given <em>event</em> to the logging destination. Subclasses\nshould provide an implementation of this …\n"],["write","Logging::Appenders::Buffering","Logging/Appenders/Buffering.html#method-i-write","( event )","<p>Writes the given <em>event</em> to the logging destination. The\n<em>event</em> can be either a LogEvent or a String. If …\n"],["write","Logging::Appenders::Syslog","Logging/Appenders/Syslog.html#method-i-write","( event )","<p>Write the given <em>event</em> to the syslog facility. The log event will\nbe processed through the Layout associated …\n"],["write","Logging::Logger","Logging/Logger.html#method-i-write",null,""],["write","Logging::Logger","Logging/Logger.html#method-i-write","( msg )",""],["yaml","Logging::Layouts","Logging/Layouts.html#method-c-yaml","( *args )","<p>Factory for the Parseable layout using YAML formatting.\n"],["yaml","Logging::Layouts::Parseable","Logging/Layouts/Parseable.html#method-c-yaml","( opts = {} )","<p>Create a new Parseable layout that outputs log events using YAML style\nformatting. See the initializer …\n"],["History","","History_txt.html","","<p>2.0.0 / 2015-03-28\n<p>Enhancements\n<p>added event filtering via the Filter framework\n"]]}}